# Design de banco de dados usando diagramas de entidade-relacionamento

Essenciais para o projeto de bancos de dados, os diagramas entidade-relacionamento \(ER\) são conhecidos por sua utilidade na modelagem de dados e no mapeamento claro de projetos de bancos de dados. Eles também são conhecidos por serem difíceis de dominar. Com o livro "Design de Banco de Dados Usando Diagramas Entidade-Relacionamento", Terceira Edição, designers de banco de dados, desenvolvedores e estudantes que se preparam para ingressar na área podem aprender rapidamente os detalhes da modelagem de dados por meio da diagramação ER.

Com base no sucesso das edições best-sellers primeira e segunda, este texto acessível inclui um novo capítulo sobre o modelo relacional e dependências funcionais. Inclui também capítulos expandidos sobre diagramas Entidade-Relacionamento Aprimorados \(EER\) e mapeamento reverso. Utiliza estudos de caso e exemplos de ponta para ajudar os leitores a dominar os fundamentos do desenvolvimento de banco de dados e define diagramas ER e EER em termos de requisitos \(solicitações do usuário final\) e especificações \(feedback do designer a essas solicitações\), facilitando o desenvolvimento ágil de bancos de dados. Este livro

+ Descreve uma abordagem passo a passo para produzir um diagrama ER e desenvolver um banco de dados relacional a partir dele
+ Contém exercícios, exemplos, estudos de caso, bibliografias e resumos em cada capítulo
+ Detalha as regras para mapear diagramas ER para bancos de dados relacionais
+ Explica como fazer engenharia reversa de um banco de dados relacional de volta para um modelo entidade-relacionamento
+ Inclui gramática para os diagramas ER que podem ser apresentados ao usuário, facilitando o desenvolvimento ágil do banco de dados

Os exercícios e resumos dos capítulos atualizados fornecem a compreensão prática necessária para desenvolver diagramas ER e EER, mapeá-los para bancos de dados relacionais e testar o banco de dados relacional resultante. Completa com uma riqueza de exercícios e exemplos adicionais, esta edição deve ser um componente básico de qualquer curso de banco de dados. Sua natureza abrangente e estrutura de fácil navegação fazem dela um recurso ao qual estudantes e profissionais recorrerão ao longo de suas carreiras.


# Design de banco de dados usando diagramas de entidade-relacionamento

Terceira edição

Sikha Saha Bagui, Richard Walsh Earp

Terceira edição publicada em 2023

Foram feitos esforços razoáveis para publicar dados e informações confiáveis, mas o autor e a editora não podem assumir responsabilidade pela validade de todos os materiais ou pelas consequências de seu uso. Os autores e as editoras tentaram rastrear os detentores dos direitos autorais de todo o material reproduzido nesta publicação e pedem desculpas aos detentores dos direitos autorais caso não tenham obtido a permissão para publicar neste formato. Caso algum material protegido por direitos autorais não tenha sido reconhecido, por favor, escreva-nos e nos informe para que possamos retificar em qualquer reimpressão futura.

Exceto conforme permitido pela Lei de Direitos Autorais dos EUA, nenhuma parte deste livro pode ser reimpressa, reproduzida, transmitida ou utilizada de qualquer forma por qualquer meio eletrônico, mecânico ou outro, conhecido atualmente ou inventado posteriormente, incluindo fotocópia, microfilmagem e gravação, ou em qualquer sistema de armazenamento ou recuperação de informações, sem a permissão por escrito dos editores.

Para obter permissão para fotocopiar ou usar material eletronicamente desta obra, acesse www.copyright.com ou entre em contato com o Copyright Clearance Center, Inc. \(CCC\), 222 Rosewood Drive, Danvers, MA 01923, 978–750–8400. Para obras que não estão disponíveis no CCC, entre em contato com mpkbookspermissions@tandf.co.uk.

Aviso de marca registrada: nomes de produtos ou corporativos podem ser marcas comerciais ou marcas registradas e são usados somente para identificação e explicação, sem intenção de violação.

ISBN: 978-1-032-01718-1 \(hbk\)

ISBN: 978-1-032-32321-3 \(pbk\)

ISBN: 978-1-003-31445-5 \(ebk\)

DOI: 10.1201/9781003314455

Composto em Minion

por Apex CoVantage, LLC





Dedicado ao meu pai, Santosh Saha; mãe, Ranu

Saha; marido, Subhash; filhos, Sumon e Sudip; irmão,

Pradeep Saha; e sobrinhas, Priyashi e Piyali.

S.S.B.

Dedicado à minha falecida esposa, Brenda, e aos meus

filhos, Beryl, Rich, Gen e Mary Jo.

E à minha esposa, Anne, que me incentivou a atualizar

este trabalho e editou meticulosamente cada palavra.

R.W.E.





# Conteúdo





Prefácio

Agradecimentos

Autores

Introdução

Capítulo 1 Dados, Bancos de Dados e o Processo de Engenharia de Software

1.1 Introdução

1.2 Dados

1.3 Construindo um Banco de Dados

1.4 O que é o processo de engenharia de software?

1.5 Diagramas de Entidade-Relacionamento e o Ciclo de Vida da Engenharia de Software

1.5.1 Fase 1: Obter os requisitos para o banco de dados

1.5.2 Fase 2: Especificar o Banco de Dados

1.5.3 Fase 3: Projetar o Banco de Dados

1.6 Resumo do Capítulo

Exercícios do Capítulo 1

Bibliografia

Capítulo 2 Dados e Modelos de Dados

2.1 Introdução

2.2 Arquivos, registros e itens de dados

2.3 Migrando de cartões 3 × 5 para computadores

2.4 Modelos de Banco de Dados

2.4.1 O Modelo Hierárquico

2.4.1.1 O Modelo Hierárquico com uma Lista Encadeada

2.4.1.2 Terminologia de Relacionamento

2.4.1.3 Desvantagens do Modelo Hierárquico

2.5 O Modelo de Rede

2.6 O Modelo Relacional

2.7 Resumo do Capítulo

Bibliografia

Capítulo 3 O Modelo Relacional e Dependências Funcionais

3.1 Introdução

3.2 Fundamentos do Banco de Dados Relacional

3.3 Banco de Dados Relacional e Conjuntos

3.4 Dependência Funcional

3.5 Não-1NF para 1NF

3.6 A Segunda Forma Normal

3.6.1 Anomalias

3.6.2 Não-2NF para 2NF

3.7 A Terceira Forma Normal

3.8 A Operação Equijoin

3.9 Algumas regras de dependência funcional

3.10 A forma normal de Boyce-Codd

3.11 Resumo do Capítulo

Exercícios do Capítulo 3

Bibliografia

Capítulo 4 O Diagrama ER Básico: Um Esquema de Modelagem de Dados

4.1 Introdução

4.2 O que é um esquema de modelagem de dados?

4.2.1 O que é um diagrama de entidade-relacionamento?

4.3 Definindo um Banco de Dados — Algumas Definições: Entidade, Relacionamento e Atributo

4.3.1 Uma Metodologia Inicial

4.3.2 Metodologia de Projeto ER

4.4 Um primeiro diagrama ER “somente entidade”: uma entidade com atributos

4.5 Mais sobre Atributos

4.5.1 O Atributo Simples ou Atômico

4.5.2 O Atributo Composto

4.5.3 O Atributo Multivalorado

4.5.4 O Atributo Derivado

4.5.5 Chaves

4.6 Descrição em inglês da entidade

4.6.1 O Método

4.6.1.1 A Entidade

4.6.1.2 Os Atributos

4.6.1.3 As Chaves

4.6.2 Metodologia de Projeto ER

4.6.3 Exemplos

4.6.3.1 Figura 4.3 Exemplo

4.6.3.2 Figura 4.4 Exemplo

4.6.3.3 Figura 4.5a Exemplo

4.6.3.4 Figura 4.6 Exemplo

4.6.3.5 Figura 4.7 Exemplo

4.7 Mapeando o Diagrama de Entidades para um Banco de Dados Relacional

4.8 Resumo do Capítulo

Exercícios do Capítulo 4

Estudo de caso

Notas

Bibliografia

Capítulo 5 Além do Primeiro Diagrama de Entidade

5.1 Introdução

5.2 Examinando uma Entidade: Alterando um Atributo para Ser uma Entidade

5.3 Definindo um relacionamento para nossa nova entidade

5.3.1 Metodologia de Projeto ER

5.4 Uma gramática preliminar para diagramas ER

5.4.1 O Relacionamento

5.5 Definindo uma segunda entidade

5.6 Existe um relacionamento?

5.7 Atributo ou relacionamento?

5.7.1 Metodologia de Projeto ER

5.8 Resumo do Capítulo

Exercícios do Capítulo 5

Estudo de caso

Bibliografia

Capítulo 6 Estendendo Relacionamentos/Restrições Estruturais

6.1 Introdução

6.2 A proporção de cardinalidade de um relacionamento

6.2.1 Um para um \(1:1\)

6.2.2 Muitos para Um \(M:1\)

6.2.3 Um para muitos \(1:M\)

6.2.4 Muitos para muitos \(M:N\)

6.3 Participação: Total/Parcial

6.4 Descrições em inglês

6.5 Inglês mais rigoroso

6.5.1 Padrão 1—x:y::k:1

6.5.2 Padrão 2—x:y::k:1

6.5.3 Padrão 3—x:y::k:M

6.5.4 Padrão 4—x:y::k:M

6.5.5 Resumo dos Padrões e Relacionamentos

6.5.5.1 Padrão 1

6.5.5.2 Padrão 1

6.5.5.3 Padrão 2

6.5.5.4 Padrão 2

6.5.5.5 Padrão 3

6.5.5.6 Padrão 3

6.5.5.7 Padrão 4

6.5.5.8 Padrão 4

6.5.6 Metodologia de Projeto ER

6.6 Alguns exemplos de outros relacionamentos

6.6.1 Um exemplo do relacionamento um-para-muitos \(1:M\)

6.6.1.1 Padrão 4–1:M, Do Lado 1, Participação Parcial

6.6.1.2 Padrão 2—M\(Parcial\):1, Do Lado M, Participação Opcional

6.6.2 Um exemplo de relacionamento muitos-para-um \(M:1\)

6.6.2.1 Padrão 1—M:1, Do Lado M, Participação Plena

6.6.2.2 Padrão 3–1:M, Do Lado 1, Participação Plena

6.6.3 Um exemplo de relacionamento muitos-para-muitos \(M:N\)

6.6.3.1 Padrão 3 — M:N, Do Lado M, Participação Plena

6.6.3.2 Padrão 4—N:M, Do Lado N, Participação Parcial

6.7 Um Exemplo Final

6.7.1 Metodologia de Projeto ER

6.7.1.1 A Entidade

6.7.1.2 A Entidade

6.7.2 Padrão 1—M:1, Do Lado M, Participação Plena

6.7.3 Padrão 3–1:M, Do Lado 1, Participação Plena

6.8 Mapeando relacionamentos para um banco de dados relacional

6.8.1 Mapeando relacionamentos binários M:N

6.8.2 Mapeando relacionamentos binários 1:1

6.8.3 Mapeando relacionamentos binários 1:N

6.9 Resumo do Capítulo

Exercícios do Capítulo 6

Estudo de caso

Observação

Bibliografia

Capítulo 7 A Entidade Fraca

7.1 Introdução

7.2 Entidades fortes e fracas

7.3 Entidades Fracas e Restrições Estruturais

7.4 Entidades Fracas e o Proprietário Identificador

7.4.1 Outro exemplo de uma entidade fraca e o proprietário que a identifica

7.5 Entidades Fracas Conectadas a Outras Entidades Fracas

7.6 Revisitando a Metodologia

7.7 Gramática de Entidade Fraca

7.7.1 As Chaves

7.8 Mapeando Entidades Fracas para um Banco de Dados Relacional

7.9 Resumo do Capítulo

Exercícios do Capítulo 7

Estudo de caso

Bibliografia

Capítulo 8 Extensões adicionais para diagramas ER com relacionamentos binários

8.1 Introdução

8.2 Atributos dos Relacionamentos

8.2.1 Os Atributos

8.3 Relacionamentos que se desenvolvem em entidades: o relacionamento M:N revisitado

8.3.1 A Entidade

8.3.1.1 Os Atributos

8.3.1.2 As Chaves

8.4 Mais Entidades e Relacionamentos

8.4.1 Mais de duas entidades

8.4.1.1 Padrão 4—x:y::1:M, Do Lado 1, Participação Parcial

8.4.1.2 Padrão 1—x:y::M:1, Do Lado M, Participação Total

8.4.2 Adicionando mais atributos que evoluem para entidades

8.5 Mais Evolução do Banco de Dados

8.6 Atributos que evoluem para entidades

8.7 Relacionamentos Recursivos

8.7.1 Relacionamentos recursivos e restrições estruturais

8.7.1.1 Relacionamento recursivo um-para-um \(participação parcial em ambos os lados\)

8.7.1.2 Relacionamento recursivo um-para-muitos \(participação parcial em ambos os lados\)

8.7.1.3 Relacionamento recursivo muitos-para-muitos \(parcial em ambos os lados\)

8.8 Relacionamentos Múltiplos

8.9 O Relacionamento Derivado ou Redundante

8.10 Opcional: Uma notação ER alternativa para especificar restrições estruturais em relacionamentos

8.11 Revisão da Metodologia

8.11.1 Metodologia de Projeto ER

8.11.2 A Entidade

8.11.2.1 Os Atributos

8.11.2.2 As Chaves

8.12 Regras de mapeamento para relacionamentos recursivos

8.13 Resumo do Capítulo

Exercícios do Capítulo 8

Estudo de caso

Bibliografia

Capítulo 9 Diagramas ER Ternários e de Ordem Superior

9.1 Introdução

9.2 Relação binária ou ternário?

9.3 Restrições Estruturais para Relacionamentos Ternários

9.3.1 Muitos para muitos para muitos \(M1:M2:M3\)

9.4 Um exemplo de um relacionamento n-ário

9.5 Relacionamentos n-ários não impedem relacionamentos binários

9.6 Metodologia e gramática para o relacionamento n-ário

9.6.1 Uma gramática mais exata

9.6.1.1 Padrão 3 — M:N, Do Lado M, Participação Plena

9.6.1.2 Padrão 3—k:M, do lado k, Participação total \(k = 1 ou N\)

9.6.1.3 Padrão 5 \(n-ário\)—x:y:z::a:b:c, Do lado a, Participação total/parcial

9.6.2 Gramática em uma Participação Parcial, Relacionamento Ternário com um Relacionamento M1:1:M2

9.7 Relacionamentos Ternários de Situações Relacionamento-Relacionamento

9.8 Relacionamentos n-ários que podem ser resolvidos em relacionamentos binários

9.9 Mapeando relacionamentos n-ários para um banco de dados relacional

9.10 Revisão da Metodologia

9.10.1 Metodologia de Projeto ER

Resumo do Capítulo 9.11

Exercícios do Capítulo 9

Bibliografia

Capítulo 10 O Modelo Entidade-Relacionamento Aprimorado \(EER\)

10.1 Introdução

10.2 O que é uma generalização ou especialização?

10.3 Variantes

10.4 Exemplos de generalizações ou especializações

10.5 Metodologia e gramática para relacionamentos de generalização/especialização

10.6 Regras de mapeamento para generalizações e especializações

10.6.1 Regra de Mapeamento 15

10.6.2 Regra de mapeamento 16

10.6.3 Regra de mapeamento 17

10.6.4 Regra de mapeamento 18

10.7 Subclasses de Subclasses

10.7.1 Regra de mapeamento 19

10.8 Categorias ou Tipos de União

10.8.1 Taxas de participação em categorias ou tipos de sindicatos

10.8.2 Mapeando categorias ou tipos de união quando superclasses têm as mesmas chaves primárias

10.8.3 Mapeando categorias ou tipos de união quando superclasses têm chaves primárias diferentes

10.9 Metodologia Final de Projeto de ER

10.9.1 Metodologia de Projeto ER

Resumo do Capítulo 10.10

Exercícios do Capítulo 10

Estudo de caso

Bibliografia

Capítulo 11 Mapeamento Relacional e Engenharia Reversa de Diagramas ER/EER

11.1 Introdução

11.2 Etapas usadas para mapear diagramas ER/EER para bancos de dados relacionais

11.3 Engenharia Reversa

11.3.1 Regra 1 da Engenharia Reversa. Desenvolver Entidades Fortes

11.3.2 Regra 2 da Engenharia Reversa. Procure por relacionamentos 1:1 e 1:N \(1:x\)

11.3.3 Regra 2a da Engenharia Reversa. Verificação dos Atributos do Relacionamento 1:x

11.3.4 Regra 3 da Engenharia Reversa. Procure por Entidades Fracas e Atributos Multivalorados

11.3.5 Regra 3a da Engenharia Reversa. Verificação de Entidades Fracas

11.3.6 Regra 3b da Engenharia Reversa. Verificação de Atributos Multivalorados

11.3.7 Regra 4 da Engenharia Reversa. Verifique os relacionamentos M:N e n-ário

11.3.8 Regra 4a da Engenharia Reversa. Verifique o Caso Binário

11.3.9 Regra 4b da Engenharia Reversa. Verifique o Caso n-ário

11.3.10 Regra 5 da Engenharia Reversa. Verifique se há relações de generalização/especialização

11.3.11 Regra 5a da Engenharia Reversa. Verificar se há relacionamentos de generalização/especialização com relacionamentos disjuntos ou sobrepostos com restrições de participação total ou parcial.

11.3.12 Regra 5b da Engenharia Reversa. Verifique se há relacionamentos de generalização/especialização disjuntos com atributos definidos por um único predicado.

11.3.13 Regra 5c de Engenharia Reversa. Verifique se há sobreposição entre a relação de generalização/especialização e mais de um sinalizador.

11.3.14 Regra 6 da Engenharia Reversa. Verificar Subclasses Compartilhadas

11.3.15 Regra 7 de Engenharia Reversa. Verifique se há categorias ou tipos de união

11.4 Resumo do Capítulo

Exercícios do Capítulo 11

Bibliografia

Capítulo 12 Uma breve visão geral do modelo Barker/Oracle-Like

12.1 Introdução

12.2 Um primeiro diagrama ER “somente entidade”: uma entidade com atributos

12.3 Atributos no modelo Barker/Oracle-Like

12.3.1 Atributos opcionais versus obrigatórios

12.4 Relacionamentos no modelo Barker/Oracle-Like

12.5 Restrições Estruturais no Modelo Barker/Oracle-Like

12.6 Lidando com o Conceito de Entidade Fraca no Modelo Barker/Oracle-Like

12.7 Lidando com o Conceito de Atributos Multivalorados no Modelo Barker/Oracle-Like

12.8 Tratamento de Chaves Estrangeiras

12.9 Relacionamentos recursivos no modelo Barker/Oracle

12.10 Mapeando relacionamentos M:N

Resumo do Capítulo 12.11

Exercícios do Capítulo 12

Bibliografia

Glossário

Índice





# Prefácio





A modelagem de dados e o design de bancos de dados passaram por uma evolução significativa nos últimos anos. Hoje, o modelo de dados relacional e o sistema de banco de dados relacional dominam as aplicações de negócios. O modelo relacional permitiu que o designer de banco de dados se concentrasse nas características lógicas e físicas de um banco de dados separadamente. Neste livro, nos concentramos em técnicas de design de banco de dados com forte viés para sistemas de banco de dados relacional, utilizando a abordagem ER \(entidade-relacionamento\) para modelagem conceitual \(apenas uma implementação lógica\).



## PÚBLICO-ALVO

Este livro destina-se a ser utilizado em modelagem de dados por profissionais e estudantes de banco de dados. Também se destina a ser utilizado como texto suplementar em cursos de banco de dados, análise e projeto de sistemas e outros cursos que projetam e implementam bancos de dados. Muitos livros atuais de banco de dados e análise e projeto de sistemas limitam sua abordagem à modelagem de dados. Este livro não apenas amplia a exposição aos conceitos de modelagem de dados, como também apresenta uma abordagem passo a passo para projetar um diagrama ER e desenvolver um banco de dados relacional a partir dele.





## DESTAQUES DO LIVRO

Este livro concentra-se na modelagem de dados utilizando diagramas entidade-relacionamento \(ER\), apresentando \(a\) uma metodologia de projeto de Entidade-Relacionamento \(ER\) para o desenvolvimento de um diagrama ER; \(b\) uma gramática para os diagramas ER que pode ser apresentada ao usuário, facilitando o desenvolvimento ágil de bancos de dados; e \(c\) regras de mapeamento para mapear o diagrama ER para um banco de dados relacional. As etapas da metodologia de projeto ER, a gramática para os diagramas ER, bem como as regras de mapeamento, são desenvolvidas e apresentadas de forma sistemática e passo a passo ao longo do livro. Além disso, vários exemplos de dados de amostra foram incluídos com mapeamentos de bancos de dados relacionais para dar uma sensação "realista".

Este livro está dividido em 12 capítulos. Os três primeiros capítulos são materiais de apoio. O Capítulo 1 apresenta os conceitos de dados, banco de dados e engenharia de software. O Capítulo 2 apresenta diferentes modelos de banco de dados. O Capítulo 3 apresenta o modelo relacional e discute as dependências funcionais usadas para gerar bancos de dados de terceira forma normal.

A partir do Capítulo 4, começamos a apresentar o conceito de diagramas ER. O Capítulo 4 introduz o conceito de entidade, atributos, relacionamentos e o diagrama ER de "entidade única". As etapas 1, 2 e 3 da metodologia de projeto ER são desenvolvidas neste capítulo. A gramática de entidade única e as regras de mapeamento para o diagrama de entidade única são apresentadas.

O Capítulo 5 estende o diagrama de uma entidade para incluir uma segunda entidade. O conceito de teste de atributos para entidades é discutido e os relacionamentos entre as entidades são desenvolvidos. As etapas 3a, 3b, 4, 5 e 6 da Metodologia de Design ER são desenvolvidas, e a gramática para os diagramas ER desenvolvidos até este ponto é apresentada.

O Capítulo 6 discute restrições estruturais em relacionamentos. São apresentados vários exemplos de relacionamentos 1:1, 1:M e N:M. A etapa 6 da metodologia de projeto ER é revisada e a etapa 7 é desenvolvida. Uma gramática para as restrições estruturais e as regras de mapeamento também são apresentadas.

O Capítulo 7 desenvolve o conceito de entidade fraca. Este capítulo revisita e revisa as etapas 3 e 4 da metodologia de design de ER para incluir a entidade fraca. Novamente, são apresentadas uma gramática e as regras de mapeamento para a entidade fraca.

O Capítulo 8 discute e expande diferentes aspectos dos relacionamentos binários em diagramas ER. Este capítulo revisa a etapa 5 para incluir o conceito de mais de um relacionamento e revisa a etapa 6b para incluir relacionamentos derivados e redundantes. O conceito de relacionamento recursivo é introduzido neste capítulo. A gramática e as regras de mapeamento para relacionamentos recursivos são apresentadas.

O Capítulo 9 discute relacionamentos ternários e outros relacionamentos de "ordem superior". A Etapa 6 da metodologia de projeto ER é novamente revisada para incluir relacionamentos ternários e outros relacionamentos de ordem superior. Vários exemplos são apresentados, e as regras gramaticais e de mapeamento são desenvolvidas e apresentadas.

O Capítulo 10 discute relacionamentos de entidades aprimorados \(EERs\): generalizações e especializações, subclasses compartilhadas e categorias ou tipos de união. Mais uma vez, a etapa 6 da metodologia de projeto de ER é modificada para incluir generalizações e especializações, e a gramática e as regras de mapeamento para o mapeamento do EER são apresentadas.

O Capítulo 11 apresenta um resumo das regras de mapeamento e da engenharia reversa de um banco de dados relacional para um diagrama ER. A engenharia reversa é útil para descrever bancos de dados existentes que podem ter evoluído, mas para os quais não existe documentação.

Os Capítulos 4 a 11 apresentam diagramas ER e EER usando um modelo do tipo Chen. No Capítulo 12, discutimos os modelos do tipo Barker/Oracle, destacando as principais semelhanças e diferenças entre os modelos do tipo Chen e do tipo Barker/Oracle.

Em cada capítulo, apresentamos inúmeros exemplos. Seções de "Pontos de Verificação" dentro dos capítulos e exercícios no final de cada capítulo são apresentados em cada capítulo, para serem estudados pelo leitor a fim de obter uma melhor compreensão do material contido nas respectivas seções e capítulos. Ao final dos Capítulos 4 a 10, há um estudo de caso em andamento, com a solução \(ou seja, o diagrama ER/EER e o banco de dados relacional com alguns dados de exemplo\).





# Agradecimentos





Nossos agradecimentos especiais aos nossos editores, John Wyzalek e Stephanie Kiefer, da CRC Press/Taylor & Francis Group.





# Autores





Sikha Saha Bagui é Professora Universitária Emérita e Askew Fellow no Departamento de Ciência da Computação da Universidade da Flórida Ocidental, em Pensacola, Flórida. Ela leciona nas áreas de banco de dados e análise de dados, e seus interesses de pesquisa são design de banco de dados, mineração de dados, análise de Big Data e aprendizado de máquina. A Dra. Bagui trabalhou em projetos de pesquisa financiados e não financiados e possui mais de 100 publicações revisadas por pares. A Dra. Bagui é coautora de vários livros com o Dr. Earp e faz parte do conselho editorial de diversos periódicos.

Richard Walsh Earp, Professor Emérito, é ex-presidente e ex-professor associado do Departamento de Ciência da Computação e ex-reitor da Faculdade de Ciência e Tecnologia da Universidade da Flórida Ocidental em Pensacola, Flórida. O Dr. Earp também foi instrutor da Learning Tree International e trabalhou para a Computer Sciences Corporation na Estação Aérea Naval em Pensacola como consultor de banco de dados após sua aposentadoria da academia. Ele é coautor de vários livros com o Dr. Bagui.





# Introdução





Este livro foi escrito para auxiliar alunos em aulas de banco de dados e profissionais de banco de dados a entender como chegar a um projeto de banco de dados definido e claro usando um diagrama entidade-relacionamento \(ER\). Ao projetar um banco de dados com um diagrama ER, reconhecemos que esta é apenas uma maneira de atingir o objetivo: o banco de dados. Existem outras metodologias de projeto que também produzem bancos de dados, mas um diagrama ER é o mais comum. O diagrama ER é um subconjunto do que chamamos de "modelos semânticos". À medida que avançamos neste material, ocasionalmente apontamos onde outros modelos diferem do modelo ER.

O modelo ER é uma das ferramentas mais conhecidas para projeto lógico de bancos de dados. Dentro da comunidade de bancos de dados, é considerado uma maneira natural e fácil de entender de conceituar a estrutura de um banco de dados. As alegações que foram feitas a seu favor incluem o seguinte: é simples e facilmente compreendido por não especialistas; é facilmente conceituado, as construções básicas \(entidades e relacionamentos\) são altamente intuitivas e, portanto, fornecem uma maneira natural de representar os requisitos de informação de um usuário; e é um modelo que descreve um mundo em termos de entidades e atributos que é mais adequado para usuários finais ingênuos em computadores. Em contraste, muitos educadores relataram que os alunos em cursos de banco de dados têm dificuldade em compreender os conceitos da abordagem ER, particularmente ao aplicá-los a problemas do mundo real.

Adotamos a abordagem de começar com uma entidade e, a partir dela, desenvolver uma "estratégia de dentro para fora" \(conforme mencionado em Elmasri e Navathe, 2016\). A engenharia de software envolve extrair de um usuário \(talvez\) "ingênuo" o que ele gostaria de ter armazenado em um sistema de informação. O processo que apresentamos segue o paradigma de engenharia de software de requisitos/especificações, com o diagrama ER sendo o núcleo da especificação. Projetar uma solução de software depende de uma elicitação correta. Na maioria dos paradigmas de engenharia de software, o processo começa com uma elicitação de requisitos seguida por uma especificação e, em seguida, um ciclo de feedback. Em termos simples, a ideia é \(a\) "diga-me o que você quer" \(requisitos\), depois \(b\) "isso é o que eu acho que você quer" \(especificação\). Esse processo de requisitos/especificação pode \(e provavelmente deve\) ser iterativo para que o usuário entenda o que obterá do sistema e o analista entenda o que o usuário deseja, facilitando o desenvolvimento ágil de bancos de dados.

Apresenta-se uma metodologia para a produção de um diagrama ER. O processo leva a um diagrama ER que é então traduzido para um inglês simples \(mas preciso\) que o usuário possa compreender. O mecanismo iterativo assume então o controle para chegar a uma especificação \(um diagrama ER revisado e em inglês\) que tanto o usuário quanto o analista compreendam. O mapeamento do diagrama ER para um banco de dados relacional é apresentado; o mapeamento para outros modelos lógicos de banco de dados não é abordado. Acreditamos que o banco de dados relacional é o mais apropriado para demonstrar mapeamentos, visto que é o modelo de banco de dados contemporâneo mais utilizado. Na verdade, a ideia por trás do diagrama ER é produzir um modelo de banco de dados de alto nível que não tenha um modelo lógico específico \(relacional, hierárquico, orientado a objetos ou de rede\) implícito.

Temos uma forte inclinação para o modelo relacional. A "qualidade" do modelo relacional final é testável por meio da ideia de formas normais. A qualidade do modelo relacional produzido por um mapeamento a partir de um diagrama ER, teoricamente, deveria ser garantida pelo processo de mapeamento. Se um diagrama for "bom o suficiente", o mapeamento para um modelo relacional "bom" deveria ocorrer quase automaticamente. Na prática, o cenário será produzir um diagrama ER tão bom quanto possível, mapeá-lo para um modelo relacional e, em seguida, mudar a discussão para "Este é um bom modelo relacional ou não?", utilizando a teoria das formas normais e outros critérios associados de "qualidade relacional".

A abordagem que adotamos para o projeto de bancos de dados é intuitiva e informal. Não lidamos com definições precisas de relações de conjuntos. Usamos o intuitivo "um/muitos" para cardinalidade e "pode/deve" para restrições de participação. A intenção é fornecer um mecanismo para produzir um diagrama ER que possa ser apresentado a um usuário em inglês e refinar o diagrama em uma especificação que possa então ser mapeada em um banco de dados. Em seguida, sugerimos testar o banco de dados produzido pela teoria das formas normais e outros critérios \(ou seja, restrições de integridade referencial\). Também sugerimos um paradigma de mapeamento reverso para mapear um banco de dados relacional de volta a um diagrama ER para fins de documentação.



## OS MODELOS DE ER QUE ESCOLHEMOS

Começamos nossa aventura em diagramas ER com um modelo "semelhante a Chen", e a maior parte deste livro foi escrita usando o modelo semelhante a Chen. Por que escolhemos esse modelo? Chen \(1976\) introduziu a ideia dos diagramas ER. Elmasri e Navathe \(2016\) e a maioria dos textos sobre bancos de dados usam alguma variante do modelo Chen. Chen e outros aprimoraram o processo de ER ao longo dos anos e, embora não haja um modelo padrão de diagramas ER, o modelo semelhante a Chen e suas variantes são comuns, particularmente em textos abrangentes sobre bancos de dados. No último capítulo, apresentamos brevemente o modelo "semelhante a Barker/Oracle". Assim como no caso do modelo Chen, não seguimos os modelos Barker ou Oracle com precisão e, portanto, usamos o termo modelos semelhantes a Barker/Oracle neste texto.

Há também outras razões para a escolha do modelo Chen-like em detrimento dos demais. Com o modelo Chen-like, não é necessário considerar como o banco de dados será implementado. O modelo Barker-like está mais intimamente ligado ao paradigma de banco de dados relacional. A Oracle Corporation utiliza um diagrama ER mais próximo do modelo Barker. Além disso, nos diagramas ER Barker-like e Oracle-like, não há acomodação para alguns dos recursos que apresentamos no modelo Chen-like. Por exemplo, atributos multivalorados, relacionamentos muitos-para-muitos e entidades fracas não fazem parte do processo de design Barker-like ou Oracle-like.

O processo de design de banco de dados segue o paradigma da engenharia de software ágil e, durante a fase de requisitos e especificações, esboços de diagramas ER são feitos e refeitos. Não é incomum chegar a um design e, em seguida, revisá-lo. Ao desenvolver modelos ER, é preciso perceber que o modelo Chen é desenvolvido para ser independente de implementação. O modelo semelhante a Chen é usado quase exclusivamente por universidades no ensino de banco de dados. As regras de mapeamento do modelo Chen para um banco de dados relacional são relativamente diretas, mas o modelo em si não representa nenhum modelo lógico específico. Embora o modelo semelhante a Barker/Oracle seja popular, sua implementação depende do conhecimento do banco de dados relacional. O modelo semelhante a Barker/Oracle mapeia diretamente para um banco de dados relacional; não há regras reais de mapeamento para esse modelo.



## BIBLIOGRAFIA

+ Chen, P. P. 1976. O modelo entidade-relacionamento - em direção a uma visão unificada de dados, ACM Transactions on Database Systems, 1\(1\). 
+ Elmasri, R., e Navathe, S. B. 2016. Fundamentos de Sistemas de Banco de Dados. Addison Wesley, Reading, MA.





# 1 Dados, bancos de dados e o processo de engenharia de software



DOI: 10.1201/9781003314455-1



## 1.1 INTRODUÇÃO

Neste capítulo, apresentamos alguns conceitos e ideias fundamentais para a nossa apresentação do design de um banco de dados. Definimos dados, descrevemos o conceito de banco de dados e exploramos o processo de design de um banco de dados.



## 1.2 DADOS

Dados, como usamos o termo, são fatos sobre algo ou alguém. Por exemplo, uma pessoa tem um nome, um endereço e um gênero. Alguns dados \(fatos\) sobre uma pessoa específica podem ser "Mary Jo Davis", "123 4th St.", "Feminino". Se tivéssemos uma lista de nomes, endereços e gêneros de várias pessoas, teríamos um conjunto de fatos sobre várias pessoas. Um banco de dados é uma coleção de dados relacionados. Para que esse "conjunto de fatos sobre várias pessoas" seja um banco de dados, esperaríamos que as pessoas no banco de dados tivessem algo em comum — ou seja, fossem "parentes" de alguma forma. Aqui, "parentes" não implica um relacionamento familiar, mas sim algo mais como "pessoas que jogam golfe", "pessoas que têm cachorros" ou "pessoas que entrevistei na rua hoje". Em um "banco de dados de pessoas", espera-se que as pessoas tenham alguma característica comum que as una. Um "conjunto de fatos sobre algumas pessoas" não é um banco de dados até que a característica comum também seja definida. Em outras palavras: por que os nomes e endereços dessas pessoas estão sendo mantidos em uma lista?

Ponto de verificação 1.1

1. Uma árvore é classificada como um “grande carvalho com cerca de 100 anos”. Quais são três fatos sobre esta árvore? 
2. Outra árvore tem as seguintes características: pinheiro, pequeno, com 15 anos. Se eu escrever as informações sobre o carvalho e o pinheiro em um pedaço de papel, você poderia considerar isso um banco de dados? Por que sim ou por que não? 
3. Por que o pedaço de papel não é um banco de dados de árvores?



## 1.3 CONSTRUINDO UM BANCO DE DADOS

Como construímos um banco de dados? Suponha que lhe pedissem para montar um banco de dados com os itens que se guardam numa despensa. Como faria isso? Poderia pegar num pedaço de papel e começar a listar os itens que vê. Quando terminar, deverá ter um banco de dados com os itens na despensa. É bastante simples: tem uma coleção de dados relacionados. Mas vá um passo além: este é um bom banco de dados? A sua abordagem à construção do banco de dados foi uma boa metodologia? A resposta a estas perguntas depende, em parte, do porquê e de como construiu a lista e de quem a utilizará e para quê. Além disso, quem utilizar o banco de dados conseguirá encontrar um facto facilmente? Se for mais metódico, pode primeiro perguntar-se qual a melhor forma de construir este banco de dados antes de pegar no papel e começar a listar os itens. Um pouco de reflexão prévia poupará tempo a longo prazo, porque planeia como a lista será utilizada e por quem.

Ao lidar com software e atividades relacionadas a computadores, como bancos de dados, existe uma ciência do "como fazer" chamada engenharia de software \(ES\). ES é um processo de especificação de sistemas e escrita de software. Para projetar um bom banco de dados, usaremos algumas ideias da ES.

Neste capítulo, apresentamos uma breve descrição de ES no que se refere ao planejamento de nosso banco de dados. Após esta contextualização/visão geral, exploramos modelos de banco de dados, em particular o modelo de banco de dados relacional. Embora historicamente existam muitos tipos de modelos de banco de dados, a maioria dos bancos de dados em uso hoje utiliza um modelo conhecido como "banco de dados relacional". Nosso foco neste livro é propor uma metodologia baseada em ES para projetar um banco de dados relacional sólido.

Ponto de verificação 1.2

Você tem um conjunto de livros em estantes em casa. Alguém lhe pede para fazer uma lista de todos os livros que você tem.

1. Quem vai usar esta lista? 
2. Quando a lista estiver completa, ela será um banco de dados? 
3. Que perguntas devem ser feitas antes de começar? 
4. O que o procedimento de perguntas e respostas da questão 3 vai realizar?



## 1.4 O QUE É O PROCESSO DE ENGENHARIA DE SOFTWARE?

O termo engenharia de software refere-se ao processo de especificação, projeto, escrita, entrega, manutenção e, finalmente, descontinuação de software. Engenheiros de software frequentemente se referem ao "ciclo de vida" do software; o software tem um começo e um fim. Há muitas referências excelentes sobre o tema de Engenharia de Software. Algumas são referenciadas no final deste capítulo.

Alguns autores usam o termo engenharia de software como sinônimo de "análise e projeto de sistemas", mas o ponto subjacente é que qualquer sistema de informação requer algum processo para ser desenvolvido corretamente. A engenharia de software abrange uma ampla gama de tarefas de sistemas de informação. A tarefa que nos interessa principalmente aqui é especificar e projetar um banco de dados. "Especificar um banco de dados" significa documentar o que o banco de dados deve conter e como realizar a tarefa geral de projeto em si.

Uma ideia básica em SE é construir software corretamente; uma série de etapas ou fases é necessária para progredir por um "ciclo de vida". Essas etapas garantem que um processo de pensamento preceda a ação — pensar sobre "o que é necessário" precede "qual software será escrito". Além disso, o "pensar antes da ação" exige que todas as partes envolvidas no desenvolvimento de software se entendam e se comuniquem. Uma versão comum da apresentação do cenário "pensar antes de agir" pode ser chamada de modelo "cascata"; o processo de desenvolvimento de software deve fluir de forma direcional, sem retrocesso. Como uma cascata, uma vez ultrapassado um ponto de decisão, é, na melhor das hipóteses, difícil voltar atrás e revisitá-lo.

Geralmente, a primeira etapa do processo de SE envolve a especificação formal do que deve ser feito. Podemos dividir essa primeira etapa em duas etapas: \(a\) elucidação dos requisitos e \(b\) aprovação de um documento de especificação. A ideia em cascata implica que, uma vez escrita e aceita pelo usuário, a especificação do software não é alterada ou revisada, mas sim usada como base para o projeto. Pode-se comparar o exercício geral de SE à construção de uma casa. A elucidação é onde você diz ao construtor o que deseja. O documento de especificação é uma declaração formal dos seus desejos.

Para ampliar nosso exemplo, suponha que você aborda um construtor. Você diz que quer uma casa de três quartos e dois banheiros. O construtor então faz perguntas — um ou dois andares, tijolo ou revestimento, onde você quer um interruptor de luz, fora do nível do solo ou laje, etc. O construtor então reúne todas as anotações sobre seus desejos, organiza as informações e apresenta as anotações para sua aprovação. O construtor fazendo perguntas é chamado de "esclarecimento". Uma vez que o construtor apresenta a você o que ele acredita serem seus desejos, a "lista de desejos final e negociada", você tem uma especificação. Deve haver um diálogo entre você e o construtor. Em algum momento, você e o construtor entendem o que você quer, e seus desejos são finalizados para que o construtor possa prosseguir com o processo de projeto da casa. O desenvolvimento de software e bancos de dados funciona da mesma forma que o exemplo da casa. Tornar o processo da casa formal garante que o construtor não perca tempo projetando algo que você não quer. O mesmo vale para o projeto de bancos de dados.

Uma vez acordada a especificação, o próximo passo é projetar a casa de acordo com a especificação. À medida que a casa é projetada e a planta \(design\) é elaborada, não é aceitável revisitar a especificação, exceto para pequenas alterações. Deve haver um "encontro de mentes" ao final da fase de especificação para prosseguir com o projeto \(planta\) da casa a ser construída. O mesmo ocorre com o desenvolvimento de software e banco de dados. A produção de software é um processo de ciclo de vida — o software \(um banco de dados\) é criado, usado, mantido e, eventualmente, descontinuado.

Os "atores" no ciclo de vida do desenvolvimento de software podem ser divididos em dois grupos, frequentemente chamados de usuário e analista. O software é projetado pelo analista para o usuário, de acordo com suas especificações. Em nossa apresentação, vamos nos considerar o analista tentando enunciar o que os usuários pensam que desejam. Lembre-se do exemplo deste capítulo sobre a lista de livros na biblioteca doméstica. Aqui, a pessoa que solicita a lista é o usuário; a pessoa que elabora a lista de livros é o analista \(também conhecido como o desenvolvedor, o construtor ou o designer do software\).

Não há consenso geral entre engenheiros de software quanto ao número exato de etapas ou fases em um modelo de desenvolvimento de software. Os modelos variam dependendo do interesse do pesquisador de SE em uma ou outra parte do processo. Segue uma breve descrição do processo de software: \(Software, a seguir, pode ser entendido como um banco de dados\)

+ Etapa 1 \(ou Fase 1\): Requisitos. Descubra o que o usuário deseja/precisa. O "procedimento de descoberta" costuma ser chamado de "esclarecimento". 
+ Etapa 2: Especificação. Descreva os desejos/necessidades do usuário com a maior precisão possível. Nesta etapa, o usuário e o analista documentam não apenas o que é desejado, mas também quanto custará e quanto tempo levará para entrar em uso. Um princípio básico do SE é gerar software dentro do prazo e do orçamento. Portanto, além de fazer com que ambos entendam o que é desejado/necessário, uma etapa essencial é definir um orçamento e um cronograma para a criação do produto. 
+ Etapa 2a: Envie a especificação ao usuário. Uma revisão formal do documento de especificação é realizada para verificar se \(a\) o usuário concorda que o analista enunciou corretamente o que ele deseja e \(b\) o analista está satisfeito com a clareza dos requisitos do usuário. Etapa 2b: Refaça a especificação conforme necessário e retorne à etapa 2a até que o analista e o usuário se entendam e concordem em prosseguir. Lembre-se do modelo em cascata — uma vez alcançado o fim da fase de especificação, não se retorna à fase anterior. 
+ Etapa 3: Design — O software ou um banco de dados é projetado para atender às especificações da etapa 2. Como na construção interna, agora o analista \(o construtor\) sabe o que é necessário, então o plano para o software é formalizado — um projeto é elaborado. 
+ Etapa 3a: O projeto do software é verificado independentemente em relação à especificação. A verificação independente do projeto indica que o analista atendeu claramente à especificação. Observe o senso de concordância na etapa 2 e o uso desta como base para ações futuras. Quando a etapa 3 começa, voltar atrás é, na melhor das hipóteses, difícil; é suposto ser assim. Talvez pequenos detalhes da especificação possam ser revisitados, mas a ideia é prosseguir após a conclusão de cada etapa. Uma vez concluída a etapa 3a, tanto o usuário quanto o analista sabem o que precisa ser feito. Na analogia da construção de uma casa, a planta baixa está agora desenhada.

Um último ponto aqui: na especificação, um orçamento e um cronograma são propostos pelo analista e aceitos pelo usuário. Na fase de design, essa parte orçamentária do design geral às vezes é refinada. Todo desenvolvimento de software demanda tempo e dinheiro. Não só é vital produzir corretamente um determinado produto, como também é necessário deixar claro para todas as partes envolvidas o investimento de tempo e dinheiro.

+ Etapa 4: Desenvolvimento. O software é escrito; um banco de dados é criado. 
+ Etapa 4a: Na fase de desenvolvimento, o software, conforme escrito, é verificado em relação ao projeto até que o analista o tenha atendido claramente. Observe que a especificação da etapa 2 já passou há muito tempo, e apenas pequenas modificações no projeto seriam toleradas aqui ou na Etapa 3. O objetivo da etapa 4 é construir o software de acordo com o projeto \(o blueprint\) da etapa 3. No nosso caso, o banco de dados é criado e preenchido nesta fase. 
+ Etapa 5: Implementação. O software é entregue ao usuário para ser utilizado na aplicação. 
+ Etapa 5a: O usuário testa o software e o aceita ou rejeita. A questão é: "O banco de dados foi criado corretamente? Atendeu às especificações e ao design?". No nosso caso, o banco de dados é consultado, os dados são adicionados ou excluídos e o usuário aceita o que foi criado. Uma pessoa pode pensar que este é o fim do ciclo de vida do software, mas há duas etapas mais importantes.
+  
Etapa 6: Manutenção. A manutenção é realizada no software até que ele seja descontinuado. Não importa quão bem especificado, projetado e escrito seja, algumas partes do software podem falhar. Em bancos de dados, alguns itens de dados podem precisar ser adicionados ou excluídos. Talvez algumas tabelas auxiliares precisem ser criadas. Algumas partes do banco de dados podem precisar ser modificadas ao longo do tempo para se adequar ao usuário ou para melhorar o desempenho. Os tempos mudam; as demandas e as necessidades mudam. A manutenção é uma parte muito demorada e cara do processo de software — especialmente se o processo de SE não tiver sido bem executado. A manutenção envolve a correção de falhas ocultas do software, bem como o aprimoramento da funcionalidade do software.

+  
Em bancos de dados, novos itens de dados são frequentemente necessários; alguns dados antigos podem não ser mais necessários. Mudanças de hardware. Sistemas operacionais mudam. O próprio mecanismo do banco de dados, que é o software, é frequentemente atualizado — novas versões são impostas ao mercado. Os dados no banco de dados devem estar em conformidade com as mudanças, e um procedimento para alterá-los deve estar em vigor.

+ Etapa 7: Aposentadoria. Eventualmente, qualquer software escrito se torna obsoleto. Pense em videogames antigos que já foram de última geração e se tornaram obsoletos e ultrapassados. Mecanismos de banco de dados, computadores e a tecnologia em geral estão evoluindo. O pacote de software antigo que você usava em algum computador pessoal antigo não funciona mais porque o sistema operacional foi atualizado, o computador está obsoleto e o software antigo precisa ser aposentado. Basicamente, o processo de SE deve ser reiniciado com novas especificações. O mesmo vale para bancos de dados e sistemas projetados. Às vezes, a coisa mais econômica a se fazer é começar do zero.

Ponto de verificação 1.3

1. Em que fase o banco de dados é criado? 
2. Qual pessoa testa o banco de dados? 
3. Em que fase o usuário diz o que deseja no banco de dados? 
4. Quando você está registrando fatos sobre um banco de dados, qual é essa fase?



## 1.5 DIAGRAMAS DE ENTIDADE-RELACIONAMENTO E O CICLO DE VIDA DA ENGENHARIA DE SOFTWARE

Este texto concentra-se nas etapas 1 a 3 do ciclo de vida do software para bancos de dados. Um banco de dados é uma coleção de dados relacionados. O conceito de dados relacionados significa que um banco de dados armazena informações sobre uma empresa: um negócio, uma organização, um agrupamento de pessoas ou processos relacionados. Por exemplo, um banco de dados pode conter dados sobre a Acme Plumbing e envolver clientes e chamadas de serviço. Um banco de dados diferente pode ser sobre os membros e atividades de um grupo religioso na cidade. Seria inadequado ter dados sobre o grupo religioso e a Acme Plumbing no mesmo banco de dados porque as duas organizações não estão relacionadas. Novamente, um banco de dados é uma coleção de dados relacionados. Manter um banco de dados sobre cada uma das entidades acima é aceitável, mas não no mesmo banco de dados.

Sistemas de banco de dados são frequentemente modelados usando um diagrama entidade-relacionamento \(ER\) como o projeto a partir do qual o banco de dados real é criado; o projeto finalizado é a saída da fase de projeto. O diagrama ER é uma ferramenta do analista para diagramar os dados a serem armazenados em um sistema de banco de dados. A Fase 1, a fase de requisitos, pode ser bastante frustrante, pois o analista precisa obter necessidades e desejos do usuário. O usuário pode ou não ser "entendido em informática" e pode ou não conhecer os recursos de um sistema de software. O analista frequentemente tem dificuldade em decifrar as necessidades do usuário e deseja criar uma especificação que \(a\) faça sentido para ambas as partes \(usuário e analista\) e \(b\) permita que o analista projete com eficiência.

No mundo real, o usuário e o analista podem ser comitês de profissionais, mas os usuários \(ou grupos de usuários\) devem transmitir suas ideias a um analista \(ou equipe de analistas\). Os usuários devem expressar o que desejam e o que acreditam precisar; os analistas devem identificar esses desejos e necessidades, documentá-los e criar um plano para atender aos requisitos do usuário.

Descrições de usuários podem parecer vagas e desestruturadas. Normalmente, os usuários são bem-sucedidos em um negócio. Eles conhecem o negócio; entendem o modelo de negócios. A pessoa que trabalha com computadores normalmente desconhece o negócio, mas entende a parte computacional do problema. Para a pessoa com foco em computadores, a descrição do negócio feita pelo usuário é tão nova para o analista quanto o jargão da computação é para o usuário. Apresentamos uma metodologia projetada para tornar a linguagem do analista precisa, de modo que o usuário se sinta confortável com o banco de dados a ser projetado, mas ainda fornece ao analista uma ferramenta para facilitar o mapeamento direto para o banco de dados.

Em resumo, a seguir revisaremos as etapas iniciais do ciclo de vida do SE, conforme se aplica ao design de banco de dados.



### 1.5.1 Fase 1: Obter os requisitos para o banco de dados

Na fase 1, ouvimos e fazemos perguntas sobre quais fatos \(dados\) o usuário deseja organizar em um sistema de recuperação de banco de dados. Essa etapa geralmente envolve permitir que os usuários descrevam como pretendem usar os dados. Você, o analista, eventualmente fornecerá um processo para carregar e recuperar dados de um banco de dados. Muitas vezes, há uma "curva de aprendizado" necessária para o analista à medida que o usuário explica o sistema.



### 1.5.2 Fase 2: Especificar o Banco de Dados

A Fase 2 envolve descrições gramaticais e diagramas do que o analista acredita que o usuário deseja. O projeto de banco de dados geralmente é realizado com um diagrama ER funcionando como o modelo para o banco de dados a ser projetado. Como a maioria dos usuários não está familiarizada com a noção de diagrama ER, nossa metodologia complementará o diagrama ER com descrições gramaticais do que o banco de dados deve conter e como suas partes se relacionam. A descrição técnica de um banco de dados pode ser árida e desinteressante para o usuário; no entanto, quando os analistas traduzem o que acham que ouviram em declarações em inglês, os usuários e os analistas têm um melhor entendimento. Por exemplo, se o analista fizer declarações como "todos os funcionários devem gerar faturas", o usuário pode então afirmar, negar ou modificar a declaração para se adequar ao caso real. Como veremos, faz uma grande diferença no banco de dados se "todos os funcionários devem gerar faturas" versus "alguns funcionários podem gerar faturas".



### 1.5.3 Fase 3: Projetar o Banco de Dados

Depois que o banco de dados for diagramado e acordado, o diagrama ER se torna o projeto finalizado para a construção do banco de dados na fase 3. Passar do diagrama ER para o banco de dados real é semelhante a pedir a um construtor de uma casa que pegue um projeto e comece a construção.

Como vimos, pode haver mais etapas no processo de SE, mas este livro é sobre design de banco de dados e, portanto, as etapas restantes de qualquer modelo de SE não são enfatizadas.

Ponto de verificação 1.4

1. Descreva brevemente as principais etapas do ciclo de vida do SE conforme ele se aplica aos bancos de dados. 
2. Quem são os dois principais participantes do ciclo de vida de desenvolvimento de software? 
3. Por que a comunicação escrita entre as partes no processo de design é importante? 
4. Como é chamado o projeto a partir do qual o banco de dados real é criado? 
5. Quais são as três fases importantes do projeto de um banco de dados?





## 1.6 RESUMO DO CAPÍTULO

Este capítulo serve como um capítulo de contexto. O capítulo descreve brevemente dados, bancos de dados e o processo de ES. O processo de ES é apresentado conforme se aplica aos diagramas ER — o projeto de design de banco de dados.





## CAPÍTULO 1 EXERCÍCIOS

David administra uma loja de golfe com equipamentos de golfe e muitos clientes; seu negócio principal é vender produtos de varejo para clientes. David quer controlar tudo em um computador. Ele aborda Kaitlin, que entende de computadores, e pergunta a ela o que fazer.

1. No nosso contexto, David é um; Kaitlin é um. 
2. Quando David explica a Kaitlin o que ele quer, Kaitlin começa a escrever o quê? 
3. Quando David diz: “Kaitlin, essa especificação está toda errada”, o que acontece em seguida? 
4. Se David disser: “Kaitlin, esta especificação é aceitável”, o que acontece a seguir? 
5. Se, durante o projeto, Kaitlin perceber que David esqueceu de contar a ela sobre algo que ele quer, o que Kaitlin deve fazer? 
6. Como Kaitlin obtém as especificações de David em primeiro lugar? 
7. A etapa 3a acima sugere: “O design do software é verificado independentemente em relação à especificação”. O que isso significa? Como isso pode ser feito?

Uma boa ideia aqui seria que David e Kaitlin tivessem alguém para revisar o design do banco de dados. No capítulo, sugerimos uma avaliação independente do banco de dados. Talvez Kaitlin e David tenham colegas de trabalho que poderiam e deveriam revisar o design do banco de dados antes de prosseguir.



## BIBLIOGRAFIA

+ Schach, S.R. \(2011\). Engenharia de Software Clássica e Orientada a Objetos. Nova Iorque: McGraw-Hill.





# 2 Dados e Modelos de Dados



DOI: 10.1201/9781003314455-2



## 2.1 INTRODUÇÃO

Neste capítulo, examinamos a evolução dos bancos de dados e mostramos como surgiu o modelo de banco de dados relacional para projetar e utilizar bancos de dados. Historicamente, houve muitas abordagens para armazenar e recuperar dados, e alguns sistemas mais antigos ainda podem ser utilizados. No entanto, a maioria dos bancos de dados em uso hoje se baseia no modelo relacional. Nosso objetivo neste livro é projetar um bom banco de dados relacional. Apresentamos o banco de dados relacional conforme ele evoluiu a partir de abordagens históricas para armazenamento e recuperação de dados.

No próximo capítulo, apresentaremos o conceito de dependências funcionais para definir o que é um bom \(e um não tão bom\) banco de dados relacional. Embora o objetivo deste capítulo seja familiarizá-lo com um banco de dados relacional, exploraremos a evolução dos bancos de dados, pois isso gera uma apreciação pela simplicidade e pelo poder do modelo relacional.



## 2.2 ARQUIVOS, REGISTROS E ITENS DE DADOS

Os dados devem ser armazenados de forma ordenada em algum tipo de arquivo para serem úteis. Suponha que não existissem computadores — pense em uma época em que todos os arquivos eram documentos em papel para uma empresa acompanhar seus clientes e produtos. Um consultório médico monitorava os pacientes. Um time esportivo mantinha estatísticas sobre seus jogadores. Nesses casos, os dados eram registrados em papel e provavelmente mantidos em um arquivo. Os arquivos com dados poderiam ser chamados de "banco de dados". Um banco de dados é simplesmente um repositório de dados sobre alguma entidade específica. Um arquivo de cliente pode ser tão simples e minimalista quanto uma lista de pessoas que fizeram negócios com um comerciante. Há dois aspectos no arquivamento: armazenamento e recuperação. Algum método de armazenamento de dados para facilitar a recuperação é o mais desejável.

Em um arquivo de registros de clientes, o arquivo inteiro pode ser chamado de arquivo de cliente, enquanto as informações individuais do cliente são mantidas em um registro de cliente. Arquivos consistem em registros. Muito provavelmente, mais informações do que uma lista contendo apenas os nomes dos clientes seriam registradas. No mínimo, o nome, endereço e número de telefone de um cliente poderiam constituir um registro de cliente. Cada um desses componentes do registro é chamado de item ou campo de dados. O arquivo de cliente contém registros de clientes que consistem em campos de dados.

A Tabela 2.1 apresenta um exemplo de alguns dados \(você pode imaginar cada linha como um cartão 3 × 5, com os três cartões \[três registros\] formando um arquivo\).
TABELA 2.1 Dados de amostra para o arquivo CLIENTE.  `Record 1`  `McDonald, A`  `123 4th St`  `Mobile, AL`    `Record 2`  `Claud, S`  `452 Main St`  `Pensacola, FL`    `Record 3`  `Jarzin, D`  `92 Adams Lane`  `Elberta, AL`     
Este arquivo contém três registros, um para cada cliente. Cada registro consiste em quatro campos: número do registro, nome, endereço e cidade. À medida que mais clientes forem adicionados, seus dados serão registrados em um novo cartão 3 × 5 \(um novo registro\) e colocados no arquivo do cliente. Várias perguntas e observações interessantes surgem para o comerciante que mantém essas informações:

1. O comerciante pode querer adicionar informações, como um número de telefone, no futuro. Você adicionaria um número de telefone a todos os cartões 3 × 5 ou a adição seria feita "conforme necessário"? Se fosse feito "conforme necessário", alguns clientes teriam números de telefone e outros não. Se um cliente não tivesse número de telefone no registro, o número de telefone desse cliente seria "nulo". \(Usamos o termo "nulo" para significar "desconhecido".\) 
2. Como o arquivo será organizado? Imagine não três clientes, mas 300 ou 3.000. Os cartões 3 × 5 seriam colocados em ordem alfabética? Talvez, mas o que acontece se você receber outro A. McDonald ou S. Claude? Ou, e se você quiser encontrar endereços com mais frequência do que nomes? O campo no qual o arquivo é organizado é chamado de chave. Talvez o arquivo deva ser organizado por número de telefone ou endereço, em vez de nome. A chave é um identificador para encontrar dados. As chaves devem ser únicas, mas e se houver um valor duplicado para uma chave? 
3. Suponha que o arquivo fosse organizado por número de telefone. E se o número de telefone de um cliente não tivesse sido registrado porque você não sabia o número ou porque o cliente não tinha um telefone? Se não houvesse número de telefone, a terminologia comum é dizer que o campo de telefone para esse registro é nulo. Não faria sentido ter o arquivo organizado por número de telefone se alguns valores fossem nulos. Claramente, a chave de um arquivo não pode ser nula. Além disso, observe que se o número de telefone fosse a chave para o arquivo do cliente, a pessoa que buscasse um registro de cliente no arquivo teria que saber o número de telefone para encontrar o registro apropriado com eficiência. 
4. O formato do arquivo acima é:
> ` CUSTOMER(record_number, name, address, city) ` 
O formato do arquivo determina a ordem dos campos em qualquer registro. Neste registro, o número do registro vem primeiro, seguido por um nome e assim por diante. O design do arquivo pode ter os campos em alguma outra ordem, mas uma vez definida, a ordem dos campos permanece constante.

Se um campo de número de telefone fosse adicionado, o formato do arquivo poderia ser:
> ` CUSTOMER(record_number, name, address, city, telephone) ` 
Esta notação de formato abreviada ilustrada é chamada de design de arquivo. Se o arquivo fosse configurado para buscar dados por nome e o nome fosse a chave, o nome seria sublinhado, da seguinte forma:
> ` CUSTOMER(record_number, name, address, city, telephone) ` 
+ 5 Você pode perguntar: "Por que não usar o número do registro para organizar o arquivo?". Por um lado, ele é único \(o que é desejável para uma chave\), mas, por outro lado, você teria que saber o número do registro para encontrar um cliente. O exemplo está organizado por número de registro; no entanto, imagine 300 ou mais clientes. Você quer encontrar o endereço de Claude — você teria que saber o número do registro. Faz mais sentido organizar este arquivo de cartões 3 × 5 por nome. Levando alguns desses pontos em consideração, a Tabela 2.2 apresenta uma versão aprimorada do arquivo de clientes, na qual cada linha representa um cartão 3 × 5. TABELA 2.2 Dados de exemplo para o arquivo CLIENTE aprimorado. `Record 1``Adams, A``77 A St``Pensacola, FL``555–5847``Record 2``Charles, X``365 Broad St``Mobile, AL``555–8214``Record 3``Jarzin, H``92 Adams Lane``Elberta, AL``555–1234``Record 4``McDonald, A``22 Pine Forest``Pensacola, FL``null``Record 5``McDonald, J``123 4th St``Mobile, AL``555–9978``Record 6`\{\{i d\_00026\}\}`932 Dracena Way``Gulf Breeze, FL``555–1111``Record 7``Claud, S``452 Main St``Pensacola, FL``555–0003`

Ponto de verificação 2.1

1. O que significa dizer que um campo tem valores únicos? 
2. Por que é desejável que uma chave seja única? 
3. Por que um arquivo precisa ser organizado por um campo-chave? 
4. O que significa nulo? 
5. Considere este arquivo de cliente: `Record 1``77 A St``Adams, A``Pensacola, FL``555–5847``Record 2``Charles, X``365 Broad St``555–8214``Mobile, AL``Record 3``555–1234``Jarzin, H``92 Adams Lane``Elberta, AL`O que está errado aqui?



## 2.3 MUDANDO DE CARTÕES 3 × 5 PARA COMPUTADORES

Voltemos ao nosso exemplo de um comerciante que mantinha um arquivo de clientes em cartões 3 × 5. Com o passar do tempo, a base de clientes cresceu e o comerciante passou a desejar manter mais informações sobre os clientes. Do ponto de vista do processamento de dados, diríamos que as técnicas aprimoradas de armazenamento e recuperação levaram a cartões mais bem organizados, mais campos e, talvez, melhores maneiras de armazenar e encontrar registros individuais.

Surgem algumas perguntas: os registros dos clientes eram mantidos em ordem alfabética de nome e nome? Os registros eram armazenados por número de telefone ou número de registro \(que também poderia ser o número do cliente\)? O que acontece se um campo que não constava nos formulários ou cartões existentes fosse obrigatório? Se dados forem adicionados ou alterados, o quanto os formatos dos registros serão alterados? Esses eram os dilemas do processamento de dados do passado.

Quando os computadores começaram a ser usados para empresas, os dados eram armazenados em mídia magnética. A mídia magnética era principalmente discos e fitas. A maneira como os dados eram armazenados e recuperados em um computador começou como os cartões 3 × 5, mas os dados magnéticos eram virtuais. Eles não existiam fisicamente onde você pudesse tocá-los ou vê-los sem algum tipo de software para carregar e encontrar registros. Além disso, um dispositivo de exibição para ver o que o "cartão 3 × 5" tinha era necessário. Antes de 1975, a maneira mais comum de os dados serem inseridos em um computador era por meio de cartões perfurados. Os sistemas de cartões perfurados para manipulação de dados estavam em uso já na década de 1930; os classificadores eram capazes de digitalizar e organizar uma pilha de cartões. O uso de cartões perfurados para inserir dados em computadores era comum na década de 1960 porque era uma tecnologia conhecida. A saída ou "dispositivo de exibição" era normalmente uma impressora de linha.

À medida que os dados eram colocados em um computador, softwares eram desenvolvidos para lidar com os dados e técnicas de arquivamento evoluíam. Nos primórdios dos bancos de dados, os arquivos mantidos em computadores basicamente replicavam os cartões 3 × 5. Havia muitos problemas com computadores e bancos de dados nos "primeiros dias". \(Geralmente, os primeiros dias em termos de computadores e bancos de dados significam aproximadamente do início a meados da década de 1960.\) Alguns problemas envolviam entrada \(como os dados entravam no computador\), saída \(como os dados deveriam ser exibidos\) e manutenção de arquivos \(como os dados deveriam ser armazenados e mantidos atualizados, como os registros deveriam ser adicionados e excluídos e como os campos deveriam ser adicionados, excluídos ou alterados\). Uma pessoa que usasse um computador para rastrear dados podia comprar um computador e contratar programadores, operadores de computador e pessoal de entrada de dados.

No início, os computadores eram caros e grandes. A maioria das pequenas empresas não tinha recursos para adquirir um computador, muito menos para contratar pessoas cujo trabalho fosse exclusivamente "no computador". Devido ao custo dos computadores e às demandas de armazenamento físico, as primeiras tentativas de arquivamento e recuperação de dados eram responsabilidade de grandes empresas e grandes organizações.

Se uma empresa comprasse um computador e toda a infraestrutura necessária, os departamentos dentro da empresa desejariam manter arquivos de vários tipos no computador. Suponha que a empresa fabricasse um produto e tivesse vários departamentos \(por exemplo, vendas, contabilidade e produção\). Cada departamento queria manter dados sobre os clientes. Cada departamento tinha uma visão diferente dos clientes. O departamento de vendas queria saber o nome, endereço, número de telefone e alguns dados relacionados à propensão à compra do produto. O departamento de contabilidade queria saber aproximadamente as mesmas informações, mas queria acompanhar o faturamento e os pagamentos. A produção também queria algumas das mesmas informações, mas queria saber o que o cliente precisava no produto e quantos produtos eles deveriam fabricar. Cada departamento queria coisas aproximadamente semelhantes, mas cada um abordava o problema de uma maneira diferente.

O que realmente acontecia nos primeiros dias era que cada departamento compartilhava o caro computador, mas contratava sua própria equipe de programação para manter "seu banco de dados". Embora a ideia de compartilhar o caro computador estivesse presente, a ideia de compartilhar dados não estava. A ideia de um "pacote de software" para armazenar e recuperar dados também não existia. Os programadores usavam linguagens de computador como COBOL, RPG, ALGOL, PL/1 e FORTRAN para armazenar e recuperar dados. Cada departamento criava seus próprios registros e seus próprios métodos de armazenamento e recuperação, mantinha seus próprios programas e tinha seus próprios grupos de entrada de dados.

Os primeiros bancos de dados eram sistemas de arquivamento mantidos por programadores usando uma linguagem de computador \(tipicamente COBOL\). Por exemplo, um programador escrevia um programa em COBOL para coletar dados de entrada em cartões perfurados e armazená-los em um arquivo de computador. Em seguida, o programador escrevia outro conjunto de programas para recuperar os dados e exibi-los da maneira que o usuário quisesse. Os primeiros sistemas de arquivamento de computador eram arquivos sequenciais simples. Os dados em cartões perfurados eram lidos e armazenados. Na Tabela 2.3, reconsideramos o arquivo de clientes que apresentamos anteriormente.
TABELA 2.3 Dados de amostra para o arquivo CLIENTE.  `Record 1`  `Adams, A`  `77 A St`  `Pensacola, FL`  `555–5847`    `Record 2`  `Charles, X`  `365 Broad St`  `Mobile, AL`  `555–8214`    `Record 3`  `Jarzin, H`  `92 Adams Lane`  `Elberta, AL`  `555–1234`    `Record 4`  `McDonald, A`  `22 Pine Forest`  `Pensacola, FL`  `null`    `Record 5`  `McDonald, J`  `123 4th St`  `Mobile, AL`  `555–9978`    `Record 6`  `Richard, E`  `932 Dracena Way`  `Gulf Breeze, FL`  `555–1111`    `Record 7`  `Claud, S`  `452 Main St`  `Pensacola, FL`  `555–0003`     
Se você pudesse olhar os dados em um disco, ele se pareceria com a Tabela 2.4.
TABELA 2.4 Aparência dos dados de amostra no disco.  `Adams, A`  `77 A St`  `Pensacola, FL`  `555–5847`    `Charles, X`  `3 65 Broad St`  `Mobile, AL`  `555–8214`    `Jarzin, H`  `92 Adams Lane`  `Elberta, AL`  `555–1234`    `McDonald, A`  `22 Pine Forest`  `Pensacola, FL`  `null`    `McDonald, J`  `123 4th St`  `Mobile, AL`  `555–9978`    `Richard, E`  `932 Dracena Way`  `Gulf Breeze, FL`  `555–1111`    `Claud, S`  `452 Main St`  `Pensacola, FL`  `555–0003`     


Os registros endereçados pelo COBOL tinham uma estrutura como esta:
01 CLIENTE   05 NOME PERSONAGEM\(20\)  05 ENDEREÇO PERSONAGEM\(20\)  05 CIDADE-ESTADO PERSONAGEM\(25\)  05 TELEFONE PERSONAGEM\(7\)   
O arquivo representado acima era chamado de "arquivo sequencial". Se alguém quisesse ver uma lista de dados por endereço em vez de nome, o arquivo precisava ser ordenado e os dados reexibidos. Se dados fossem adicionados ao arquivo, eles precisavam ser colocados em seu devido lugar de acordo com a chave sequencial, que neste exemplo é o campo de nome. As primeiras ideias giravam em torno de cartões perfurados e muita ordenação — primeiro, a ordenação de cartões perfurados e, em seguida, técnicas para ordenar dados em discos ou fitas.

Para corrigir as desvantagens da classificação e de mais classificação para recuperar dados, dois outros sistemas principais de arquivamento evoluíram na década de 1960: os sistemas de arquivamento indexados e de acesso direto. As fitas eram dispositivos sequenciais capazes de armazenar uma grande quantidade de dados. Os discos, por outro lado, podiam armazenar dados como as fitas, mas com menor capacidade. Os discos forneciam capacidade de acesso aleatório, enquanto as fitas não. Assim, os sistemas de software evoluíram para aproveitar o armazenamento em disco com acesso não sequencial aos dados. No final da década de 1960, pacotes de software chamados "sistemas de banco de dados" começaram a surgir. Os sistemas de banco de dados eram programas compráveis para armazenar e recuperar dados, bem como realizar manutenção \(adicionar, excluir e modificar campos e registros\). Com um sistema de banco de dados, não era necessário escrever programas em COBOL para manipular os dados diretamente, mas sim confiar no programa do banco de dados para manipular os dados. Os programadores usavam uma combinação de COBOL e algumas linguagens de banco de dados proprietárias para manter os dados. Com esses sistemas, cada departamento podia compartilhar dados e recursos. À medida que os bancos de dados evoluíram, em vez de cada departamento ter seus próprios programadores e talvez seu próprio computador, passou a haver um computador central para armazenar dados, uma equipe de programação e um pacote de software de banco de dados. Os dados poderiam e deveriam ser compartilhados, com cada departamento tendo sua própria visão dos dados.

Tudo isso parece ótimo, mas, na realidade, levou vários anos para romper com o modelo "meus dados". Além disso, surgiram sistemas híbridos com foco principal na recuperação de dados. Isso atrasou a transição para um ambiente totalmente relacional devido aos investimentos que as empresas tinham em software e programadores.

Por que compartilhar dados era algo positivo? Compartilhar não apenas utilizava recursos caros de forma mais eficiente, como também reduzia a redundância. Redundância significa armazenar as mesmas informações em locais diferentes. Se cada departamento armazenasse sua própria versão dos dados, sua própria visão dos clientes, o nome, endereço, número de telefone do cliente e assim por diante seriam registrados por cada departamento. Suponha que o cliente se mudasse. Então, cada departamento alterava seus dados ao descobrir que o cliente havia se mudado, e mudanças repetidas de um cliente poderiam facilmente levar ao armazenamento inconsistente do endereço de um cliente — o departamento de contabilidade poderia ter um endereço, o departamento de vendas poderia ter outro, etc. O problema fundamental aqui é a falta de compartilhamento de dados, e o compartilhamento era um objetivo central dos primeiros sistemas de banco de dados.

Os primeiros softwares de banco de dados evoluíram para dois modelos de dados principais: o modelo hierárquico e o modelo de rede. Embora o modelo relacional para um banco de dados tenha sido reconhecido como uma técnica desejável no início da década de 1970, o modelo relacional era tratado como uma técnica teórica muito boa, mas os computadores não eram rápidos o suficiente para implementá-la naquela época.

Os modelos de banco de dados \(hierárquico, de rede e relacional\) eram modelos lógicos — maneiras de perceber logicamente o arranjo de dados em uma estrutura de arquivo. Percebia-se como os dados deveriam ser armazenados logicamente, e o banco de dados implementava fisicamente o modelo lógico. Como veremos, há uma estreita relação entre as implementações lógicas e físicas dos modelos hierárquico e de rede. Como não havia implementações relacionais práticas além dos então supercomputadores em centros de pesquisa, o mundo dos bancos de dados comerciais na década de 1970 envolvia a escolha entre os modelos hierárquico e de rede. As próximas seções oferecem uma breve visão geral de cada um desses três modelos principais e uma introdução ao modelo relacional.

Ponto de verificação 2.2

1. O que é um arquivo sequencial? 
2. O que é COBOL? 
3. Por que a ordem é importante em um sistema de arquivamento sequencial? 
4. O que é um programa de banco de dados? 
5. Antigamente, como os dados eram colocados em um arquivo?



## 2.4 MODELOS DE BANCO DE DADOS

Agora, vamos dar uma olhada nos modelos de banco de dados como eles eram antes do banco de dados relacional se tornar prático. Essa retrospectiva mostra por que os "sistemas antigos" são considerados obsoletos e por que o modelo relacional é o padrão de fato em bancos de dados hoje. Os sistemas antigos eram classificados em dois modelos principais de banco de dados: hierárquico e em rede. Esses dois modelos eram a espinha dorsal do software de banco de dados antes da década de 1980. Embora esses sistemas legados possam ser considerados "antiquados", existem alguns sistemas ainda em uso hoje que dependem desses modelos.

Nesta seção, apresentamos algumas versões do modelo hierárquico por vários motivos:

1. Para ilustrar como modelos mais antigos foram construídos a partir de sistemas de arquivos 
2. Para mostrar por que esses bancos de dados baseados em arquivos se tornaram obsoletos quando os bancos de dados relacionais se tornaram práticos 
3. Para ver a evolução dos sistemas baseados em arquivos

Os sistemas de arquivos discutidos abaixo representam formas reais como alguns sistemas de banco de dados eram escritos antes do surgimento dos bancos de dados relacionais. O objetivo aqui é ilustrar os pontos positivos e negativos dos sistemas de banco de dados mais antigos e mostrar por que os bancos de dados relacionais representaram e representam uma melhoria tão grande no design e no uso de bancos de dados.



### 2.4.1 O Modelo Hierárquico

Em modelos de banco de dados hierárquicos, todos os dados são organizados de cima para baixo, na qual alguns registros têm um ou mais registros "dependentes" ou "filhos", e cada registro filho está vinculado a um e apenas um "pai". O relacionamento pai-filho não pretende inferir um relacionamento familiar humano. Os termos pai e filho são históricos e visam evocar uma imagem de um tipo de dado como dependente de outro. Outra terminologia para o relacionamento pai-filho é proprietário e objetos possuídos, mas a terminologia pai-filho é mais comum. Como ilustrado aqui, os registros "filhos" serão esportes praticados por uma pessoa "pai".

Começamos com um exemplo de situação de arquivo hierárquico. Suponha que você tenha um banco de dados de pessoas que praticam um esporte em algum local. Suponha que temos uma pessoa, Brenda, que joga tênis em quadras municipais e que joga golfe nos campos municipais. A pessoa, Brenda, estaria no topo da hierarquia, e o local do esporte estaria no segundo nível. Normalmente, a conexão entre as camadas na hierarquia é uma relação pai-filho. Cada pai-pessoa pode estar relacionado a muitos locais de esportes filhos, mas cada local de esporte \(cada registro filho\) está vinculado à única pessoa \(um registro pai\) que pratica aquele esporte específico. Uma maneira de armazenar esse banco de dados hierárquico poderia ser ter dois arquivos, um arquivo para a pessoa, um arquivo para os locais de esportes. Para que o modelo de dois arquivos faça sentido \(ou seja, para ter os arquivos "relacionados" e, portanto, ser um banco de dados\), teria que haver ponteiros ou referências de algum tipo de um arquivo para o outro. Uma maneira de implementar um esquema de ponteiros seria ter um ponteiro do esporte \(criança\) para a pessoa \(pai\) como este:
> PESSOA\(número\_registro, nome\) Com dados: `Brenda` `Richard` `Abbie` > ESPORTES\(esporte, local, referência ao número de registro da pessoa\) Com dados: `tennis, city courts, 1` `golf, municipal links, 1` `golf, municipal links, 2` `snorkeling, Pensacola Bay, 2` `running, UWF track, 2` `downhill skiing, Ski Beech, 3` 
Um diagrama dessa relação é mostrado na Figura 2.1.
FIGURA 2.1 Uma hierarquia de pessoas e esportes com indicadores dos pais. 
A localização real dos registros em um disco não precisa ser conhecida. O sentido dos dados não se perde se os locais forem endereços de disco e se você imaginar que há milhares de pessoas e esportes. Aqui, suponha que assumamos que o "endereço do registro" é uma sequência alfanumérica de quatro letras:
> PESSOA\(endereço\_registro, nome\) Com dados: `A45C, Brenda` `C333, Abbie` `B259, Richard` > ESPORTES\(esporte, local, referência à pessoa\) Com dados: `golf, municipal links, B259` `running, UWF track, B259` `downhill skiing, Ski Beech, C333` `snorkeling, Pensacola Bay, B259` `tennis, city courts, A45C` `golf, municipal links, A45C` 
Este sistema possui um vínculo pai-filho — o ponteiro do filho para o pai cria um relacionamento. A "referência à pessoa" no arquivo SPORTS refere-se à chave primária do arquivo PERSON e é chamada de chave estrangeira \(FK\) porque a "referência à pessoa" é uma chave primária de outro arquivo. A FK referencia uma chave primária, completando assim o relacionamento de um arquivo com o outro. Se não houvesse relacionamento, você teria dois arquivos independentes, sem conexão — o sistema não faria sentido.

Embora tenhamos estabelecido a relação entre filho e pai na discussão, o banco de dados apresenta algumas desvantagens. A questão aqui é que, em qualquer banco de dados, os dados devem ser armazenados de forma que possam ser consultados. Isso significa que o projetista do banco de dados precisa perguntar ao usuário quais perguntas ele provavelmente fará? Pode apostar que sim.

Para responder a uma pergunta neste banco de dados, "Quem joga golfe em campos municipais?", você começa olhando o arquivo SPORTS, procura por "golfe em campos municipais" e vê quais registros pais existem. Esta pergunta e resposta são fáceis o suficiente porque você começa com o objeto da busca — um esporte. Agora, se sua pergunta fosse "Quais esportes Richard pratica?", você teria que primeiro encontrar Richard no arquivo PERSON para obter o endereço do registro dele e, em seguida, procurar no arquivo SPORTS para encontrar os links de volta para Richard. Como o arquivo SPORTS não está organizado de forma a facilitar a busca por uma resposta para sua pergunta, você deve olhar todas as instâncias de todos os esportes para ver quais, se houver, apontaram para Richard.

Se você estivesse realmente implementando este modelo de banco de dados, poderia aprimorar um pouco o sistema para responder a perguntas que começam com o registro pai. Uma melhoria neste modelo poderia ser referenciar cada esporte dentro de cada registro pai \(vamos voltar aos números simples para isso\):
> PESSOA\(endereço de registro, nome, \{endereços esportivos\}\) Com dados: `Brenda, (101, 102)` `Richard, (103, 104, 105)` `Abbie, (106)` > ESPORTES\(esporte, local, referência à pessoa\) Com dados: `101, tennis, city courts, 1` `102, golf, municipal links, 1` `103, golf, municipal links, 2` `104, snorkeling, Pensacola Bay, 2` `105, running, UWF track, 2` `106, downhill skiing, Ski Beech, 3` 
A Figura 2.2 ilustra a relação entre os registros pai e filho em ambas as direções. Quando vistos a partir do pai, esses links de ponteiros-filhos são chamados de sistema de ponteiros múltiplos-filhos \(MCP\). Richard tem três ponteiros para registros filhos porque, neste banco de dados, ele pratica três esportes.
FIGURA 2.2 Uma hierarquia de pessoas e esportes com indicadores de pais e filhos. 
Quando visualizado a partir do arquivo filho, o link para trás é chamado de ponteiro pai. No arquivo SPORTS, se um registro for examinado como:
> ` 106, downhill skiing, Ski Beech, 3 ` 
a referência de ponteiro para a pessoa \(3\) seria chamada de ponteiro pai. O 3 aponta para o pai, Abbie.

Neste modelo, o relacionamento entre os registros pai e filho é feito de duas maneiras. A "referência à pessoa" no arquivo SPORTS é um link \(o FK\) do filho para o pai. A referência a vários filhos nos registros pai é chamada de esquema MCP \(ponteiro para múltiplos filhos\). Embora seja verdade que o MCP é redundante para o relacionamento, ele faz duas coisas práticas:

1. Ele permite que perguntas sejam feitas ao sistema que são mais fáceis de responder do que apenas com ponteiros dos pais. 
2. Ele permite que o sistema seja consultado sem olhar os registros filhos.

Por exemplo, se você fizer a pergunta — quantos esportes Richard pratica? — você só precisa olhar o arquivo da pessoa e contar as referências do MCP.

Ilustramos duas maneiras de construir um relacionamento entre dois arquivos: o ponteiro pai FK e o MCP. Ambas as técnicas de vinculação são implementações viáveis em bancos de dados. A segunda, o sistema MCP, foi implementada com mais frequência do que o sistema FK.

O que aprendemos até agora sobre bancos de dados hierárquicos?

1. Os ponteiros no banco de dados determinam a facilidade com que o banco de dados é consultado. 
2. Embora as indicações entre pais e filhos implementem o relacionamento, elas não conseguem responder facilmente a algumas perguntas. 
3. O esquema simples de criança para pai pode ser aprimorado para responder melhor a algumas perguntas adicionando um sistema MCP ao plano. 
4. A noção de um pai para cada filho ainda está em vigor. Analisaremos em seguida um sistema que nos permite passar de vários pais para vários filhos. No entanto, se você acha que ter registros de pais vinculados a vários registros de filhos e vice-versa será complicado, você está certo. Serão necessárias muitas dicas. 
5. Mantendo-se apenas o sistema apresentado acima, com um ponteiro pai e vários ponteiros filhos, o sistema é limitado, pois apenas um número limitado de filhos pode ser endereçado por um sistema MCP. Em um sistema MCP, cada pai deve ter espaços de ponteiro predefinidos suficientes para o número máximo de registros filhos possível. Na próxima seção, veremos um sistema em que o esquema de ponteiros pai-filho é ilimitado.



#### 2.4.1.1 O Modelo Hierárquico com uma Lista Encadeada

Tendo utilizado o sistema MCP/FK para construir um banco de dados hierárquico, apresentamos agora um segundo modelo hierárquico. Vamos examinar novamente o banco de dados acima com ponteiros de filhos no registro pai \(MCP\). Agora, suponha que houvesse mais registros de filhos do que o planejado originalmente. Suponha que o sistema não fosse uma pessoa e esportes, mas alunos em uma escola e faltas. O aluno seria o registro pai, e os registros de ausência seriam o filho. Agora, suponha que você projetou este sistema com um relacionamento MCP para que um aluno pudesse ter até 20 faltas. O que acontece quando o aluno falta pela 21ª vez? Uma de duas coisas deve acontecer:

1. O sistema MCP teria que ser modificado para incluir algum tipo de estouro. 
2. Algum outro sistema hierárquico teria que ser usado.

Poderíamos, é claro, implementar isso como um sistema FK e ignorar completamente a parte do MCP. Mas o que acontece se você não tiver um componente MCP no seu banco de dados? Algumas consultas não seriam mais difíceis de responder?

Poderíamos implementar um sistema diferente para permitir filhos ilimitados para um pai sem usar um MCP. O sistema de arquivos a seguir usa um sistema de "lista encadeada" ou "cadeia" para implementar o relacionamento entre pai e filho. Com os mesmos dados, os registros seriam configurados da seguinte forma:
> ` Parent(link to 1st child) ` 
E, dentro dos registros da criança:
> ` Child(link to next child) ` 
Aqui estão os dados acima com este tipo de arranjo:
> PESSOA\(endereço\_registro, nome, primeiro esporte\) Com dados: `Brenda (101)` `Richard (103)` `Abbie (106)` > ESPORTES\(esporte, local, link para o próximo esporte dessa pessoa\). Um ponteiro, 999, indica o fim da cadeia de registros filhos. Com dados: `101, tennis, city courts, 102` `102, golf, municipal links, 999` `103, golf, municipal links, 104` `104, snorkeling, Pensacola Bay, 105` `105, running, UWF track, 999` `106, downhill skiing, Ski Beech, 999` 
Aqui, 999 significa “nenhum próximo link”.
FIGURA 2.3 Uma hierarquia de pessoas e esportes com uma lista vinculada de pais para filhos. 
A Figura 2.3 ilustra um esquema de apontamento de pai para filho em uma lista encadeada. Neste sistema, temos um link do pai para o filho que não tínhamos apenas com o sistema FK. Além disso, os registros, tanto no pai quanto no filho, têm tamanho uniforme. Tanto o pai quanto o filho contêm apenas um ponteiro. Além disso, neste sistema, não importa se uma pessoa pratica 1 esporte ou 100 — o sistema funciona bem se o número de registros filhos for desconhecido ou altamente variável. Se você argumentar que encontrar um registro filho específico entre 200.000 registros esportivos pode ser demorado, você está 100% correto. Se você argumenta que o sistema é frágil e que, se um link for perdido, tudo cai, você está correto novamente. Embora esse sistema de lista encadeada possa parecer um tanto frágil, ele formou a base para vários dos bancos de dados comerciais de maior sucesso. Como você poderia esperar, a lista encadeada básica incluía melhorias como links diretos de volta para o pai, links para frente e para trás, e links que pulavam ao longo da cadeia em uma direção e não na outra \(anéis de coral\). Todas essas melhorias foram a base do design de bancos de dados na década de 1970.



#### 2.4.1.2 Terminologia de Relacionamento

Tendo visto como implementar relacionamentos em bancos de dados hierárquicos, precisamos refinar um pouco a linguagem sobre como os relacionamentos são formados. Relacionamentos em todos os modelos de banco de dados têm o que chamamos de restrições estruturais. Uma restrição estrutural consiste em dois conceitos: cardinalidade e opcionalidade. Cardinalidade é uma descrição de quantos registros de um tipo se relacionam com o outro e vice-versa.

Suponha que implementamos um banco de dados sobre uma pessoa e seus livros. Temos uma pessoa \(registro pai\) e livros \(registros filhos\). Em nosso banco de dados, se uma pessoa pode possuir vários livros e cada livro específico pode ter apenas uma pessoa-pai nomeada, diríamos que a cardinalidade do relacionamento é um-para-muitos: uma pessoa se relaciona com um ou mais livros e um livro específico tem apenas uma pessoa-proprietário no banco de dados. Esse relacionamento um-para-muitos é abreviado como 1:M; a cardinalidade do relacionamento pessoa-livro é dita 1:M.

Se a situação fosse tal que uma pessoa pudesse ter vários livros e um livro pudesse ser reivindicado por mais de uma pessoa, então a cardinalidade seria muitos para muitos: muitas pessoas se relacionam com muitos livros. Muitos para muitos é abreviado como M:N \(como em M de um lado se relaciona com N do outro lado, e M e N geralmente não são iguais\).

Opcionalidade refere-se à possibilidade de um registro ter ou não um registro correspondente no outro arquivo. Se uma pessoa pode ou não ter livros, a opcionalidade da relação entre pessoa e livro é opcional ou parcial. Se os livros no banco de dados devem ser "relacionados a" ou "atribuídos a" alguém, a opcionalidade da relação entre livro e pessoa é obrigatória ou total.

Além disso, os relacionamentos são sempre declarados em ambas as direções em uma descrição de banco de dados. Diríamos, por exemplo,
> As pessoas podem ter zero ou mais livros, 
e
> Os livros devem ser associados a uma e somente uma pessoa. 
Observe a pessoa a ser reservada, a cardinalidade um-para-muitos e a natureza opcional/obrigatória do relacionamento. Retornaremos a essa linguagem, mas é fácil perceber que a maneira como um banco de dados é projetado depende de sua descrição. Se a descrição for clara e inequívoca, o resultado provável do projeto do banco de dados será muito mais previsível. Esperamos que isso esclareça por que tantos esforços são feitos na fase de elucidação/especificação do projeto do banco de dados para expressar cuidadosamente como cada relacionamento deve ser implementado. Fará diferença na implementação do banco de dados se "Livros devem ser associados a uma e apenas uma pessoa" ou "Livros podem ser associados a uma e apenas uma pessoa".



#### 2.4.1.3 Desvantagens do Modelo Hierárquico

Todos os relacionamentos entre registros em um modelo hierárquico têm cardinalidade de um para muitos ou um para um, mas nunca de muitos para um ou muitos para muitos. Portanto, para um modelo hierárquico de funcionário e dependente, só podemos ter o relacionamento funcionário-dependente como um para muitos ou um para um; um funcionário pode ter zero ou mais dependentes. No modelo hierárquico, não é possível ter dependentes com vários pais-funcionários.

Como ilustramos, a maneira original como os bancos de dados hierárquicos foram implementados envolvia escolher alguma maneira de "conectar" fisicamente os registros pai e filho. Pense em um banco de dados em papel e imagine que você pesquisou informações sobre um funcionário em um arquivo de funcionários. Em seguida, você deseja encontrar os registros de dependentes desse funcionário em um arquivo de dependentes. Uma maneira de implementar o relacionamento funcionário-dependente seria fazer com que um registro de funcionário apontasse para um registro de dependente e que esse registro de dependente apontasse para o próximo dependente \(uma lista vinculada de registros filho\). Por exemplo, você encontra um funcionário chamado McDonald. No registro do McDonald's, há uma notação de que o primeiro dependente do McDonald's é encontrado no arquivo de dependentes, gaveta de arquivo 2, registro 17. A "gaveta de arquivo 2, registro 17" é chamada de ponteiro e é a conexão ou relacionamento entre o funcionário e o dependente. Agora, para levar esse exemplo adiante, suponha que o registro do dependente na gaveta de arquivo 2, registro 17, aponte para o próximo dependente na gaveta de arquivo 3, registro 38. Então, esse dependente aponta para o próximo dependente na gaveta de arquivo 1, registro 82.

Conforme apontado na discussão sobre modelos hierárquicos, a abordagem de lista encadeada para conectar registros pai e filho apresenta vantagens e desvantagens. Por exemplo, algumas vantagens seriam que cada funcionário precisa manter apenas um ponteiro e o tamanho da lista encadeada de dependentes é teoricamente ilimitado. As desvantagens incluem a fragilidade do sistema, ou seja, se um registro dependente for destruído, a cadeia é quebrada. Além disso, se você quiser informações sobre apenas um dos registros filho, talvez seja necessário procurar em muitos registros antes de encontrá-lo.

A questão aqui é que algum sistema deve ser escolhido para ser implementado no software de banco de dados subjacente. Uma vez escolhido o sistema de vinculação, ele é corrigido pela implementação do software. A forma como a vinculação é feita deve ser usada para vincular todos os registros filhos aos pais, independentemente de quão eficiente ou ineficiente ela possa ser em uma situação específica.

Existem três grandes desvantagens no modelo hierárquico:

1. Nem todas as situações se enquadram no formato um-para-muitos, pai-filho. 
2. A escolha da maneira como os arquivos são vinculados tem impacto no desempenho e no armazenamento tanto positivo quanto negativo. 
3. A vinculação dos registros dos pais e dos filhos é feita fisicamente. Se o arquivo dependente fosse reorganizado, todos os ponteiros teriam que ser redefinidos.



## 2.5 O MODELO DE REDE

Cada um dos métodos apresentados para o banco de dados hierárquico tem vantagens e desvantagens. O modelo de rede permite relacionamentos M:N \(muitos para muitos\). Por exemplo, se embelezássemos o banco de dados acima para torná-lo M:N, desejaríamos implementar um sistema de ponteiros para múltiplos pais para cada registro filho. Como isso seria tratado? Provavelmente, seriam necessários múltiplos links de encaminhamento filho com uma lista encadeada ou um sistema MCP no pai, e ponteiros pai nos registros filho \(talvez mais de um\). O modelo de rede aliviou uma grande preocupação do modelo hierárquico, pois, no modelo de rede, não se estava restrito a ter um pai por filho; um relacionamento muitos para muitos ou muitos para um era aceitável.

Para exemplificar uma abordagem de rede, vamos revisitar o exemplo PERSON-SPORTS, mas agora permitindo que um registro esportivo seja conectado a mais de uma pessoa. Seguem dados de exemplo com mais pessoas e mais esportes, utilizando um sistema MCP em ambas as direções:

+ Primeiro, os dados: `Brenda: tennis, city courts; golf, municipal links``Richard: golf, municipal links; snorkeling, Pensacola Bay; running, UWF track``Abbie: downhill skiing, Ski Beech``David: snorkeling, Pensacola Bay; golf, municipal links``Kaitlyn: curling, Joe’s Skating Rink; downhill skiing, Ski Beech``Chrissy: cheerleading, Mountain Breeze High; running, UWF track` 
+ Agora, diagramamos esse conglomerado de dados com ponteiros \(usamos números de registro em cada “arquivo”\): PESSOA\(número\_de\_registro, nome, \{esportes\}\)ESPORTES\(número\_de\_registro, esporte, local, \{quem joga\}\)

Em cada caso, a parte da descrição do arquivo entre parênteses, como \(quem toca\), é chamada de grupo de repetição, o que significa que pode ter vários valores. Nosso pequeno, embora complexo, banco de dados se parece com isto:
> PESSOA\(número\_recorde, nome, \{esportes\}\) Com dados: `Kaitlyn, (107, 106)` `Abbie, (106)` `Brenda, (102, 101)` `Chrissy, (108, 105)` `Richard, (103, 104, 105)` `David, (104, 102)` > ESPORTES\(número\_recorde, esporte, local, \{quem joga\}\) Com dados: `101 tennis, city courts, (3)` `102 golf, municipal links, (3, 6)` `103 golf, municipal links, (5)` `104 snorkeling, Pensacola Bay, (5, 6)` `105 running, UWF track, (4, 5)` `106 downhill skiing, Ski Beech, (2, 1)` `107 curling, Joe’s Skating Rink, (1)` `108 cheerleading, Mountain Breeze High, (4)` 
A rede com ponteiros em ambas as direções é ilustrada na Figura 2.4.
FIGURA 2.4 Uma rede de pessoas e esportes com indicadores do MCP e dos pais. 
A complexidade do banco de dados em rede é exponencialmente maior do que a do hierárquico. O banco de dados que acabamos de ilustrar poderia ter sido implementado como uma série de filhos/pais vinculados ou alguma outra combinação de links e ponteiros. A segunda e a terceira desvantagens dos bancos de dados hierárquicos se estendem aos bancos de dados em rede. Se alguém fosse projetar um sistema de banco de dados baseado em arquivos do zero, teria que escolher algum método de conectar ou vincular fisicamente os registros. Essa escolha de conexão de registros nos leva ao mesmo problema anterior: uma conexão implementada em hardware tem um impacto positivo e negativo no desempenho. Além disso, à medida que o banco de dados se torna mais complexo, os caminhos das conexões e os problemas de manutenção tornam-se exponencialmente mais difíceis de gerenciar.

Como projeto, você poderia criar o banco de dados PERSON-SPORTS com alguns registros a mais do que os fornecidos no exemplo, usando listas encadeadas. A princípio, você pode achar que este é um exercício intimidador, mas um dos sistemas de banco de dados mais populares da década de 1970 usava uma variante desse sistema. Os registros pai e filho eram todos encadeados com listas encadeadas que iam em duas direções — para frente e para trás. A ideia de avançar/retroceder era acelerar a busca por registros filhos, de modo que fosse possível pesquisá-los em qualquer direção. Um aprimoramento desse sistema é usar listas encadeadas que apontam para a frente com uma cadeia de links que aponta para trás, mas com a cadeia para trás pulando cada n registro, onde o n ótimo acaba sendo a raiz quadrada do número de entradas na cadeia. Agora concluímos o tour pelo banco de dados histórico eliminando todos os ponteiros de uma vez.



## 2.6 O MODELO RELACIONAL

Codd \(1970\) introduziu o modelo relacional para descrever um banco de dados que não sofre as desvantagens dos modelos hierárquico e de rede \(ou seja, links físicos e restrições de hardware\). A premissa de Codd era que, se ignorarmos a maneira como os arquivos de dados são conectados e organizarmos nossos dados em tabelas simples, bidimensionais e não ordenadas, podemos desenvolver um cálculo para consultas \(perguntas feitas ao banco de dados\) e focar nos dados como dados, não como uma realização física de um modelo lógico. A ideia de Codd era verdadeiramente lógica porque não se estava mais preocupado com a forma como os dados eram armazenados fisicamente. Em vez disso, os conjuntos de dados eram simplesmente tabelas de dados bidimensionais e não ordenadas. Para chegar a uma maneira viável de decidir quais partes de dados iriam para qual tabela, Codd propôs "formas normais". Para entender as formas normais, devemos primeiro introduzir a noção de dependências funcionais. Depois de entender as dependências funcionais, as formas normais seguem.

Como nota histórica, quando Codd apresentou seu modelo relacional, ele foi considerado por muitos como "apenas teórico". Na época, um mainframe típico podia ter 64 KB de memória interna, e um conjunto realmente bom de discos rígidos podia ter até vários megabytes de armazenamento. Além disso, o computador normalmente ocupava uma sala grande, exigindo tratamento de ar separado, características arquitetônicas especiais como pisos elevados e redes elétricas aprimoradas. Todo o "poder computacional" era compartilhado por todos que precisavam de computação. Em uma empresa, os usuários podem incluir contabilidade, compras, pessoal, finanças e assim por diante. Para que mesmo uma dessas unidades pudesse executar o modelo relacional no início da década de 1970, seriam necessários vastos recursos dedicados. À medida que os computadores se tornaram mais onipresentes, mais baratos, menores e assim por diante, a quantidade de memória disponível interna e externamente tornou-se mais barata e tinha uma capacidade muito maior. O modelo relacional "cresceu" com a evolução dos computadores na década de 1980. Expandiremos a noção de banco de dados relacional no próximo capítulo.

Ponto de verificação 2.3

1. Quais são os três principais modelos de dados que discutimos? 
2. Qual modelo de dados é mais utilizado hoje? Por quê? 
3. Quais são algumas das desvantagens do modelo de dados hierárquico? 
4. Quais são algumas das desvantagens do modelo de dados de rede? 
5. Como todos os relacionamentos \(principalmente as cardinalidades\) são descritos no modelo de dados hierárquico? Como isso pode ser uma desvantagem do modelo de dados hierárquico? 
6. Como todos os relacionamentos \(principalmente as cardinalidades\) são descritos no modelo de dados de rede? Você os consideraria vantagens ou desvantagens do modelo de dados de rede? 
7. O que são restrições estruturais? 
8. Por que a promessa de Codd do modelo relacional foi melhor?





## 2.7 RESUMO DO CAPÍTULO

Neste capítulo, abordamos conceitos essenciais para a compreensão e o design de um banco de dados. Também abordamos modelos de dados sob uma perspectiva histórica — os modelos hierárquico e de rede, e a introdução ao modelo relacional. Este capítulo deve servir como pano de fundo histórico para o material do restante do livro.



## BIBLIOGRAFIA

+ Codd, E.F. \(1970\). Um modelo relacional de dados para grandes bancos de dados compartilhados. Comunicações da ACM, 13\(6\): 377–387.





# 3 O Modelo Relacional e Dependências Funcionais



DOI: 10.1201/9781003314455-3



## 3.1 INTRODUÇÃO

Conforme discutido no Capítulo 2, a ideia de Edgar Codd para um banco de dados relacional era que os dados fossem organizados em tabelas simples, bidimensionais e não ordenadas. Organizando os dados corretamente dessa maneira, podemos fazer perguntas sobre o conteúdo do banco de dados \(gerar consultas\) de forma direta e, essencialmente, ignorar a forma física como os dados são armazenados. Para começar, exploramos a ideia de "tabela adequada" e, em seguida, examinamos as dependências funcionais \(DFs\). Como Codd sugeriu, não criaremos nosso banco de dados com registros fisicamente vinculados, mas sim garantiremos que os dados estejam em um formato adequado. Isso significa que os dados são normalizados, o que é alcançado seguindo a noção de DFs.



## 3.2 FUNDAMENTOS DE BANCO DE DADOS RELACIONAL

Começamos nossa discussão sobre o banco de dados relacional com a ideia mais fundamental: a tabela bidimensional. Isso significa que os dados são organizados em linhas e colunas com um dado em cada célula, conforme mostrado na Tabela 3.1a.
TABELA 3.1A Tabela bidimensional de dados relacionais.    **coluna1**  **coluna2**  **coluna3** …     `row1`  `data-cell`  `data-cell`  `data-cell`     `row2`  `data-cell`  `data-cell`  `data-cell`     `row3`  `data-cell`  `data-cell`  `data-cell`      
A Tabela 3.1b é um exemplo de uma tabela CLIENTE.
TABELA 3.1B Visão bidimensional da tabela CLIENTE.   **nome**  **número de telefone**  **endereço**     `Jones`  `222–3333`  `123 4th St`    `Smith`  `333–2154`  `55 Main St`    `Adams`  `555–8888`  `3145 Euclid Ct`     


As colunas recebem títulos: nome, telefone, endereço.

As linhas são arranjos horizontais de células de dados sob cada coluna.
> A linha 1 contém `Jones 222–3333 123 4th St`. Muitas vezes, ao discutir uma linha em uma tabela, ela é denotada assim: `<Jones, 222–3333, 123 4th St>` 
As células de dados contêm fatos. Por exemplo, você tem um cliente chamado Smith, o endereço dele é Rua Principal, 55, e assim por diante. Na tabela bidimensional, cada coluna contém o mesmo tipo de dados — o mesmo tipo de dados com a mesma semântica \(mesmo significado\). A Tabela 3.2 é um arranjo bidimensional, mas viola o sentido de "cada coluna contém o mesmo tipo de dados".
TABELA 3.2 Arranjo bidimensional onde cada coluna não contém o mesmo tipo de dados.   **nome**  **número de telefone**  **endereço**     `Jones`  `222–3333`  `123 4th St`    `55 Main St`  `Smith`  `333–2154`    `Adams 3145`  `Euclid Ct`  `555–8888`     
Os mesmos dados estão lá, mas estão misturados e os títulos das colunas não fazem sentido. Em um arranjo como esse, diríamos que os dados eram "inconsistentes".

Em bancos de dados relacionais, a célula de dados deve ser atômica. A característica da atomicidade significa que a célula contém apenas um fato. Se Adams tivesse dois números de telefone e eles fossem inseridos na mesma linha, não seria uma tabela de dados válida para um banco de dados relacional. Seria necessário projetar as tabelas de outra forma.

Como pode ser visto na Tabela 3.3, o número de telefone de Adams é não atômico. Diz-se que a célula de dados que contém os dois números de telefone contém um grupo de repetição. Se um arranjo bidimensional de células de dados contém apenas dados atômicos, diz-se que é uma tabela. Este arranjo de dados com uma célula não atômica não é uma tabela, ao contrário do exemplo anterior \(Tabela 3.2\) com todas as células atômicas. Na terminologia de Codd para banco de dados, se você tem uma tabela \(ou seja, um arranjo bidimensional de dados atômicos\), então seus dados estão na primeira forma normal \(1NF\).
TABELA 3.3 Arranjo contendo células não atômicas.   **nome**  **número de telefone**  **endereço**     `Jones`  `222–3333`  `123 4th St`    `Smith`  `333–2154`  `55 Main St`    `Adams`  `555–8888, 555–8889`  `3145 Euclid Ct`     
Na teoria de bancos de dados relacionais, existe uma notação abreviada para se referir a linhas e colunas em tabelas. Chamaremos tabelas preenchidas de "tabelas" e colunas de "atributos". Em termos resumidos, tabelas são geralmente abreviadas com uma letra maiúscula, como R, e os atributos, como A, B, C... Podemos dizer:
> R\(A, B, C, D\) 
está em 1NF, enquanto
> R\(A, B, C, \{D\}\) 
não é 1NF, pois \{D\} representa um grupo repetitivo. As chaves significam "grupo repetitivo".

Ponto de verificação 3.1

1. O seguinte arranjo de dados é uma tabela? license\_nomakecolor`12345``Honda``Grey``54321``Ford``Green, White` 
2. O seguinte arranjo de dados é uma tabela? license\_nomakecolor`12345``Honda``Grey``54321``Green``Ford` 
3. O seguinte arranjo de dados é uma tabela? license\_nomakecolor`12345``Honda``Grey``54321``Ford``Green` 
4. O seguinte arranjo de dados é uma tabela? makelicense\_nocolor`Honda``12345``Grey``Ford``54321``Ford` 
5. O seguinte arranjo de dados é uma tabela? license\_nomakecolor`12345``null``Grey``54321``Green``null` 
6. O que significa R\(A, B, C, D, E, F\)?



## 3.3 BANCO DE DADOS E CONJUNTOS RELACIONAIS

Em matemática, definimos conjuntos como uma coleção não ordenada de objetos únicos. Codd visualizou e definiu um banco de dados relacional como: Todas as tabelas contêm conjuntos de linhas e todos os dados são atômicos em tabelas bidimensionais. A noção de "conjuntos de linhas" é poderosa porque implica duas coisas:

1. Não há linhas duplicadas. 
2. Não há ordem entre as linhas. \(Não se presume que as linhas sejam classificadas de forma alguma\).

Conjuntos matemáticos não estão em ordem ordenada e não contêm duplicatas. Se eu tivesse um conjunto de vestuário, ele poderia conter sapatos, meias, camisa, calças e chapéus. O mesmo conjunto poderia ser escrito como \(calças, camisa, meias, chapéus, sapatos\). A ordem dos itens no conjunto não é definida. Um item está no conjunto ou não está nele. No que diz respeito ao conjunto, o conjunto \(calças, camisa, meias, chapéu, calças, camisa, sapatos, meias, chapéus\) é o mesmo de antes. A duplicação de itens não faz sentido em conjuntos.

Quando analisamos algumas linhas de dados em um banco de dados relacional, pensamos nas tabelas como conjuntos de linhas. Considere a Tabela 3.4.
TABELA 3.4 Conjunto de linhas.   **nome**  **trabalho**     `Rich`  `Carpenter`    `Beryl`  `Dentist`    `Mary Jo`  `Programmer`     
Em termos de conjuntos, a Tabela 3.5 mostra a mesma tabela que a Tabela 3.4.
TABELA 3.5 Tabela mostrando que a ordem das linhas não é importante.   **nome**  **trabalho**     `Beryl`  `Dentist`    `Mary Jo`  `Programmer`    `Rich`  `Carpenter`     
A ordem das linhas não é importante. Se tivéssemos uma linha duplicada, como mostrado na Tabela 3.6, não teríamos uma tabela relacional válida. Como um banco de dados relacional é um "conjunto de linhas", a linha extra é desnecessária para a extração de informações no banco de dados. Além disso, do ponto de vista prático, a linha duplicada violaria o princípio de ser possível identificar apenas uma linha de uma chave primária.
TABELA 3.6 Tabela com linhas duplicadas.   **nome**  **trabalho**     `Rich`  `Carpenter`    `Beryl`  `Dentist`    `Mary Jo`  `Programmer`    `Rich`  `Carpenter`     
Assim como acontece com os conjuntos, podemos nos perguntar: <Lindsey, Cook> está no banco de dados? Neste caso, Lindsey não está. A questão é que a linha específica está lá ou não — ela está no conjunto de linhas, ou não.



## 3.4 DEPENDÊNCIA FUNCIONAL

Uma dependência funcional \(DF\) é um relacionamento de um atributo em uma tabela com outro. Em um banco de dados, frequentemente temos o caso em que um atributo define o outro. Por exemplo, podemos dizer que o número do Seguro Social \(SSN\) define ou identifica um nome. O que isso significa? Significa que se eu tiver um banco de dados com CPFs e nomes, e se eu souber o CPF de alguém, então posso encontrar o nome da pessoa. Além disso, como usamos a palavra define, estamos dizendo que para cada CPF teremos um e apenas um nome. Diremos que classificamos o nome como funcionalmente dependente do CPF.

A ideia de uma FD é definir um campo como uma âncora a partir da qual sempre se pode encontrar um único valor para outro campo. Se isso lhe parece familiar, é porque é — esta é a ideia da chave primária que discutimos anteriormente. A ideia principal em FDs é encontrar chaves primárias de forma que todos os dados em um registro dependam apenas da chave primária.

Em um banco de dados, o designer faz escolhas definindo dados com FDs. É responsabilidade do designer obter informações de FDs do usuário. O usuário nos diz se um projeto tem um ou vários locais. O usuário nos diz se uma pessoa pode ter apenas um número de telefone ou não. Além disso, trabalhando de trás para frente a partir dos dados, não se pode examinar um banco de dados e "provar" que um atributo é funcionalmente dependente de outro. A ideia de uma FD é de definição, e ela se aplica ao design da tabela, assim como a definição de uma coluna e tipo de dado.

Como outro exemplo, suponha que uma empresa atribuiu a cada funcionário um número de funcionário exclusivo. Considere o número e o nome do funcionário por um momento. Cada funcionário tem um número de funcionário e um nome. Os nomes podem ser os mesmos para dois funcionários diferentes, mas seus números de funcionário sempre seriam diferentes e únicos porque a empresa os definiu dessa forma. Seria inconsistente no banco de dados se houvesse duas ocorrências do mesmo número de funcionário com nomes diferentes.

Escrevemos um FD com uma seta como esta:
> SSN → nome 
ou
> empno → nome 
A expressão empno → nome é lida “empno define nome” ou “empno implica nome”.

Ponto de verificação 3.2

1. Na tabela a seguir, todos os dados estão em conformidade com empno → nome? empnoname`123``Beryl``456``Mary Jo` 
2. O fato de os dados estarem de acordo com o DF proposto prova que o DF é de fato verdadeiro? 
3. Na tabela a seguir, todos os dados estão em conformidade com empno → nome? empnoname`123``Beryl``456``Mary Jo, Mary, MJ` 
4. Na tabela a seguir, todos os dados estão em conformidade com empno → nome? `<123,``Beryl>``<MJ,``456>` 
5. Na tabela a seguir, empno → nome? empnoname`123``Beryl``456``Mary Jo`



## 3.5 NÃO-1NF PARA 1NF

Vamos considerar a disposição dos dados na Tabela 3.7.
TABELA 3.7 Dados de amostra para CLIENTE.   **número\_do\_cliente**  **nome**  **número de telefone**  **endereço**     `101`  `Jones`  `222–3333`  `123 4th St`    `102`  `Smith`  `333–2154`  `55 Main St`    `107`  `Adams`  `555–8888, 555–8889`  `3145 Euclid Ct`     
O que aprendemos até agora sobre dados como este? O customer\_no provavelmente é único. Por quê? Porque quem criou esta tabela de clientes provavelmente usaria customer\_no como um identificador único para clientes. Os dados comprovam que customer\_no são únicos? Dados não podem "provar" nada. Seria apropriado dizer que este exemplo sugere que customer\_no são identificadores únicos, mas a designação de customer\_no como uma chave primária única para esta tabela é uma questão de definição.

O phone\_no para Adams é não atômico. Diz-se que a célula de dados que contém os dois números de telefone contém um "grupo de repetição". Esse arranjo de dados faz sentido para nós, mas precisa ser reorganizado para se adequar à definição de uma tabela 1FN. Simbolicamente, R\(A, B, \{C\}, D\) não é 1FN, pois \{C\} representa um grupo de repetição.

Antes de lidar com o problema não-1NF, é melhor definir uma chave primária em R, se possível. Uma chave primária é um atributo que sempre identifica de forma única uma linha em uma tabela. Suponha que a chave primária seja o atributo A \(aqui, customer\_no\), que assumiremos ser único para cada cliente por definição. Então, a maneira como o grupo de repetição é tratado é por meio de um processo chamado decomposição. A tabela original, R\(A, B, \{C\}, D\), será decomposta em duas tabelas:
> R1\(A, B, D\) \(a chave é A\) 
e
> R2\(A, C\) \(a chave é A e C — uma chave concatenada\) 
Voltando ao exemplo CUSTOMER, se definissemos customer\_no como a chave primária, a decomposição seria assim:

+ CLIENTE \(número do cliente, nome, \{telefone\}, endereço\)

se tornará \(se decomporá em duas tabelas\):

+ CLIENTE1 \(número do cliente, nome, endereço\) \(a chave é customer\_no\)

e

+ CLIENTE2 \(cliente\_nº, telefone\_nº\) \(A chave é cliente\_nº \+ telefone\_nº\)

A notação customer\_no\+phone\_no é chamada de concatenação. As novas tabelas preenchidas terão a aparência das Tabelas 3.8 e 3.9.
TABELA 3.8 Dados de amostra para CLIENTE1.   **número\_do\_cliente**  **nome**  **endereço**     `101`  `Jones`  `123 4th St`    `102`  `Smith`  `55 Main St`    `107`  `Adams`  `3145 Euclid Ct`      TABELA 3.9 Dados de amostra para CLIENTE2.   **número\_do\_cliente**  **endereço**     `101`  `222–3333`    `102`  `333–2154`    `107`  `555–8888`    `107`  `555–8889`     
Todos os dados agora são atômicos em ambas as tabelas — ambas estão na 1NF. A chave primária da primeira tabela, customer\_no em CUSTOMER1, é referenciada na segunda tabela. Customer\_no em CUSTOMER2 é chamada de chave estrangeira, pois faz referência a uma chave primária em outra tabela. Em CUSTOMER1, a chave é customer\_no, que é única e, portanto, serve para identificar uma linha. Em CUSTOMER2, não há um atributo específico que identifique uma linha; portanto, a linha inteira é considerada uma chave primária. A linha consiste na concatenação de customer\_no e phone\_no.

Consideremos outro exemplo. Suponha que não houvesse número de cliente, nem chave óbvia. Suponha que os dados originais se parecessem com a Tabela 3.10.
TABELA 3.10 Dados de amostra para a tabela CLIENTE original.   **nome**  **número de telefone**  **endereço**     `Jones`  `222–3333`  `123 4th St`    `Smith`  `333–2154`  `55 Main St`    `Adams`  `555–8888, 555–8889`  `3145 Euclid Ct`     
Nem nome nem endereço seriam considerados identificadores de linha confiáveis; agora, não temos uma chave óbvia e temos um grupo de repetição. O que fazemos? Pegamos os valores do grupo de repetição e os combinamos com todos os outros atributos, chamando toda a linha de chave. Esta é a melhor chave que você pode escolher? Talvez; maneiras de determinar o valor de todos os atributos concatenados como uma chave serão determinadas mais adiante neste capítulo, à medida que definimos as outras formas normais. Aqui, pegamos um arranjo de dados não-1NF e o transformamos em 1NF. Além disso, essa técnica sempre funciona porque você acaba com dados atômicos em cada coluna em uma tabela bidimensional \(1NF\). A Tabela 3.11 é a decomposição na qual não temos uma chave primária óbvia:

+ CLIENTE \(nome, \{telefone\}, endereço\)
TABELA 3.11 CLIENTE sem chave primária óbvia.   **nome**  **número de telefone**  **endereço**     `Jones`  `222–3333`  `123 4th St`    `Smith`  `333–2154`  `55 Main St`    `Adams`  `555–8888, 555–8889`  `3145 Euclid Ct`     
A Tabela 3.11 é transformada em uma tabela com nome e telefone como chave \(Tabela 3.12\):

+ CLIENTE \(nome, telefone, endereço\)


TABELA 3.12 Dados de exemplo para CLIENTE com nome e telefone como chave.   **nome**  **número de telefone**  **endereço**     `Jones`  `222–3333`  `123 4th St`    `Smith`  `333–2154`  `55 Main St`    `Adams`  `555–8888`  `3145 Euclid Ct`    `Adams`  `555–8889`  `3145 Euclid Ct`     
Nesta tabela transformada, agora temos 1NF, linhas exclusivas e uma chave primária. Observe que, no caso de CUSTOMER com um customer\_no exclusivo adicionado, ele poderia ser resolvido para 1NF facilmente, assim:

+ CLIENTE \(número\_do\_cliente, nome, número\_de\_telefone, endereço, cidade\)

Mas, como temos uma chave primária em customer\_no, essa decomposição \(Tabela 3.13\) é um pouco mais complexa. À medida que adotamos outras formas normais, esse problema será resolvido.
TABELA 3.13 Dados de amostra para CLIENTE resolvidos para 1NF.   **número\_do\_cliente**  **nome**  **número de telefone**  **endereço**  **cidade**     `101`  `Jones`  `222–3333`  `123 4th St`  `Pensacola`    `102`  `Smith`  `333–2154`  `55 Main St`  `Alpharetta`    `107`  `Adams`  `555–8888`  `3145 Euclid Ct`  `Two Egg`    `107`  `Adams`  `555–8889`  `3145 Euclid Ct`  `Two Egg`      
Ponto de verificação 3.3

1. Qual você acha que é a chave desta tabela? colormakeyear`Red``Honda``2018``Green``Ford``2020``Blue``Ford``2018``Red``Buick``2019` 
2. Coloque este arranjo de dados em 1NF: nometelefoneresidencialcelular`Jones``111-1111, 222-2222``333-3333``Smith``444–4444``555–5555, 666–6666``Adams``777–7777, 888–8888``112–1212, 113–1313`



## 3.6 A SEGUNDA FORMA NORMAL

Normalmente, a segunda forma normal \(2FN\) é abordada quando verificamos se uma tabela está na primeira forma normal \(1FN\). Ao examinar uma tabela pela primeira vez, você deve primeiro decidir se ela é de fato uma tabela \(ou seja, está na 1FN\) e, além dos dados na tabela, perguntar qual é o seu design. Considere o seguinte arranjo de dados na Tabela 3.14.
TABELA 3.14 Disposição dos dados.   **número\_da\_licença**  **fazer**  **cor**     `12345`  `Honda`  `Grey`    `54321`  `Green`  `Ford`     
Os dados parecem estar na 1NF, então devemos perguntar: "Qual é o design da tabela?". A pequena quantidade de dados mostrada parece conter células atômicas e nenhuma linha duplicada. Mas o que não é declarado são as FDs pretendidas. A pergunta apropriada é: "Marca e cor são funcionalmente dependentes do número da licença?". Semanticamente, parecem ser, mas quem produziu esta tabela de dados também deve fornecer um design de tabela correspondente.

Agora, vamos considerar esta tabela de dados sem FD definido ainda \(Tabela 3.15\).
TABELA 3.15 Dados de amostra para FUNCIONÁRIO.   **Empno**  **nome**     `101`  `Kaitlyn`    `102`  `Brenda`    `103`  `Beryl`    `104`  `Wallace`    `105`  `Wallace`     
Parece ser uma tabela válida? Sim, é consistente e contém dados atômicos e nenhuma linha duplicada. Agora, suponha que definimos os dados assim: O nome da tabela é EMPLOYEE. EMPLOYEE tem dois atributos: empno e name. Os tipos de dados dos atributos são os seguintes:
> FUNCIONÁRIO \[nº do funcionário NUMÉRICO\(3\), nome VARCHAR\(20\)\] 
VARCHAR é um tipo de dado muito comum que significa "número variável de caracteres", e VARCHAR\(20\) significa que os dados no atributo name terão de zero a 20 caracteres. Até aqui, tudo bem, mas falta alguma coisa? Não mencionamos nada sobre FDs. Se nenhuma FD for definida com a tabela, as únicas que podemos assumir são reflexivas:
> empno → empno, nome → nome, 
e
> empno, nome → empno, nome 
Essas DFs reflexivas são sempre verdadeiras; elas existem para o senso de completude matemática. Se você colocar essas DFs em palavras, elas diriam: "Se eu souber o nome de uma pessoa, posso lhe dizer o nome". Observe também que combinações de atributos podem ser DFs. A expressão empno, nome → empno, nome significa que, se eu souber uma combinação de empno e nome, posso lhe dizer o empno e o nome \(uma DF reflexiva\).

Ao observarmos a tabela, parece que temos o FD, empno → nome, mas, a menos que seja explicitamente definido como tal, só podemos dizer: "Parece que..." Espere\! Há duas pessoas chamadas Wallace. Isso é um problema com FDs? De jeito nenhum. Você espera que o nome não seja único, e é comum que duas pessoas tenham o mesmo primeiro nome. No entanto, não há duas pessoas com o mesmo empno, e para cada empno, há um e apenas um valor de nome.

Uma definição adequada para esta tabela seria:

+ FUNCIONÁRIO \(nº do funcionário NUMÉRICO\(3\), nome VARCHAR\(20\)\)

dado
> empno → nome 
O empno sublinhado indica que empno é a chave primária nesta tabela. Se uma chave primária for definida, ela estará sempre no lado esquerdo \(LHS\) de uma FD. Chaves primárias implicam FDs e são definidas. A chave primária não precisa ser a primeira coluna da tabela, mas é convencional colocá-la lá. FDs não definem necessariamente chaves primárias; mas, como veremos, um comando do cálculo de FDs nos levará a concluir o que pode ser uma chave primária e o que não pode.

Vejamos outro exemplo. Suponha que você receba esta tabela com empno definido como chave primária:

+ EMPLOYEE1 \(nº do funcionário NÚMERO\(3\), VARCHAR do cargo\(20\), nome VARCHAR\(20\)\)

O que isso nos diz? A definição da tabela nos diz que a primeira coluna será empno, a segunda coluna será job e a terceira coluna será name. Ela diz que todos os empno serão números de até três dígitos. Job e name serão strings de caracteres de até 20 caracteres cada. O empno sublinhado nos diz que empno é uma chave primária; portanto, duas FDs são definidas, empno → job e empno → name. As FDs dizem que, se você souber o empno, poderá encontrar o job e o nome para esse empno; job e name são definidos funcionalmente por empno. A Tabela 3.16 mostra alguns dados de exemplo.
TABELA 3.16 Dados de amostra para FUNCIONÁRIO1.   **empno**  **trabalho**  **nome**     `101`  `President`  `Kaitlyn`    `104`  `Programmer`  `Wallace`    `103`  `Designer`  `Beryl`     
Sempre que encontramos empno = 104, descobrimos que o nome é Wallace. Sempre que encontramos empno 103, sabemos que a função de 103 é Designer.

Vamos agora considerar esta tabela:

+ TÁXI \(número do táxi NUMERIC\(4\), data de condução\(DATA\), motorista VARCHAR\(20\)\)

Os FDs estão sendo disponibilizados.

A Tabela 3.17 mostra alguns dados de amostra.
TABELA 3.17 Dados de amostra para a tabela TAXI.   **número do táxi**  **orientado a data**  **motorista**     `101`  `2/4/2023`  `Rich`    `102`  `2/4/2023`  `Gen`    `103`  `2/5/2023`  `John`    `102`  `2/5/2023`  `Steph`     


Embora não possamos definir FDs observando os dados, podemos eliminá-los. Podemos dizer cab\_no → driver? Claramente, não podemos, pois cab\_no 102 possui dois drivers diferentes; temos duas linhas com dados que contradizem o FD, cab\_no → driver: <102, Gen>, <102, Steph>. Podemos dizer, date\_driven → driver? Novamente, a resposta é não, pois encontramos informações em contrário \(consulte 04/02/2023\). E quanto a date\_driven → cab\_no? Não. De acordo com esta tabela, são necessários cab\_no e date\_driven para definir um driver. Dados esses dados, podemos perguntar ao designer da tabela se a combinação de cab\_no e date\_driven formará o FD, cab\_no, date\_driven → driver? Supondo que essa seja a intenção, a definição completa da tabela seria:

+ TÁXI \(número do táxi NUMERIC\(4\), data de condução \(DATA\), motorista VARCHAR\(20\)\)

dado o FD
> nº\_do\_cab, data\_de\_viagem → motorista 
Os atributos cab\_no e date\_driven estão sublinhados. É a concatenação desses dois atributos que define uma chave primária para esta tabela.

Agora, suponhamos que expandamos um pouco nossa tabela TÁXI e incluímos informações sobre o próprio táxi — a cor do táxi. Vamos propor este design:

+ TAXI\(cab\_no NUMERIC\(4\), data\_driven \(DATE\), motorista VARCHAR\(20\), cor VARCHAR\(20\)\)

com FD
> nº\_cab, data\_condução → motorista, cor


Suponha que os dados agora apareçam como na Tabela 3.18.
TABELA 3.18 Dados de amostra para tabela TAXI refinada.   **número do táxi**  **orientado a data**  **motorista**  **cor**     `101`  `2/4/2023`  `Rich`  `Yellow`    `102`  `2/4/2023`  `Gen`  `Green`    `103`  `2/5/2023`  `John`  `Yellow`    `102`  `2/5/2023`  `Steph`  `Green`     
Esta tabela parece estar correta, mas há um problema oculto. O design indica que cab\_no, date\_driven, é a chave primária. Isso é verdade com este pequeno dado — se soubermos a combinação de cab\_no e date\_driven, podemos identificar o motorista e a cor da cabine. Se eu souber \(102, 04/02/2023\), posso encontrar o motorista \(Gen\) e a cor da cabine \(Verde\). Você pode detectar um problema aqui; no entanto, vamos continuar e ver se você o encontra. Para ilustrar o problema, suponha que a cabine 102 esteja pintada de vermelho. Você pode alterar os dados na tabela para refletir isso, mas observe o que você precisa fazer \(conforme ilustrado na Tabela 3.19\).
TABELA 3.19 Tabela TÁXI com redundância.   **número do táxi**  **orientado a data**  **motorista**  **cor**     `101`  `2/4/2023`  `Rich`  `Yellow`    `102`  `2/4/2023`  `Gen`  `Red`    `103`  `2/5/2023`  `John`  `Yellow`    `102`  `2/5/2023`  `Steph`  `Red`     
Você teve que fazer duas alterações. Imagine que esta tabela tem milhares de linhas e você altera a cor de uma cabine. Você precisa alterar cada linha para refletir a nova cor da cabine para aquela cabine. A cor da cabine é registrada redundantemente. Quando tal redundância aparece, é um sintoma de um problema de projeto. Aqui, dizemos que a tabela não está na 2FN.



### 3.6.1 Anomalias

A atualização que acabamos de propor é chamada de anomalia de atualização porque a mudança na cor do gabinete não é uma simples atualização de uma tabela, mas requer múltiplas atualizações devido à redundância. Há outros problemas com esta tabela de dados — outras anomalias. As anomalias se apresentam em três formas: atualização, inserção e exclusão.

Um exemplo de uma anomalia de inserção na tabela mal projetada anterior seria o seguinte: Suponha que você queira inserir dados de táxi e cor na tabela sem identificar um motorista ou uma data. Você não pode fazer isso porque teria que incluir uma linha como esta: `<105, null, null, Blue>`. Esta é uma linha inválida porque você não pode ter parte da chave primária como nula. Em um banco de dados relacional, há uma regra chamada restrição de integridade da entidade que se aplica a todas as tabelas e proíbe que qualquer parte de uma chave primária seja nula. Isso faz sentido porque se uma chave primária ou qualquer parte dela for nula, significa que você não pode saber a chave primária para identificar uma linha e, portanto, sua definição de chave primária é contraditória.

Um exemplo de anomalia de exclusão seria o seguinte: Suponha que você queira excluir um táxi do banco de dados. Suponha que o táxi nº 102 tenha sofrido um acidente e sido retirado da frota. Você não pode excluir o táxi nº 102 da tabela sem excluir todas as linhas onde o táxi nº 102 aparece, e essa exclusão também excluiria as outras informações, como `<102, 2/5/2023, Steph, Red>`, onde sabemos que Steph dirigiu em 05/02/2023. Uma anomalia de exclusão faz com que dados sejam excluídos além do pretendido.



### 3.6.2 Não-2NF para 2NF

Em termos de FDs, o problema em nossa tabela não-2NF é que a cor do táxi depende do cab\_no e não do date\_driven. Os FDs corretos nesta tabela são os seguintes:
> nº\_cab, data\_conduzido → motorista nº\_cab → cor 
Você precisa apenas do cab\_no para identificar a cor. Como você tem uma chave concatenada e um atributo na tabela depende apenas de parte da chave, isso é chamado de dependência parcial. Tabelas com dependências parciais não estão na segunda forma normal. Uma tabela na segunda forma normal \(2FN\) tem uma chave primária sem dependências parciais. Para que uma tabela não esteja na 2FN, é necessário que haja uma chave concatenada com algum atributo que não dependa da chave inteira.

Nessa situação de Cab não 2NF, a discussão simbólica do problema seria assim:

+ Temos uma tabela, R\(A, B, C, D\), com os FDs AB → C e A → D. Portanto, a tabela não está na 2FN porque você tem uma dependência parcial, A → D, quando AB é a chave da tabela; o atributo D depende de parte da chave AB, não da chave inteira.

O que você deve fazer com tabelas que não estão na 2FN? A resposta é decomposição. A tabela não 2FN é decomposta em duas tabelas; cada tabela contém dados dependentes apenas da chave primária \(a chave inteira e nada além dela\). Simbolicamente, R\(A, B, C, D\) com DFs AB → C e A → D \(não 2FN\) será decomposta em duas tabelas, R1\(A, B, C\) e R2\(A, D\), ambas na 2FN porque todos os atributos não-chave dependem apenas da chave primária. Voltando ao problema do Cab, a tabela original será decomposta em duas tabelas.

+ TÁXI \(cab\_no NUMERIC\(4\), data\_conduzido \(DATE\), motorista VARCHAR\(20\), cor VARCHAR\(20\)\)

com FDs
> nº\_cab, data\_condução → motorista, nº\_cab → cor 
torna-se…

+ TAXI\_1 \(cab\_no NUMERIC\(4\), data\_conduzido \(DATA\), motorista VARCHAR\(20\)\)

com FD
> nº\_do\_cab, data\_de\_viagem → motorista 
com dados de amostra conforme mostrado na Tabela 3.20.
TABELA 3.20 Dados de amostra para a tabela TAXI\_1.   **número do táxi**  **orientado a data**  **motorista**     `101`  `2/4/2023`  `Rich`    `102`  `2/4/2023`  `Gen`    `103`  `2/5/2023`  `John`    `102`  `2/5/2023`  `Steph`     
E

+ CAB \(cab\_no NUMERIC\(4\), cor VARCHAR\(20\)\)

com FD
> cab\_no → cor 
Com dados de amostra conforme mostrado na Tabela 3.21.
TABELA 3.21 Dados de amostra para a tabela CAB.   **número do táxi**  **cor**     `101`  `Yellow`    `102`  `Green`    `103`  `Yellow`     
Damos à nova tabela TAXI um nome ligeiramente diferente \(TAXI\_1\) para diferenciá-la da original. Reconsidere a atualização que propusemos. Com as tabelas decompostas, suponha que o cab\_no 102 fosse pintado de vermelho. A única linha a ser alterada nesta nova tabela decomposta é a segunda linha da tabela CAB, que agora se pareceria com a Tabela 3.22.
TABELA 3.22 Nova tabela CAB decomposta.   **número do táxi**  **cor**     `101`  `Yellow`    `102`  `Red`    `103`  `Yellow`     
Há uma mudança, uma linha atualizada. Com as tabelas em seu formato decomposto 2FN, não há redundância, e todos os dados não-chave dependem da chave primária de cada tabela:

+ TAXI\_1\(cab\_no NUMERIC\(4\), data\_orientada DATE, motorista VARCHAR\(20\)\)

com FD
> nº\_do\_cab, data\_de\_viagem → motorista 
E

+ CAB \(cab\_no NUMERIC\(4\), cor VARCHAR\(20\)\)

com FD
> cab\_no → cor 
As outras anomalias desaparecem quando as tabelas são decompostas. Você pode inserir um táxi e uma cor na tabela CAB sem alterar o TAXI\_1. Um táxi não precisa de um motorista ou de um sistema de data para ser adicionado ao banco de dados. Você pode excluir uma combinação de táxi e cor sem perder as informações sobre o motorista ou o sistema de data. Você excluirá apenas a cor do táxi.

Ponto de verificação 3.4

1. Dado AB → CDE, R\(A, B, C, D, E\) está na 2FN? 
2. Dado B → ACDE, R\(A, B, C, D, E\) está na 2FN? 
3. Dado AB → CD e B → E, R\(A, B, C, D, E\) está na 2FN? 
4. Se uma tabela estiver na 1NF e você não tiver uma chave concatenada, não precisará se preocupar com problemas na 2NF \(Verdadeiro/Falso\)?



## 3.7 A TERCEIRA FORMA NORMAL

Vamos agora considerar outro exemplo de uma tabela com uma chave definida:

+ FUNCIONÁRIO \(nº do funcionário NÚMERO\(3\), nome VARCHAR\(20\), ID da habilidade NÚMERO\(3\), descrição da habilidade VARCHAR\(20\)\)

com FD
> empno → nome, ID da habilidade, descrição da habilidade 
Ou, em resumo
> R\(A, B, C, D\) 
com FD
> A → BCD 
A Tabela 3.23 mostra alguns dados de amostra de FUNCIONÁRIO.
TABELA 3.23 Dados de amostra para a tabela EMPLOYEE.   **empno**  **nome**  **ID\_da\_habilidade**  **descrição\_de\_habilidade**     `101`  `Adams`  `Prog`  `Programmer`    `102`  `Baker`  `Brick`  `Bricklayer`    `103`  `Charles`  `PR`  `Public Relations`    `107`  `Davis`  `Prog`  `Programmer`     
Esta tabela está na 1ª e 2ª FN? Sim, está. Ela contém todos os atributos atômicos, não há chaves concatenadas e, portanto, não há chance de dependências parciais. No entanto, ainda há um problema aqui. Consegue identificá-lo? Para skill\_ID = Prog, temos uma skill\_desc = Programmer. Parece que há redundância no banco de dados.

Como ilustramos, redundância é um "sinal de alerta" — sugere um problema de design. Temos uma chave primária em empno; sabendo que empno nos permite identificar uma linha. Como empno é a chave primária, ela identifica todo o conteúdo da linha; portanto, podemos dizer legalmente que empno → nome, ID\_habilidade, desc\_habilidade. O problema é que skill\_desc é melhor definido por skill\_ID do que por empno; devido a essa definição, vemos que skill\_desc é funcionalmente dependente de skill\_ID mais do que empno. Temos uma dependência transitiva de empno → ID\_habilidade e ID\_habilidade → desc\_habilidade. Essa dependência transitiva causa redundância, o que provoca anomalias \(atualização, inserção e exclusão\). O que seria uma anomalia de atualização na tabela EMPLOYEE? Suponha que quiséssemos alterar a descrição skill\_desc de skill\_ID = `Prog` para skill\_desc = `Programmer/analyst?`. Haveria duas alterações de linha nesta pequena tabela de apenas quatro linhas. Uma anomalia de inserção surge quando tentamos inserir novos dados na tabela. Suponha que quiséssemos inserir o fato de que temos um skill\_ID = `Car`t e skill\_desc = `Cartographer` na tabela. Teríamos a Tabela 3.24.
TABELA 3.24 Dados de amostra para a tabela EMPLOYEE com cartógrafo.   **empno**  **nome**  **ID\_da\_habilidade**  **descrição\_de\_habilidade**     `101`  `Adams`  `Prog`  `Programmer`    `102`  `Baker`  `Brick`  `Bricklayer`    `103`  `Charles`  `PR`  `Public Relations`    `107`  `Davis`  `Prog`  `Programmer`    `null`  `null`  `Cart`  `Cartographer`     


Mas isso não funcionará porque violamos a regra de integridade da entidade. Uma anomalia de exclusão ocorreria se excluíssemos uma linha e perdêssemos mais informações do que o planejado. Suponha que decidíssemos excluir o funcionário Charles. Charles tem o ID de habilidade de PR, e você não só perde a linha com Charles, mas também perde o fato de que ID de habilidade = `PR` significa desc\_habilidade = `Public` `Relations`.

Agora, vamos retornar à tabela EMPLOYEE original e resolver o problema:

+ FUNCIONÁRIO \(nº do funcionário NÚMERO\(3\), nome VARCHAR\(20\), ID da habilidade NÚMERO\(3\), descrição da habilidade VARCHAR\(20\)\)

com FD
> empno → nome, ID da habilidade, descrição da habilidade 
ou
> R\(A, B, C, D\) 
com FD
> A → BCD 
O problema é que a skill\_desc depende funcionalmente da skill\_ID e não do empno. Os FDs corrigidos deveriam ser:
> empno → nome, ID\_habilidade 
e
> ID\_habilidade → descrição\_habilidade 
ou
> R\(A, B, C, D\) 
com FDs
> A → BC, C → D 
Isso ilustra uma dependência transitiva quando A → C e C → D. A terceira forma normal \(3NF\) não exige dependências transitivas. Assim como as dependências parciais em arranjos não-2NF, arranjos não-3NF causam anomalias:

1. Possíveis alterações múltiplas quando você atualiza um skill\_desc \(uma anomalia de atualização\) 
2. Incapacidade de adicionar uma linha com apenas um skill\_ID e seu skill\_desc \(uma anomalia de inserção\) 
3. Perda de informações ao excluir uma linha \(lembre-se de perder um skill\_ID quando Charles foi excluído\) — uma anomalia de exclusão.

Essas anomalias são causadas pela dependência transitiva. Como corrigimos esse problema? Como antes, decompomos a tabela não-3NF em duas tabelas nas quais os atributos dependerão apenas da chave da tabela:
> R\(A, B, C, D\) com FDs A→BC e C → D se tornam R1\(A, B, C\) e R2\(C, D\). 
Com nossos dados de FUNCIONÁRIOS, decompomos em duas tabelas como esta:

+ EMPLOYEE1\(empno NUMÉRICO\(3\), nome VARCHAR\(20\), ID\_habilidade NUMÉRICO\(3\)\)

com FD
> empno → nome, ID\_habilidade 
e

+ HABILIDADE \(ID\_habilidade NUMÉRICO\(3\), descrição\_habilidade VARCHAR\(20\)\)

com FD
> ID\_habilidade →desc\_habilidade 
As tabelas preenchidas serão semelhantes às Tabelas 3.25 e 3.26.
TABELA 3.25 Dados de amostra para a tabela EMPLOYEE1.   **empno**  **nome**  **ID\_da\_habilidade**     `101`  `Adams`  `Prog`    `102`  `Baker`  `Brick`    `103`  `Charles`  `PR`    `107`  `Davis`  `Prog`      TABELA 3.26 Dados de amostra para a tabela SKILL.   **ID\_da\_habilidade**  **descrição\_de\_habilidade**     `Prog`  `Programmer`    `Brick`  `Bricklayer`    `PR`  `Public Relations`     
Estas duas tabelas representam um banco de dados em 3NF. A redundância foi eliminada. Se você quiser alterar um skill\_desc, faça uma alteração. Se quiser excluir um funcionário, não perderá o skill\_ID-skill\_desc, e se quiser inserir um novo skill\_ID sem nenhum funcionário definido, poderá fazê-lo. As anomalias foram eliminadas.

Ponto de verificação 3.5

1. Considere esta tabela: EMPREGADO \(nº do funcionário, nome, nº do projeto, local do projeto\) com os FDs nº do funcionário → nº do funcionário, nome, nº do projeto e nº do projeto → local do projeto. Esta tabela está na 1ª, 2ª e 3ª NF? Decomponha a tabela, se necessário. 
2. Considere esta tabela: R\(A, B, C, D, E, F\) com DFs AB → CD, D → E, E → F. Esta tabela está na 1ª FN, 2ª FN, 3ª FN? Decomponha a tabela, se necessário.



## 3.8 A OPERAÇÃO EQUIJOIN

Em um banco de dados relacional, frequentemente decompomos tabelas não-3NF para 3NF. Gerentes e usuários podem reclamar: "Minha tabela de dados foi espalhada por todo lugar" ou "O processo de normalização removeu minha tabela de informações primária". Embora as tabelas sejam decompostas, elas podem ser facilmente reconstituídas com a operação equijoin do cálculo relacional, que é realizada em SQL \(Linguagem de Consulta Estruturada\). SQL é a linguagem de consulta de fato do banco de dados relacional. Uma discussão sobre cálculo relacional e SQL está além do escopo deste capítulo; existem muitas referências excelentes à linguagem de consulta \(Bagui e Earp, 2011; Earp e Bagui, 2021\). O ponto aqui é que, embora uma tabela normalizada possa ter sido decomposta, a tabela original pode ser reformada a partir das decompostas com uma simples consulta SQL. Como exemplo, suponha que temos uma tabela como a da seção anterior:

+ FUNCIONÁRIO \(nº do funcionário, nome, nº do projeto, local do projeto\)

com FDs
> empno → empno, nome, nº\_do\_projeto, localização\_do\_projeto 
e
> nº\_do\_projeto → local\_do\_projeto 
Reconhecemos a dependência transitiva e decompomos EMPLOYEE nestas duas tabelas:

+ EMPLOYEE1 \(nº do funcionário, nome, nº do projeto\) 
+ PROJETO \(projeto\_nº, projeto\_localização\)

A tabela EMPLOYEE pode ser reconstruída unindo EMPLOYEE1 e PROJECT pelo atributo comum project\_no. Project\_no é a chave primária de PROJECT e é uma chave estrangeira que faz referência a EMPLOYEE1. Se R\(A, B, C\) for decomposto em S\(A, B\) e T\(B, C\), a operação de equijoin pode reconstruir R combinando as tabelas S e T em linhas onde os valores do atributo comum B são iguais. Se R = EMPLOYEE, S = EMPLOYEE1, T = PROJECT e B = project\_no, a equijoin procederia da seguinte forma:

+ FUNCIONÁRIO \(nº do funcionário, nome, nº do projeto, local do projeto\)

com dados
> ` <101, Adams, P1, Pensacola>` `<102, Baker, P1, Pensacola>` `<103, Charles, P2, Mobile>` `<104, Davis, P2, Mobile> ` 
decompõe-se em

+ EMPLOYEE1 \(nº do funcionário, nome, nº do projeto\)

com dados
> ` <101, Adams, P1> <102, Baker, P1> <103, Charles, P2> <104, Davis, P2> ` 
e

+ PROJETO \(projeto\_nº, projeto\_localização\)

com dados
`<P1,`  `Pensacola>`    `<P2,`  `Mobile>`     
A operação equijoin J nos dá Resultado = \(EMPLOYEE1 J PROJECT\) em project\_no, resultando em

+ `<101, Adams, P1> joins with <P1, Pensacola> to give <101, Adams, P1, Pensacola>`  
+ `<102, Baker, P1> joins with <P1, Pensacola> to give <102, Baker, P1, Pensacola>`  
+ `<103, Charles, P2> joins with <P2, Mobile> to give <103, Charles, P2, Mobile>`  
+ `<104, Davis, P2> joins with <P2, Mobile> to give <104, Davis, P2, Mobile>`  

A tabela RESULT contém os mesmos dados da tabela EMPLOYEE original. A operação de junção pode usar operadores diferentes de igualdade, mas as outras variedades de junção são incomuns e estão além do escopo deste livro. A recombinação de tabelas decompostas durante o processo de normalização usa a operação equijoin.



## 3.9 ALGUMAS REGRAS DE DEPENDÊNCIA FUNCIONAL

Apresentamos agora um conjunto de regras de DF para auxiliar na busca de formas normais. Não abordamos esse assunto com grande rigor matemático, mas sim apelamos ao bom senso e à lógica. Há abordagens muito mais rigorosas para esse assunto \(Elmasri e Navathe, 2016\). Antes de determinarmos as formas normais, lidamos com a busca de uma chave mínima em uma tabela e, a partir dessa chave, trabalhamos para as formas normais. Designamos uma tabela com as letras R, S ou T \(geralmente R\). Representamos os atributos como A, B, C, … Por exemplo, se temos uma tabela R com três atributos A, B e C, abreviamos R\(A, B, C\). Agora, considere um problema que consiste em um conjunto de atributos e algumas DFs para ver como um conjunto de regras de DF nos permitirá organizar o banco de dados:

Recebemos alguns dados, que colocamos em uma tabela R\(A, B, C, D\), e recebemos alguns FDs: A → BC, B → D. O processo de trazer esses dados para a 3FN ocorre assim: \(a\) Encontre uma chave mínima de R; \(b\) determine se R está na 3FN; e se não, decomponha-o até que esteja.

Para encontrar a chave, queremos propor algumas regras para lidar com os DFs que nos são fornecidos. Se A → BC, o atributo A define B e C, ou, dito de outra forma, B e C são funcionalmente dependentes de A. Aqui está um exemplo: Seja
> R seja FUNCIONÁRIO A seja número\_funcionário B seja nome C seja cidade D seja estado 
Se dissermos A → BCD em R, estamos dizendo que, se você souber o número do funcionário, poderá encontrar o nome, a cidade e o estado de um determinado número do funcionário na tabela R. Ao escrever FDs, estamos lidando com conjuntos de atributos. Conjuntos não têm ordem, e a duplicação de atributos em ambos os lados de uma FD não adiciona nenhuma informação. Algumas das noções sobre conjuntos são frequentemente expressas como regras de FD. Se considerarmos a FD como uma relação de conjunto entre atributos, podemos dizer que todas as seguintes são iguais a A → BCD:

+ A → DCB, A → CDB, AA → BCD, A → BBCCDDDD, AAAA → BBBCDDDD.

Na tabela EMPLOYEE, como A \(nº\_funcionário\) define os outros atributos, designamos A como chave primária. Portanto, escrever a tabela em forma abreviada fica assim: R\(A, B, C, D\), onde o A sublinhado é a chave primária. Agora, aqui estão algumas regras:

1. A regra reflexiva: A → A. Neste capítulo, propomos esta regra, que é trivialmente óbvia; ela significa simplesmente que se eu conheço A, então posso lhe dizer A. Como tratamos os atributos como conjuntos, a regra reflexiva também nos diz AA → A e A → AA. 
2. A regra de aumento: Se A → B, então AC → B. Se você receber A → B, isso significa que se você souber um valor para A, poderá encontrar um valor para B. Se A for employee\_no e B for um nome, A → B diz que se você me der um valor para employee\_no, então eu posso encontrar um nome para esse employee\_no. A regra de aumento diz que se eu aumentar o LHS \(lado esquerdo\) da expressão definidora \(A\), ainda posso encontrar corretamente o RHS \(lado direito\). Adicionar informações ao LHS realmente não faz nada para melhorar o FD. Suponha que tomemos um exemplo: employee\_no = 101 implica que o nome é Jones. Agora, se adicionarmos informações ao LHS, como employee\_no = 101, Data de Nascimento = 21 de novembro de 1958, qual é o nome? É Jones, e a informação adicionada de aniversário no LHS é supérflua. Ainda assim, a regra é válida e nos ajudará a derivar uma chave. 
3. A regra de decomposição: Se A → BCD, então A → B, A → C e A → D. \(Por favor, não confunda esta regra de decomposição de tabelas com a decomposição de tabelas para obter formas normais. Infelizmente, os nomes são os mesmos, mas o significado é sobrecarregado.\) Novamente, apelamos à intuição para entender esta regra. Se employee\_no define um nome, endereço e cidade, então é válido dizer employee\_no define um nome, employee\_no define um endereço e employee\_no define uma cidade. Se você me der um employee\_no válido, posso lhe dizer o nome, o endereço e o número de telefone de uma pessoa individualmente ou em partes. 
4. A regra da união: Se A → B e A → C, então A → BC. O inverso da regra de decomposição é a regra da união, que diz a mesma coisa que a regra de decomposição, mas de trás para frente. Por exemplo, se employee\_no define um nome e employee\_no define uma cidade, então employee\_no define um nome e uma cidade. 
5. A regra transitiva: Se A → B e B → C, então A → C. Esta regra parece ir contra a 3FN, mas para encontrar chaves em uma confusão de atributos, ela é bastante útil. Pense na regra em termos de uma tabela de employee\_no, job e jobdescriptions. Você recebe employee\_no → job. Você recebe job → jobdescription. A regra diz employee\_no → jobdescription. Dê-me um employee\_no e eu lhe direi o trabalho que essa pessoa faz, porque posso pesquisar o trabalho e então encontrar a jobdescription. 
6. A regra do subconjunto: A é um subconjunto de algum grupo de atributos F, então F → A. Por exemplo, se F = AB, então A é um subconjunto de AB e AB → A. Se AB for employee\_no e name, então, dados employee\_no e name, posso dizer name ou employee\_no.

EXEMPLO 3.1

Vamos considerar o seguinte problema: recebemos alguns dados em uma tabela: R\(A, B, C, D, E\); recebemos alguns FDs: A → BC, B → D, AC → E. O que queremos encontrar é um conjunto de atributos para definir todos os outros, uma chave para esta tabela, R. Depois de encontrarmos a chave, trabalharemos em formas normais.

Passo 1. Encontre um LHS \(lado esquerdo\) \(de um FD\) que seja uma chave mínima para R. Você sempre pode começar com a propriedade reflexiva e usar todos os atributos no LHS. ABCDE → ABCDE. ABCDE é uma chave, mas o que queremos encontrar é um subconjunto de todos os atributos para definir os outros — uma chave mínima \(se existir\). Uma boa maneira de encontrar um LHS mínimo é primeiro procurar um FD com um LHS concatenado \(se houver\). Se não houver uma chave concatenada, escolha um atributo para definir o máximo de outros atributos possível. É verdade que esta é uma escolha subjetiva, mas se você escolher incorretamente, basta tentar novamente com um LHS diferente ou aprimorado. Depois de escolher algum LHS, examinamos as regras de FD e vemos se conseguimos definir os outros atributos do nosso LHS escolhido. Neste caso, temos AC → E. Veremos se podemos mostrar AC → ABCDE e, portanto, deixar que AC seja uma chave mínima do R original. Observe que começamos com o maior LHS concatenado porque precisaremos de pelo menos AC para definir o que for funcionalmente dependente dele.

Passo 2. Use as regras para encontrar o máximo possível de atributos RHS com o candidato LHS. Como AC → E, sabemos pela regra reflexiva que AC → AC; e então, pela regra da união, combinamos estes dois:

+ Regra da união: AC → E \(dado\), AC → AC \(reflexivo\), então AC → ACE.

Use os outros FDs fornecidos para encontrar outros atributos que dependem do LHS escolhido na etapa 1.

Estabelecemos que AC → ACE. Nos foi dado A → BC.

+ Regra do subconjunto: AC → ACE \(derivada anteriormente\), então AC → A. 
+ Regra transitiva: AC → A, A → BC \(dado\), então AC → BC. 
+ Regra da união: AC → ACE, AC → BC, então AC → ACEBC, e como estamos lidando com conjuntos de atributos, AC → ABCE.

Etapa 3. Repita a etapa 2 conforme necessário para obter todos os atributos do RHS do LHS escolhido, se possível.

Temos todos os atributos no RHS, exceto D. O outro FD que nos é dado é B → D. Usando a mesma linha de pensamento, estabelecemos AC → ABCE:

+ Regra do subconjunto: AC → ABCE, então AC → B. 
+ Regra transitiva: AC → B, B → D \(dado\), então AC → D. 
+ Regra da união: AC → ABCE, AC → D, então AC → ABCDE.

O processo de usar regras de FD para encontrar uma chave mínima não é um algoritmo exato. Algumas pessoas verão primeiro uma regra transitiva, depois uma regra de união; outras verão primeiro as regras de decomposição. A ordem de aplicação das regras não é tão importante quanto definir claramente um caminho válido de um LHS para definir todos os atributos \(ABCDE → ABCDE\) até alguma chave mínima \(aqui, AC → ABCDE\).

Como nosso LHS define todos os outros atributos, temos uma chave mínima AC. Agora, a pergunta: isso está na 1ª FN, 2ª FN ou 3ª FN? Nenhum grupo repetido foi indicado; portanto, temos a 1ª FN com R\(A, C, B, D, E\). A melhor tática aqui é remover as dependências transitivas primeiro. Temos B → D, então podemos decompor R da seguinte forma:
> R \(A, C, B, D, E\) se torna R1 \(A, C, B, E\) e R2 \(B, D\). 
Quando todas as FDs transitivas tiverem sido removidas, procure por dependências parciais. Embora AC seja a chave de R, temos uma FD: A → BC \(uma dependência parcial\) porque R1 tem AC → BE.
> R1 \(A, C, B, E\) se decompõe em R3 \(A, B, C\) e R4 \(A, C, E\) 
A versão final do banco de dados é
> R2 \(B, D\)R3 \(A, B, C\)R4 \(A, C, E\) 
Sugerimos que a melhor técnica de decomposição seria remover primeiro as dependências transitivas. A decomposição poderia ser feita removendo primeiro as dependências parciais, mas o FD com a dependência transitiva precisa ser mantido com seu LHS. Considere o seguinte:

+ R \(A, C, B, D, E\) se torna R1 \(A, B, C\) \(dependência parcial removida\) e R2 \(A, C, D, E\). Mas agora há um problema. Você ainda tem B → D, e não tem B e D juntos em R1 ou R2.

Você tem que manter B e D juntos e, portanto, decompor assim:

+ R \(A, C, B, D, E\) se torna R3 \(A, B, C, D\) e R4 \(A, C, E\) e então lida com a dependência transitiva. 
+ R3 \(A, B, C, D\) se decompõe em R5 \(A, B, C\) e R6 \(B, D\).

A versão final é
> R4 \(A, C, E\) R5 \(A, B, C\) R6 \(B, D\) 
Independentemente de como a decomposição é feita, o resultado final precisa ser verificado para ver se todos os FDs ainda estão lá. Se sim, então você deve ter um banco de dados 3FN.

EXEMPLO 3.2

Vamos dar mais um exemplo de decomposição e escolha de chave um pouco menos simples. Suponha que temos R \(A, B, C, D, E, F\) e AB → CD e B → E. Sua primeira missão é encontrar uma chave mínima para R. Da discussão anterior, sugerimos que você escolha o maior LHS de um determinado FD e, em seguida, veja se consegue usar as regras para mostrar que ele é uma chave. Aqui, você escolheria AB para começar e, em seguida, veria se consegue mostrar AB → ABCDEF. Usando nossas regras, podemos mostrar:

1. AB → AB \(regra reflexiva\) 
2. AB → CD \(dado\) 
3. AB → ABCD \(regra da união de 1 e 2\) 
4. AB → B \(regra do subconjunto\) 
5. B → E \(dado\) 
6. AB → E \(regra transitiva em 4 e 5\) 
7. AB → ABCDE \(regra de união em 3 e 6\)

E quanto ao F? Você já deve ter percebido que isso é um problema. No entanto, ao analisar as FDs fornecidas, você verá que o F não aparece nem no LHS nem no RHS. Você pode ver que a escolha de AB como chave inicial foi boa, mas não completa. Para resolver isso, você pode fazer o seguinte:

+ 8. ABF → ABCDE \(regra de aumento e 7\) 
+ 9. ABF → F \(regra do subconjunto\) 
+ 10. ABF → ABCDEF \(regra da união de 8 e 9\).

Esta última discussão e exemplo sugerem duas coisas: \(a\) nosso algoritmo básico de "começar com a maior chave concatenada como LHS" é bom, mas a regra de aumento nos permite incluir atributos no LHS conforme necessário para chegar a uma chave mínima; e \(b\) você pode derivar novas regras de FD. Nosso uso das regras nas etapas 8, 9 e 10 sugere que podemos propor esta regra:

+ vii. A regra do duplo aumento: você recebe ou derivou AB → C, depois ABD → CD. Você pode adicionar um atributo tanto ao lado esquerdo quanto ao lado direito ao mesmo tempo, como fizemos para ir do passo 7 ao passo 10.

Existem muitas teorias e algoritmos sobre como decompor e escolher chaves mínimas. Por exemplo, para encontrar uma chave mínima, existem algoritmos propostos que começam com todos os atributos → todos os atributos e, em seguida, removem os atributos do LHS — uma abordagem de cima para baixo. Em termos de decomposição, parece mais fácil lidar primeiro com dependências transitivas. Apresentamos o que consideramos uma abordagem prática e viável para passar de um conjunto de atributos embaralhados para a 3FN. Aqui está o resumo da abordagem que ilustramos:
> Encontre a chave mínima \(CM\): MK1. Agrupe todos os atributos em uma tabela R e escolha a maior FD do LHS como a chave mínima K. MK2. Use as regras de FD para descobrir se K pode de fato definir todos os atributos em R. MK3. Se K não puder definir todos os atributos, então aumente K com outro atributo "bem escolhido" e retorne à etapa MK2 com K agora K' \(K mais algum outro atributo\). Com a prática, o atributo bem escolhido será algum atributo do conjunto original que definirá quaisquer outros atributos ausentes na etapa MK2. > Decompor \(D\): D1. Remover todas as dependências transitivas para uma tabela separada. D2. Remover todas as dependências parciais para uma tabela separada. 
Verifique se o produto final ainda retém todos os FDs fornecidos.

Ponto de verificação 3.6

Para cada um dos seguintes, encontre uma chave mínima e decomponha conforme necessário para chegar à 3FN. Mostre tabelas decompostas com chaves.

1. R\(A, B, C, D, E, F\) e A → BCDEF 
2. R\(A, B, C, D\) e AB → CD, C → D 
3. R\(A, B, C, D\) e AB → D, B →C 
4. R\(A, B, C, D, E\) e ABC → D, D → E 
5. R\(A, B, C, D, E\) e AB → C, B → D, D →E 
6. R\(A, B, C, D\) e ABD → C 
7. R\(A, B,\{C\}\) e A→B e A→>C \(A tem múltiplas ocorrências de C\) 
8. R\(A, B, C, D, E\) e C → ABDE



## 3.10 A FORMA NORMAL DE BOYCE-CODD

Sugerimos que todos os bancos de dados sejam colocados na 3NF. Quando todas as tabelas estão na 3NF, é provável que não haja redundância nem anomalias. Há uma situação para a qual a 3NF pode não ser "boa o suficiente". Colocamos isso por último no capítulo porque é um tanto incomum, mas possível, e os projetistas de bancos de dados devem estar cientes disso. Alguns autores sugerem que esta é uma "forma mais forte do que a 3NF", mas ainda há uma dificuldade com tabelas normalizadas para a forma normal de Boyce-Codd \(BCNF\), como discutiremos. Aqui está o problema:

Suponha que você tenha uma tabela com três atributos, R\(A, B, C\). Suponha ainda AB → C, mas adicione a FD, C → B. A tabela com sua chave primária seria R\(A, B, C\); ela está na 3FN porque não há dependências parciais nem dependências transitivas do tipo D → E, E → F. Mas ainda há um pequeno problema. Existe aquela FD transitiva ímpar, C → B; portanto, haverá redundância e anomalias.

Aqui está um exemplo desta situação: Suponha que temos um estádio local onde há crianças que praticam esportes. Algumas crianças jogam por mais de um time. Cada time pode ter vários treinadores, e um jogador recebe um treinador em cada time. Temos um banco de dados de jogadores, times e treinadores, e omitimos alguns detalhes sobre jogadores, times e treinadores para simplificar.

Então, temos uma tabela PARK: PARK \(jogador, time, treinador\), conforme mostrado na Tabela 3.27.
TABELA 3.27 Dados de amostra para a tabela PARK.   **jogador**  **equipe**  **treinador**     `Walsh`  `Tigers`  `Adams`    `Smith`  `Pirates`  `Baker`    `Walsh`  `Spiders`  `Davis`    `Smith`  `Tigers`  `Edwards`    `Philips`  `Pirates`  `Baker`      
+ jogador, time → técnico. Observe que jogador não → time, time não → técnico \(veja os dados para refutar essas declarações falsas\). Por outro lado, técnico → time. Embora esses dados estejam na 3FN, você tem redundância porque técnico → time.

A normalização para BCNF nega quaisquer dependências transitivas e funciona assim:

+ R\(A, B, C\), com FDs AB → C, C → B podem ser normalizados em R1\(C, B\) e R2\(A, C\). O problema é que um dos FDs desapareceu \(AB → C\), assim como as anomalias. O exemplo de estádio normalizado para BCNF se parece com as Tabelas 3.28 e 3.29. TABELA 3.28 Dados de exemplo para a tabela PC. playercoach`Walsh``Adams``Smith``Baker``Walsh``Davis``Smith``Edwards``Philips``Baker` TABELA 3.29 Dados de exemplo para a tabela CT. equipe de treinadores`Adams``Tigers``Baker``Pirates``Davis``Spiders``Edwards``Tigers` 
+ PC \(jogador, treinador\) e CT \(treinador, equipe\)



Na tabela PC, ambos os atributos são uma chave concatenada \(jogador, treinador → jogador, treinador\). Como não pode haver dependências parciais ou transitivas, PC está na 3NF e BCNF. CT também está na 3NF e BCNF \(treinador → time\). O problema de decomposição é que perdemos o FD: jogador, time → treinador. A tabela original pode ser reconstruída com uma operação de junção equivalente unindo PC e CT no treinador, mas a versão BCNF permite atualizações sem redundância, enquanto a tabela PARK original não. Considere adicionar um treinador à tabela PARK original; isso só pode ser feito se um jogador for atribuído, ou então haveria um nulo na chave. Na versão BCNF, um treinador pode ser adicionado a CT sem nenhum jogador atribuído. As outras anomalias serão deixadas como exercícios.

A BCNF é um pouco mais complexa que a 1NF, 2NF e 3NF. Nas três primeiras formas normais, não há problema em se a decomposição é uma "boa ideia". Todos os bancos de dados devem ser reduzidos a pelo menos 3NF. A BCNF apresenta um dilema. O que é mais irritante para quem usa o banco de dados? A perda de uma FD é pior do que algumas anomalias? Em uma situação sem BCNF, se a ocorrência de redundância que produz anomalias for baixa, pode ser melhor deixar as tabelas como estão — em 3NF, mas não em BCNF. Se a redundância for generalizada, a normalização para BCNF pode ser necessária. Uma opção nunca aceitável é manter ambas as versões, pois isso representa redundância total.





## 3.11 RESUMO DO CAPÍTULO

Este capítulo teve como objetivo apresentar o banco de dados relacional. Tabelas relacionais são conjuntos de linhas. Como conjuntos, as linhas não têm uma ordem implícita entre si e, em uma tabela correta, não há linhas duplicadas. As formas normais são apresentadas, juntamente com \(a\) por que as formas normais são desejáveis; \(b\) por que tabelas não normalizadas geram anomalias; e \(c\) como migrar de tabelas não normalizadas para tabelas de forma normal.

Anomalias são operações anormais de manutenção de tabelas \(excluir, inserir e atualizar\) que ocorrem devido à redundância e ao design incorreto da tabela. A operação equijoin foi introduzida para mostrar como tabelas decompostas podem ser reconstruídas. Um cálculo de FD foi introduzido para mostrar como determinar chaves e decomposições em um agregado de dados. Por fim, o BCNF foi abordado. A decomposição de tabelas não BCNF remove redundâncias e anomalias, mas oculta FDs.





## CAPÍTULO 3 EXERCÍCIOS



### Exercício 3.1

+ Se X → Y, você consegue dizer Y → X? Por quê? Ou por que não?



### Exercício 3.2

Decomponha os seguintes dados em tabelas 1NF:

+ Khanna, 123 4th St., Columbus, Ohio \{Universidade de Delhi, Universidade de Calcutá, estado de Ohio\} 
+ Ray, 4 Moose Lane, Pensacola, Flórida \{Universidade da Zâmbia, Universidade da Flórida Ocidental\} 
+ Ali, 88 Tiger Circle, Gulf Breeze, Flórida \{Universidade do Sul do Alabama, Universidade da Flórida Ocidental\} 
+ Sahni, 283 Penny Street, North Canton, Ohio \{Wooster College, Mount Union College\}



### Exercício 3.3

Considere os dados da Tabela 3.30.
TABELA 3.30 Exercício 3.3 Tabela.   **nome**  **endereço**  **cidade**  **estado**  **carro**  **cor**  **ano**     `Smith`  `123 4th St`  `Pensacola`  `FL`  `Mazda`  `Blue`  `2019`    `Smith`  `123 4th St`  `Pensacola`  `FL`  `Nissan`  `Red`  `2018`    `Jones`  `4 Moose Lane`  `Santa Clive`  `CA`  `Lexus`  `Red`  `2019`    `Katie`  `5 Rain Circle`  `Fort Walton`  `FL`  `Taurus`  `White`  `2019`     
e os seguintes FDs:
> nome → endereço, cidade, estado, carro, cor, ano e carro → cor, ano 
Decomponha conforme necessário para atingir 3NF.



## BIBLIOGRAFIA

+ Armstrong, W. \(5 a 10 de agosto de 1974\). Estruturas de dependência de relacionamentos em bancos de dados. Anais do Congresso do IFIP. Estocolmo, Suécia. 
+ Bagui, S., e Earp, R. \(2011\). Fundamentos de SQL usando o SQL Server 2008. Burlington, MA: Jones e Bartlett. 
+ Chen, P.P. \(1976\). O modelo entidade-relacionamento — em direção a uma visão unificada dos dados. ACM Transactions on Database Systems, 1\(1\), 9–36. 
+ Codd, E. \(1970\). Um modelo relacional para grandes bancos de dados compartilhados. Comunicações da ACM, 13\(6\), 377–387. 
+ Codd, E. \(1972\). Normalização Adicional do Modelo Relacional de Banco de Dados. Republicado em Randall J. Rustin \(org.\), Sistemas de Banco de Dados: Courant Computer Science Symposia Series 6. Hoboken, NJ: Prentice-Hall. 
+ Codd, E. \(5 a 10 de agosto de 1974\). Investigações recentes em sistemas de banco de dados relacionais. Anais do Congresso do IFIP. Estocolmo, Suécia. 
+ Date, C. \(2003\). Uma Introdução aos Sistemas de Banco de Dados. Reading, MA: Addison-Wesley. 
+ Earp, R., e Bagui, S. \(2021\). Um Guia Prático para Usar SQL no Oracle, 3ª ed. Redding, CA: BVT Publishing. 
+ Elmasri, R., e Navathe, S.B. \(2016\). Fundamentos de Sistemas de Banco de Dados. Reading, MA: Addison-Wesley. 
+ Maier, D. \(1983\). A Teoria dos Bancos de Dados Relacionais. Nova Iorque, NY. Computer Science Press. 
+ Norman, R.J. \(1996\). Análise e Projeto de Sistemas Orientados a Objetos. Upper Saddle River, NJ: Prentice Hall. 
+ Schach, S.R. \(2011\). Engenharia de Software Clássica e Orientada a Objetos. Nova York, NY: McGraw-Hill.





# 4 O Diagrama ER Básico: Um Esquema de Modelagem de Dados



DOI: 10.1201/9781003314455-4



## 4.1 INTRODUÇÃO

Este capítulo começa descrevendo uma abordagem de modelagem de dados e, em seguida, apresenta diagramas de entidade-relacionamento \(ER\). Os conceitos de entidades, atributos, relacionamentos e chaves são introduzidos. As três primeiras etapas de uma metodologia de projeto de ER são desenvolvidas. A Etapa 1 começa com a construção de um diagrama de entidade única. A Etapa 2 concentra-se no uso do inglês estruturado para descrever um banco de dados. A Etapa 3, a última seção deste capítulo, discute o mapeamento do diagrama ER para um banco de dados relacional. Esses conceitos — diagrama, inglês estruturado e mapeamento — evoluem juntos à medida que o livro avança. Ao final deste capítulo, também iniciamos um estudo de caso em andamento, que continua nos capítulos seguintes.



## 4.2 O QUE É UM ESQUEMA DE MODELAGEM DE DADOS?

Um esquema de modelagem de dados é um método que nos permite modelar ou ilustrar um banco de dados. Geralmente, ele se apresenta na forma de um diagrama gráfico, mas outros meios de comunicação também são desejáveis. Quem não trabalha com computação pode não estar familiarizado com diagramas e gráficos. O diagrama ER é uma ferramenta gráfica para facilitar a modelagem de dados. Os diagramas ER são um subconjunto de "modelos semânticos" no jargão de banco de dados. Modelos semânticos referem-se a modelos que visam extrair significado de arranjos de dados. Os diagramas ER não são as únicas ferramentas de modelagem semântica, mas são comuns e populares.

Quando discutimos o conteúdo de um banco de dados, o modelo de dados nos ajuda a decidir qual dado combina com qual\(is\) outro\(s\) dado\(s\) em um nível conceitual. Um conceito inicial sobre o assunto de banco de dados é reconhecer que existem níveis de abstração que podemos usar ao discutir bancos de dados. Por exemplo, se discutíssemos o registro de "nomes", poderíamos discutir:

1. Em resumo, “arquivaremos os nomes das pessoas que conhecemos”. 
2. Concretamente, “Arquivaremos o primeiro, o segundo e o último nome \(20 caracteres cada\) de pessoas que conhecemos, para que possamos recuperar os nomes em ordem alfabética pelo sobrenome; e colocaremos esses dados em formato de planilha no pacote x.”

Se alguém estiver projetando um banco de dados, o primeiro passo é abstrair e, em seguida, refinar a abstração. Quanto mais tempo se mantiver afastado dos detalhes concretos dos modelos lógicos \(relacionais, hierárquicos, de rede\) e das realizações físicas \(campos \[quantos caracteres, o tipo de dado, ...\] e arquivos \[relativos, planilha, ...\]\), mais fácil será alterar o modelo e decidir como os dados serão eventualmente realizados fisicamente \(armazenados\). Quando usamos o termo campo ou arquivo, estamos nos referindo a dados físicos, e não a dados conceituais.

Mapeamento é o processo de escolher um modelo lógico e, em seguida, migrar para um sistema de arquivos de banco de dados físico a partir de um modelo conceitual \(o diagrama ER\). Um arquivo físico carregado com dados é necessário para obter dados de um banco de dados. O mapeamento é a ponte entre o conceito de design e a realidade física. Neste livro, focamos no modelo de banco de dados relacional, em que o software de banco de dados nos permite praticamente ignorar como os dados são armazenados fisicamente.



### 4.2.1 O que é um diagrama de entidade-relacionamento?

O diagrama ER é uma ferramenta de modelagem semântica de dados usada para atingir o objetivo de descrever ou retratar dados de forma abstrata. Dados descritos de forma abstrata são chamados de modelo conceitual. Nosso modelo conceitual nos levará a um "esquema". Um esquema implica uma descrição permanente e fixa da estrutura dos dados. Portanto, quando concordamos que capturamos a representação correta da realidade em nosso modelo conceitual, nosso diagrama ER, podemos chamá-lo de esquema.

Um diagrama ER também pode ser usado para documentar um banco de dados existente por meio de engenharia reversa. Ao introduzir o assunto, focamos na ideia de usar um diagrama ER para modelar um banco de dados a ser criado e, posteriormente, abordaremos a engenharia reversa.



## 4.3 DEFININDO UM BANCO DE DADOS — ALGUMAS DEFINIÇÕES: ENTIDADE, RELACIONAMENTO E ATRIBUTO

Como o nome indica, um diagrama entidade-relacionamento modela dados como entidades e relacionamentos. Uma entidade é algo sobre o qual armazenamos dados \(por exemplo, uma pessoa, uma conta bancária, um edifício\). Na apresentação original, Chen \(1976\) descreveu uma entidade como algo "que pode ser distintamente identificado". Uma entidade pode ser uma pessoa, um lugar, um objeto, um evento ou um conceito sobre o qual desejamos armazenar dados. Um relacionamento é uma conexão entre entidades. Um atributo é o nome dos dados contidos em uma entidade ou relacionamento.

Uma entidade representa um tipo ou classe de algo e deve ser nomeada de acordo. A seguir, alguns exemplos de entidades:

+ Exemplos de uma entidade pessoa seriam FUNCIONÁRIO, VETERANO ou ESTUDANTE. 
+ Exemplos de uma entidade de lugar seriam ESTADO ou PAÍS. 
+ Exemplos de uma entidade de objeto seriam BUILDING, AUTO ou PRODUCT. 
+ Exemplos de uma entidade de evento seriam VENDAS, DEVOLUÇÕES ou REGISTRO. 
+ Exemplos de uma entidade conceitual seriam CONTA ou DEPARTAMENTO.

O nome de uma entidade deve ser genérico. O nome deve ser capaz de acomodar mudanças "ao longo do tempo". Por exemplo, se estivéssemos modelando um negócio de donuts, poderíamos considerar a criação de uma entidade chamada DONUT. Mas quanto tempo levará até que esse negócio evolua para a fabricação de doces mais genéricos? Se for previsto que o negócio envolverá doces de todos os tipos, em vez de apenas donuts, talvez seja melhor criar uma entidade chamada PASTRY, que pode ser mais aplicável ao longo do tempo. Nesse caso, a entidade "negócio" é muito genérica porque você deseja registrar dados sobre donuts ou doces — componentes do negócio.

Em círculos mais antigos de processamento de dados, teríamos nos referido a uma entidade como um "registro", mas o termo registro é muito físico e muito restritivo. "Registro" nos dá uma imagem mental de algo físico e, para trabalhar no nível conceitual, queremos evitar termos orientados a dispositivos. Em um contexto de banco de dados, é incomum armazenar informações sobre uma entidade, então pensamos em armazenar coleções de dados sobre entidades; tais coleções são chamadas de conjuntos de entidades. Conjuntos de entidades correspondem ao conceito mais antigo de "um conjunto de arquivos", mas "conjuntos de arquivos" geralmente implicam coisas físicas e, portanto, abstraímos o conceito de conjunto de arquivos \(conjunto de entidades\), bem como o conceito de registro \(entidade\). Como exemplo, suponha que temos uma empresa com clientes. Você imaginaria que a empresa tinha um conjunto de entidades de clientes com entidades de clientes individuais nele.

Uma entidade pode ser muito ampla \(por exemplo, uma PESSOA\) ou pode ser limitada pela aplicação para a qual os dados estão sendo preparados \(um ALUNO ou um CLIENTE\). Entidades "ampla", que abrangem uma classe inteira de objetos, às vezes são chamadas de generalizações \(por exemplo, PESSOA\), e entidades "mais restritas", às vezes são chamadas de especializações \(por exemplo, ALUNO\). Em diagramas posteriores \(neste livro\), revisitamos generalizações e especializações, mas, por enquanto, nos concentramos em um nível de aplicação no qual não há subgrupos \(especializações\) ou supergrupos \(generalizações\) de entidades.

Quando falamos em capturar dados sobre uma entidade específica, nos referimos a isso como uma instância. Uma instância de entidade é uma ocorrência única de uma entidade. Por exemplo, se criarmos uma entidade chamada TOOL e escolhermos registrar dados sobre uma chave de fenda, o "registro" da chave de fenda será uma instância de TOOL. Cada instância de uma entidade deve ser identificável de forma única, para que cada instância seja separada e distintamente identificável de todas as outras instâncias daquele tipo de entidade. Em um conjunto de entidades de clientes, você pode imaginar que a empresa atribuiria um número de cliente exclusivo, por exemplo. Esse identificador exclusivo é chamado de chave.

Um relacionamento é um elo ou associação entre entidades. Relacionamentos geralmente são denotados por locuções verbais. Começamos expandindo a noção de entidade \(neste capítulo e no próximo\) e, em seguida, retornamos à noção de relacionamento \(no Capítulo 6\) quando nos sentirmos confortáveis com o conceito de entidade.

Um atributo é uma propriedade ou característica de uma entidade. Por exemplo, uma entidade, AUTOMÓVEL, tem os atributos tipo, cor, ID\_do\_veículo e assim por diante.



### 4.3.1 Uma Metodologia Inicial

A modelagem de banco de dados começa com uma descrição do "que deve ser armazenado". Essa descrição normalmente é obtida do "usuário". Por exemplo, a Sra. Smith, da Acme Parts Company, pede que você projete um banco de dados de peças para a empresa dela. A Sra. Smith é a usuária. Você é o projetista do banco de dados. O que a Sra. Smith lhe disser sobre as peças que a empresa vende, fabrica ou compra fará parte da descrição do banco de dados.

Como ponto de partida para lidar com um banco de dados a ser criado, identificamos uma entidade "primária" central — uma categoria sobre a qual armazenaremos dados. Por exemplo, se quiséssemos criar um banco de dados sobre alunos e seu ambiente, uma entidade seria ALUNO. \(Nossa caracterização de uma entidade será sempre no singular.\) Tendo escolhido uma primeira entidade primária, ALUNO, buscamos informações \(atributos\) a serem registradas sobre nosso ALUNO. Essa metodologia de selecionar uma entidade primária a partir de uma descrição de dados é nosso primeiro passo para desenhar um diagrama ER e, portanto, o início da fase de requisitos da engenharia de software para nosso banco de dados.

Após a escolha da entidade primária, perguntamos quais informações queremos registrar sobre ela. Em nosso exemplo, ALUNO, adicionamos alguns detalhes sobre o ALUNO — detalhes para qualificar, identificar, classificar ou expressar o estado da entidade \(neste caso, a entidade ALUNO\). Esses detalhes ou conteúdos das entidades são chamados de atributos. 1 Alguns exemplos de atributos de ALUNO seriam informações sobre o aluno — nome, número do aluno, curso, endereço e assim por diante. Nesse processo de seleção de atributos, o usuário deve ser capaz de informar quais dados devem ser armazenados.



### 4.3.2 Metodologia de Projeto ER

+  ** *Etapa 1. Selecione uma entidade primária na descrição dos requisitos do banco de dados e mostre os atributos a serem registrados para essa entidade.***  

A definição de requisitos é a primeira fase da engenharia de software, na qual o analista de sistemas tenta descobrir o que o usuário deseja. Agora, tendo escolhido uma entidade primária e alguns atributos, a tarefa será:

1. Desenhe um diagrama da nossa primeira entidade de impressão \(nossa entidade primária\). 
2. Traduza o diagrama para o inglês. 
3. Apresente o inglês \(e o diagrama\) de volta ao usuário para verificar se o designer do banco de dados e o usuário se entendem. Em caso afirmativo, prosseguimos.

A etapa c é chamada de feedback em engenharia de software. O processo de refinamento por meio de feedback é um processo normal nas fases de requisitos/especificação. O ciclo de feedback é essencial para chegar à realidade do que se deseja representar, tanto do ponto de vista do usuário quanto do analista. Primeiro, mostramos como desenhar a entidade e, em seguida, apresentamos diretrizes para converter nosso diagrama para o inglês.

Ponto de verificação 4.1

1. Dos seguintes itens, determine qual poderia ser uma entidade e diga o porquê: automóvel, turma da faculdade, aluno, nome do aluno, título do livro, número de dependentes. 
2. Por que entidades não são chamadas de arquivos ou registros? 
3. O que são conjuntos de entidades? 
4. Por que precisamos de diagramas de entidade-relacionamento? 
5. O que são atributos? Liste os atributos das entidades que você encontrou na pergunta 1. 
6. O que é um relacionamento?



## 4.4 UM PRIMEIRO DIAGRAMA ER “SOMENTE ENTIDADE”: UMA ENTIDADE COM ATRIBUTOS

Para recapitular nosso exemplo, escolhemos um exemplo com uma entidade primária de um banco de dados de informações de alunos: ALUNO. Novamente, "um aluno" é algo sobre o qual queremos armazenar informações \(a definição de uma entidade\). Neste capítulo, não nos ocuparemos de nenhuma outra entidade, mas sim adicioná-las em capítulos posteriores.

Vamos pensar em alguns atributos da entidade ALUNO. Ou seja, quais são alguns dos atributos que um aluno pode ter? Um aluno tem um nome, um endereço e uma conexão educacional. Chamamos essa conexão educacional de escola. Selecionamos três atributos para a entidade ALUNO e também escolhemos um rótulo genérico para cada um: nome, endereço e escola.

Começamos nossa primeira incursão em diagramas ER com um modelo "semelhante ao de Chen". Chen \(1976\) introduziu a ideia dos diagramas ER. Chen e outros aprimoraram o processo de ER ao longo dos anos. Embora não exista um modelo padrão de diagramas ER, o modelo semelhante ao de Chen e suas variantes são comuns. Após o modelo semelhante ao de Chen, consideraremos outros modelos. Discutiremos brevemente o modelo semelhante ao de Barker/Oracle no Capítulo 12. Os modelos semelhantes ao de Chen têm a vantagem de não ser necessário conhecer o modelo lógico subjacente para compreender o projeto. Os modelos de Barker e alguns outros modelos exigem uma compreensão completa do modelo relacional, e os diagramas são afetados por conceitos relacionais.

Para começar, no modelo Chen-like, faremos como Chen fez originalmente e colocaremos as entidades em caixas e mostraremos os atributos próximos. Uma maneira de representar os atributos é colocá-los em círculos ou ovais anexados às caixas \(consulte as Figuras 4.1a e 4.1b\). A Figura 4.1c é um estilo alternativo de representação de atributos. O estilo alternativo de atributos \(Figura 4.1c\) não é tão descritivo, mas é mais compacto e pode ser usado se os diagramas Chen-like ficarem desorganizados.
FIGURA 4.1A Modelo tipo Chen: Entidade com Atributos.   FIGURA 4.1B Entidade ALUNO com três atributos.   FIGURA 4.1C Modelo ER alternativo. 
Ilustramos o modelo de um "atributo em forma oval" \(modelo semelhante ao de Chen\) por ser comum e útil. Consulte as Figuras 4.2A, 4.2B e 4.2C para mais modelos alternativos de atributos. Há benefícios em formas alternativas para representar atributos. A forma padrão do modelo semelhante ao de Chen, com ovais e caixas, é boa para conceituar; é facilmente alterável e muito clara quanto a qual atributo deve ser colocado onde. As formas concisas \(Figura 4.1C e outras variantes mostradas nas Figuras 4.2A, 4.2B e 4.2C\) são facilmente criadas a partir da forma padrão e, às vezes, são mais úteis para documentação quando há problemas de espaço.
FIGURA 4.2A Segundo modelo alternativo para o diagrama ER.   FIGURA 4.2B Terceiro modelo alternativo para o diagrama ER.   FIGURA 4.2C Quarto modelo alternativo para o diagrama ER. 


As Figuras 4.1B e 4.1C mostram um diagrama ER com uma entidade, ALUNO, e três atributos: nome, endereço e escola. Se mais atributos fossem adicionados ao nosso modelo conceitual, como telefone e curso, eles seriam anexados à entidade \(ALUNO é a única entidade que temos até o momento\), como pode ser visto na Figura 4.3.
FIGURA 4.3 A entidade ALUNO com cinco atributos.   


## 4.5 MAIS SOBRE ATRIBUTOS

Atributos são características de entidades que fornecem detalhes descritivos sobre elas. Existem vários tipos diferentes de atributos: simples ou atômicos, compostos, multivalorados e derivados. As propriedades de um atributo são seu nome, descrição, formato e tamanho, além de sua atomicidade. Alguns atributos podem ser considerados identificadores únicos de uma entidade. Nesta seção, também introduzimos a ideia de um atributo-chave, um identificador único para uma entidade.



### 4.5.1 O Atributo Simples ou Atômico

Atributos simples ou atômicos não podem ser decompostos ou subdivididos — daí o conceito de "atômico". Pode-se examinar o domínio de valores 2 de um atributo para determinar se ele é simples ou não. Um exemplo de atributo simples ou atômico seria o número do Seguro Social; espera-se que uma pessoa tenha apenas um número de Seguro Social indivisível.

Outros testes para determinar se um atributo é simples ou atômico dependerão inteiramente das circunstâncias encontradas pelo projetista do banco de dados, bem como do desejo do usuário para o qual o banco de dados está sendo construído. Por exemplo, um atributo de número de telefone poderia ser tratado como um número simples de nove dígitos em um projeto de banco de dados específico, mas em outro cenário, poderíamos querer dividir o número de telefone em duas partes distintas: o DDD e o número de sete dígitos.

Outro exemplo de quando o uso do atributo no banco de dados determinará se o atributo é simples ou atômico é um atributo de data de nascimento. Se estivermos configurando um banco de dados para um hospital veterinário, pode fazer sentido dividir um campo de data de nascimento em mês, dia e ano, pois fará diferença no tratamento se um animal jovem tiver 5 dias de idade em comparação com 5 meses ou 5 anos. Portanto, neste caso, a data de nascimento seria um atributo composto. Para um banco de dados de CAVALOS DE CORRIDA, como o usado por handicaps, pode não ser necessário dividir um campo de data de nascimento em mês/dia/ano, pois todos os cavalos de corrida são datados apenas pelo ano em que nasceram. Neste caso, a data de nascimento, consistindo apenas do ano, seria atômica.

Se um atributo for não atômico, ele precisa ser representado como tal no diagrama ER. As seções a seguir abordam essas ideias mais complexas de atributos não atômicos: o atributo composto e o atributo multivalorado.



### 4.5.2 O Atributo Composto

Um atributo composto, às vezes chamado de atributo de grupo, é um atributo formado pela combinação ou agregação de atributos relacionados. Os nomes escolhidos para atributos compostos devem ser descritivos e gerais. O conceito de nome é adequado para uma descrição geral, mas pode ser desejável ser mais específico sobre as partes desse atributo. A maioria dos aplicativos de processamento de dados divide o nome em partes componentes. Nesse caso, o nome é chamado de atributo composto ou agregado porque geralmente é composto por um nome, um sobrenome e uma inicial do meio — subatributos, por assim dizer. A maneira como os atributos compostos são mostrados em diagramas ER no modelo do tipo Chen é ilustrada na Figura 4.4. Os subatributos, como nome, nome do meio e sobrenome, são chamados de atributos simples, atômicos ou elementares. A palavra agregado é usada em um sentido diferente em algumas linguagens de consulta a banco de dados — e para evitar confusão, não chamamos atributos compostos de agregados; usamos a palavra composto.
FIGURA 4.4 Entidade ALUNO com um Atributo Composto — Nome. 
O teste para determinar se um atributo será composto \(ou não\) dependerá inteiramente das circunstâncias encontradas pelo projetista do banco de dados — o desejo do usuário que solicita o banco de dados. Por exemplo, em um banco de dados, pode não ser importante saber exatamente de qual cidade, estado ou CEP uma PESSOA vem; portanto, um atributo de endereço nesse banco de dados pode não ser decomposto em suas partes componentes; ele pode ser simplesmente chamado de endereço. Em outro banco de dados, pode ser importante saber de qual cidade e estado uma PESSOA vem; portanto, neste segundo banco de dados, teríamos que decompor o atributo de endereço em endereço, cidade, estado e CEP, tornando o atributo de endereço um atributo composto.



### 4.5.3 O Atributo Multivalorado

Outro tipo de atributo não simples a ser gerenciado é chamado de atributo multivalorado. O atributo multivalorado, como o nome indica, pode assumir mais de um valor para uma determinada ocorrência de uma entidade. Por exemplo, o atributo "escola" pode facilmente ser multivalorado se uma pessoa frequenta \(ou frequentou, dependendo do contexto do banco de dados\) mais de uma escola. Como contraexemplo, a maioria das pessoas usa apenas um nome; portanto, o nome não é multivalorado.

O atributo multivalorado chamado escola é representado na Figura 4.5A \(modelo semelhante a Chen\) como uma oval dupla; isso ilustra a situação para a qual um banco de dados armazenará dados sobre alunos que podem ter frequentado mais de uma escola. Embora tenhamos escolhido ilustrar a escola como um atributo multivalorado, não queremos dizer que isso sempre será o caso em todos os bancos de dados. De fato, o atributo escola pode muito bem ter valor único em alguns bancos de dados. A ideia de escola pode significar a escola atual \(ou apenas a anterior\) em oposição a todas as escolas frequentadas. Se os indivíduos sobre os quais estamos armazenando dados podem frequentar apenas uma escola por vez \(e é isso que queremos representar\), então o atributo escola pode muito bem ser um atributo de valor único.
FIGURA 4.5A Entidade STUDENT com um atributo multivalorado. 
Novamente, o teste de valor único versus valor múltiplo dependerá inteiramente das circunstâncias encontradas pelo projetista do banco de dados — o desejo do usuário do banco de dados a ser construído. Recomenda-se que, se o significado do banco de dados for que o atributo "escola" significa "escola atual", o atributo seja chamado de "escola atual" e ilustrado como um atributo de valor único. Mostramos um atributo de valor múltiplo na Figura 4.5A. Este diagrama implica que várias escolas podem ser registradas para cada aluno.



### 4.5.4 O Atributo Derivado

Atributos derivados são aqueles que o usuário pode visualizar, mas que não podem ser registrados por si só. Esses atributos derivados podem ser calculados a partir de outros dados no banco de dados. Um exemplo de atributo derivado seria a idade, que pode ser calculada após o armazenamento da data de nascimento. No modelo do tipo Chen, um atributo derivado é mostrado em uma oval tracejada \(Figura 4.5B\).
FIGURA 4.5B Entidade ALUNO com um Atributo Derivado: Idade.   


### 4.5.5 Chaves

Um banco de dados é usado para armazenar dados para recuperação. Um atributo usado para encontrar a ocorrência de uma entidade específica é chamado de chave. Ao modelar nosso banco de dados com os modelos ER, podemos descobrir que alguns atributos parecem naturalmente ser chaves.

Se um atributo puder ser considerado um identificador único para uma entidade, ele é chamado de chave candidata. Quando uma chave candidata é escolhida para ser o identificador único, ela se torna a chave primária da entidade.

Como exemplo de chaves, suponha que adicionemos um atributo chamado student\_number ao nosso exemplo de entidade STUDENT. Podemos muito bem considerar student\_number como um identificador único para a entidade — uma chave candidata devido à sua exclusividade. Um nome geralmente é único, mas não necessariamente. Membros da mesma turma frequentemente compartilham sobrenomes. O endereço pode ou não ser um identificador único e, portanto, não é uma chave candidata provável. Irmãos que estudam juntos podem facilmente ter o mesmo endereço. As escolas frequentemente optam por atribuir um número de aluno exclusivo a cada aluno para poder encontrar os registros dos alunos. A ideia de uma chave é fornecer uma maneira única de encontrar uma instância de entidade \(um registro específico\).

Algumas escolas também optam por registrar um número de Seguro Social \(SSN\) como atributo. Um SSN também é único e, portanto, uma chave candidata, juntamente com o número\_de\_aluno. Se tanto o SSN quanto o número\_de\_aluno fossem registrados, o designer teria que escolher qual chave candidata seria a chave primária. No nosso caso, optamos por não registrar um SSN. A entidade ALUNO com o identificador único número\_de\_aluno, adicionado como chave, é ilustrada na Figura 4.6.
FIGURA 4.6 Entidade ALUNO com um atributo de chave primária ou identificador exclusivo. 
No modelo ER do tipo Chen, identificadores únicos \(chaves candidatas\) são geralmente sublinhados \(como mostrado na Figura 4.6\). Um identificador único pode ser um atributo ou uma combinação de atributos. Não é necessário escolher qual chave candidata será a chave primária neste ponto, mas pode-se fazê-lo. Quando há apenas uma chave candidata, geralmente a chamaremos de chave primária, simplesmente porque é óbvio que a chave primária é uma chave candidata. Na Figura 4.6, também descrevemos uma forma resumida do diagrama ER \(na parte inferior da figura\) com atributos compostos e atributos multivalorados, bem como chaves primárias. Os atributos compostos são listados com suas partes componentes, e os atributos multivalorados são colocados entre parênteses na forma abreviada.

Por fim, falando de chaves, teremos situações no diagrama ER \(no modelo do tipo Chen\) para as quais nenhuma chave é óbvia ou pretendida. Entidades que possuem pelo menos uma chave identificada são chamadas de entidades fortes. No artigo original de Chen \(1976\), entidades fortes eram chamadas de entidades regulares. Algumas entidades serão descobertas dependendo de outras entidades para sua existência \(e, portanto, para sua identificação\). Chen chamou aquelas entidades que dependem de outras entidades para sua existência de entidades fracas.

Muitas vezes, podemos reconhecer essas entidades fracas porque elas podem não ter chaves candidatas, embora o significado real de uma entidade fraca seja "uma entidade que depende da outra para existir". Como fez Chen, seguimos a notação ER semelhante à de Chen e chamamos essas entidades de entidades fracas — fracas porque elas terão que depender de alguma outra entidade para fornecer um identificador exclusivo que dê à entidade um motivo para ser registrada.

Embora uma entidade fraca possa ter uma chave candidata, ela não seria uma entidade forte. Representamos entidades fracas nos diagramas ER do tipo Chen com caixas duplas \(ver Figura 4.7\). Por enquanto, nos concentraremos nas entidades que possuem chaves, as entidades fortes, e reconsideraremos situações para as quais nenhuma chave é óbvia, as entidades fracas, posteriormente.
FIGURA 4.7 Uma entidade AUTOMÓVEL forte e uma fraca.  
Ponto de verificação 4.2

1. Descreva os tipos básicos de esquemas de representação de dados usados na modelagem ER. 
2. Qual notação é usada para mostrar diagramáticamente uma entidade no modelo ER do tipo Chen? 
3. Como mostramos diagramaticamente os atributos no modelo ER do tipo Chen? 
4. Como mostramos atributos compostos no modelo ER do tipo Chen? 
5. Desenhe uma representação de entidade para a entidade EDIFÍCIO com os seguintes atributos: nome do edifício, ocupação e se ele tem ou não elevador \(sim/não\). 
6. Embeleze a entidade EDIFÍCIO para incluir o nome do síndico do prédio \(nome, nome do meio e sobrenome\). Este atributo precisa ser composto? Por quê? 
7. Enfeite a entidade BUILDING para incluir o endereço do edifício, que será a chave primária. 
8. Novamente, embeleze a entidade PRÉDIO para incluir nomes \(e somente nomes\) da equipe de zeladoria. 
9. Adicione um atributo multivalor à entidade BUILDING. 
10. Quantos atributos uma entidade pode ter?



## 4.6 DESCRIÇÃO EM INGLÊS DA ENTIDADE

Agora temos uma entidade com atributos e queremos preparar o primeiro feedback para o usuário: a descrição em inglês. Os usuários provavelmente não vão querer estudar o diagrama de entidades, mas podem querer ouvir o que você, o analista, acha que ouviu. Para uma descrição em inglês, usamos uma gramática inglesa "estruturada" e substituímos as informações apropriadas do diagrama de entidades.



### 4.6.1 O Método

O modelo para o inglês estruturado para entidades individuais é o seguinte: Seja ENTIDADE o nome da entidade e att\(j\) os atributos. A ordem dos atributos não é importante, então j = 1, 2, … é atribuído arbitrariamente, embora, uma vez escolhida uma ordem, ela não mude. Suponha que existam n atributos até o momento. O equivalente em inglês generalizado do nosso diagrama é apresentado a seguir.



#### 4.6.1.1 A Entidade

+  **Este banco de dados registra dados sobre a Entidade. Para cada ENTIDADE no banco de dados, registramos att\(1\), att\(2\), att\(3\), … att\(n\).** 



#### 4.6.1.2 Os Atributos

Para atributos atômicos, att\(j\):

+ Para cada ENTIDADE, sempre haverá um e apenas um att\(j\). O valor de att\(j\) não será subdividido.

Para atributos compostos, att\(j\):

+  **Para cada ENTIDADE, registraremos att\(j\), que é composto de x, y, z, … \(x, y, z\) são as partes componentes de att\(j\).** 

Para atributos multivalorados, att\(j\):

+  **Para cada ENTIDADE, registraremos att\(j\). Pode haver mais de um att\(j\) registrado para cada ENTIDADE.** 

Para atributos derivados, att\(j\):

+  **Para cada ENTIDADE, podem existir att\(j\)’s, que serão derivados do banco de dados.** 



#### 4.6.1.3 As Chaves

Para a\(s\) chave\(s\):

1.  
Mais de uma chave candidata \(entidade forte\):

Para cada ENTIDADE, teremos as seguintes chaves candidatas: att\(j\), att\(k\), … \(onde j, k são atributos de chaves candidatas\).

2.  
Uma chave candidata \(entidade forte\):

Para cada ENTIDADE, teremos a seguinte chave primária: att\(j\).

3.  
Nenhuma chave candidata \(entidade fraca\):

Para cada ENTIDADE, não assumimos que qualquer atributo será único o suficiente para identificar entidades individuais sem a referência correspondente à ENTIDADE proprietária \(ou seja, alguma outra entidade\).  3 

4. Nenhuma chave candidata \(entidade de intersecção\): Isso será discutido a seguir.



### 4.6.2 Metodologia de Projeto ER

+  ** *Etapa 2. Use inglês estruturado para entidades, atributos e chaves para descrever o banco de dados obtido.***  
+  ** *Etapa 3. Mostre alguns dados de exemplo.***  

Dados de amostra geralmente ajudam a descrever o banco de dados para o usuário, conforme ele é percebido pelo analista.



### 4.6.3 Exemplos

Agora, revisitamos cada uma de nossas figuras e adicionamos uma descrição em inglês a cada uma delas.



#### 4.6.3.1 Figura 4.3 Exemplo

Primeiro, reconsidere a Figura 4.3. Não há atributos multivalorados ou compostos. ENTIDADE = ALUNO, att\(1\) = nome, att\(2\) = escola e assim por diante \(j atribuído arbitrariamente\). A "tradução" em inglês do diagrama de entidades usando os modelos é discutida a seguir.



##### 4.6.3.1.1 A Entidade

Este banco de dados registra informações sobre ALUNOS. Para cada ALUNO no banco de dados, registramos um nome, uma instituição de ensino, um endereço, um número de telefone e um curso.



##### 4.6.3.1.2 Os Atributos

+ Para cada ALUNO, haverá apenas um nome. O valor de nome não será subdividido \(observe que na Figura 4.3 não dividimos nome\). 
+ Para cada ALUNO, haverá apenas uma especialização. O valor por especialização não será subdividido. 
+ Para cada ALUNO, haverá apenas um endereço. O valor do endereço não será subdividido. 
+ Para cada ALUNO, haverá apenas uma escola. O valor por escola não será subdividido. 
+ Para cada ALUNO, haverá apenas um telefone. O valor do telefone não será subdividido.



##### 4.6.3.1.3 As Chaves

Para cada ALUNO, não presumimos que nenhum atributo será único o suficiente para identificar entidades individuais. \(Lembre-se de que estamos descrevendo a Figura 4.3.\)



##### 4.6.3.1.4 Dados de amostra

Além dessas descrições, alguns dados de exemplo costumam ser úteis para mostrar ao usuário o que você propôs. Os dados de exemplo da Figura 4.3 são mostrados na Tabela 4.1.
TABELA 4.1 Dados da amostra inicial para a Figura 4.3.   **nome**  **principal**  **endereço**  **escola**  **telefone**    
* * *
      `Smith`  `Cosc`  `123 4th St`  `St. Helens`  `222–2222`    `Jones`  `Acct`  `222 2nd St`  `PS 123`  `333–3333`    `Saha`  `Eng`  `284 3rd St`  `Canton`  `345–3546`    `Kapoor`  `Math`  `20 Living Cr`  `High`  `435–4534`     
Ao ler essas descrições, você perceberá que todas parecem repetitivas e um tanto estruturadas demais. Por favor, tenha paciência, pois estamos apenas tentando ser inequívocos e, ainda assim, ser compreendidos por um usuário que provavelmente não gostaria de interpretar um diagrama.



#### 4.6.3.2 Figura 4.4 Exemplo

Agora, considere a Figura 4.4. Esta figura possui um atributo composto, nome. A descrição em inglês deste diagrama de entidade é a seguinte.



##### 4.6.3.2.1 A Entidade

Este banco de dados registra informações sobre ALUNOS. Para cada ALUNO no banco de dados, registramos um nome, uma escola e um endereço.



##### 4.6.3.2.2 Os Atributos

+ Para cada ALUNO, haverá apenas um nome. O valor do nome será subdividido em nome, sobrenome e inicial do nome do meio. 
+ Para cada ALUNO, haverá apenas um endereço. O valor do endereço não será subdividido. 
+ Para cada ALUNO, haverá apenas uma escola. O valor da escola não será subdividido.



##### 4.6.3.2.3 As Chaves

Para cada ALUNO, não assumimos que nenhum atributo será único o suficiente para identificar entidades individuais.



##### 4.6.3.2.4 Dados de amostra

Os dados de amostra da Figura 4.4 são mostrados na Tabela 4.2.
TABELA 4.2 Dados da amostra inicial para a Figura 4.4.   **nome.primeiro**  **nome.sobrenome**  **nome.mi**  **escola**  **endereço**    
* * *
      `Richard`  `Earp`  `w`  `U. Alabama`  `222 2nd St`    `Boris`  `Backer`   `Heidelberg`  `333 Dreistrasse`    `Helga`  `Hogan`  `H`  `U. Hoover`  `8 8 Half Moon Ave`    `Arpan`  `Bagui`  `K`  `Northern School`  `3 3 Bloom Ave`    `Hema`  `Malini`   `South Bend`  `100 Livingstone`        


#### 4.6.3.3 Figura 4.5A Exemplo

Em seguida, considere a Figura 4.5A. Esta figura possui um atributo composto e um multivalor. A tradução em inglês deste diagrama de entidades é apresentada a seguir.



##### 4.6.3.3.1 A Entidade

Para a entidade, este banco de dados registra dados sobre ALUNOS. Para cada ALUNO no banco de dados, registramos um nome, escolas e um endereço.



##### 4.6.3.3.2 Os Atributos

+ Para cada ALUNO, haverá apenas um nome. O valor de nome será subdividido em nome, sobrenome e inicial do meio. Ao dividir o nome, usamos a notação de ponto para indicar a origem das partes do atributo, portanto, nome.primeiro, nome.sobrenome, nome.mi. 
+ Para cada ALUNO, haverá apenas um endereço. O valor do endereço não será subdividido. 
+ Para cada ALUNO, registraremos as escolas. Pode haver mais de uma escola registrada para cada aluno.



##### 4.6.3.3.3 As Chaves

Para cada ALUNO, não assumimos que nenhum atributo será único o suficiente para identificar entidades individuais.



##### 4.6.3.3.4 Dados de amostra

Os dados de amostra da Figura 4.5a são mostrados na Tabela 4.3.
TABELA 4.3 Dados da amostra inicial para a Figura 4.5A.   **nome.nome.sobrenome.miescola**  **endereço**    
* * *
      `Richard`  `Earp`  `W`  `U. Alabama, Mountain`  `222 2nd St`    `Boris`  `Backer`   `Heidelberg, Volcano`  `333 Dreistrasse`    `Helga`  `Hog an`  `H`  `U. Hoover, St. Helens`  `88 Half Moon Ave`    `Arpan`  `Bagui`  `K`  `Northern School`  `33 Bloom Ave`    `Hema`  `Malini`   `South Bend`  `100 Livingstone`        


#### 4.6.3.4 Figura 4.6 Exemplo

Considere a Figura 4.6. Esta figura possui atributos compostos, multivalorados e chave. A tradução em inglês deste diagrama de entidades é a seguinte.



##### 4.6.3.4.1 A Entidade

Este banco de dados registra informações sobre ALUNOS. Para cada ALUNO no banco de dados, registramos um nome, escolas, um endereço e um número de aluno.



##### 4.6.3.4.2 Os Atributos

+ Para cada ALUNO, haverá apenas um nome. O valor para nome será subdividido em nome.primeiro, nome.sobrenome, nome.mi. 
+ Para cada ALUNO, haverá apenas um endereço. O valor do endereço não será subdividido. 
+ Para cada ALUNO, registraremos as escolas. Pode haver mais de uma escola registrada para cada aluno.



##### 4.6.3.4.3 As Chaves

Para cada ALUNO, há um atributo — student\_number — exclusivo o suficiente para identificar entidades individuais.



#### 4.6.3.5 Figura 4.7 Exemplo

Por fim, considere a Figura 4.7 \(figura superior\). Esta figura mostra uma entidade forte. Combinamos a gramática para evitar que a metodologia se torne excessivamente repetitiva. A tradução em inglês deste diagrama de entidade segue abaixo.



##### 4.6.3.5.1 A Entidade

Este banco de dados registra informações sobre AUTOMÓVEIS. Para cada AUTOMÓVEL no banco de dados, registramos a marca, o estilo da carroceria, o ano, a cor e o ID do veículo.



##### 4.6.3.5.2 Os Atributos

Cada AUTOMÓVEL terá apenas uma marca, estilo de carroceria, ano, cor e ID do veículo. Nenhum desses atributos será subdividido.



##### 4.6.3.5.3 As Chaves

Para cada AUTOMÓVEL, o atributo vehicle\_id será exclusivo o suficiente para identificar entidades individuais.

A parte inferior da Figura 4.7 mostra uma entidade fraca. A única diferença entre a descrição da entidade forte e da entidade fraca envolve a frase sobre uma chave, que pode não existir na entidade fraca.

Antes de encerrar este capítulo introdutório sobre diagramas ER, mostramos o outro componente principal dos diagramas ER. A Figura 4.8 mostra um relacionamento entre duas entidades: um AUTOMÓVEL e um ALUNO. O conceito de relacionamento é discutido detalhadamente no Capítulo 6. Um relacionamento adiciona ação ao diagrama. Por exemplo, o relacionamento na Figura 4.8 pode ser que ALUNOS dirigem AUTOMÓVEIS.
FIGURA 4.8 Um diagrama ER de um banco de dados ESTUDANTE-AUTOMÓVEL. 
Nossa metodologia de design de ER evoluiu para o seguinte até agora:

+  ** *Etapa 1. Selecione uma entidade primária na descrição dos requisitos do banco de dados e mostre os atributos a serem registrados para essa entidade. Identifique as chaves, se apropriado.***  
+  ** *Etapa 2. Use inglês estruturado para entidades, atributos e chaves para descrever o banco de dados obtido.***  
+  ** *Etapa 3. Mostre alguns dados de exemplo.***  



## 4.7 MAPEANDO O DIAGRAMA DE ENTIDADES PARA UM BANCO DE DADOS RELACIONAL

Tendo ilustrado a ideia da entidade e do atributo, passamos agora a uma concretização semifísica dos conceitos. Dizemos semifísica porque não estamos preocupados com o arquivo físico armazenado na memória; em vez disso, estamos preocupados em colocar os dados em tabelas relacionais que visualizaremos como uma organização física de dados. Basicamente, um banco de dados relacional é um banco de dados de tabelas bidimensionais chamadas relações. As tabelas são compostas por linhas e colunas. As linhas são às vezes chamadas de tuplas; as colunas são atributos. Em um banco de dados relacional, todos os atributos \(colunas da tabela\) devem ser atômicos e as chaves não devem ser nulas. Além disso, em bancos de dados relacionais, não é necessário saber a localização física real dos dados em um dispositivo magnético como um disco.

O processo de conversão de um diagrama ER em um banco de dados é chamado de mapeamento. Nos concentramos apenas no modelo relacional; portanto, à medida que os capítulos deste livro se desenvolvem, desenvolveremos regras de mapeamento para transformar diagramas ER em bancos de dados relacionais.

Começamos com uma regra para mapear entidades fortes.

+ Regra de mapeamento 1 — Mapeando entidades fortes. Desenvolva uma nova tabela \(relação\) para cada entidade forte e torne a chave indicada da entidade forte a chave primária da tabela. Se mais de uma chave candidata for indicada no diagrama ER, escolha uma para a chave primária. Chame essa tabela de TABELA1.

Em seguida, precisamos mapear os atributos na tabela da entidade forte, TABELA1. As regras de mapeamento são diferentes para atributos atômicos, atributos compostos e atributos multivalorados. Primeiro, apresentamos a regra de mapeamento para atributos atômicos.
> Regra de mapeamento 2 — Mapeando atributos atômicos. Para entidades com atributos atômicos, mapeie as entidades para uma tabela e forme colunas para cada atributo atômico. Aqui, mapearíamos os atributos atômicos associados à TABELA1 para ela.4 
Ao discutir tabelas relacionais, é comum abreviar o diagrama com uma notação como esta:

+ TABLENAME\(atributo1, atributo2,. …\)

Uma realização de banco de dados relacional do diagrama de entidade na Figura 4.3 ficaria assim:

+ ALUNO\(nome, telefone, escola, endereço, curso\)

E com alguns dados de amostra, conforme mostrado na Tabela 4.4.
TABELA 4.4 Dados de amostra para a Figura 4.3.   **nome**  **telefone**  **escola**  **endereço**  **principal**    
* * *
      `Jones`  `932–5100`  `U. Alabama`  `123 4th St`  `Chemistry`    `Smith`  `932–5101`  `U. Mississippi`  `123 5th St`  `Math`    `Adams`  `932–5102`  `LSU`  `123 6th St`  `Agriculture`    `Sumon`  `435–0997`  `UWF`  `11000 Univ`  `Cyber Sec`    `Mala`  `877–0982`  `Mount Union U`  `Alliance`  `History`     
ALUNO seria o nome desta relação \(tabela\). Os atributos no diagrama de entidades se tornam os títulos das colunas. A tabela real com dados de exemplo, uma realização de uma relação, é fornecida como um exemplo do tipo de dados que você pode esperar em tal tabela. A ordem das colunas é irrelevante para o banco de dados relacional, desde que, uma vez escolhida, a mantenhamos. O objetivo deste exemplo é que você, o analista de banco de dados, comunique ao usuário como você acha que o banco de dados deve ser.

E quanto aos atributos compostos e multivalorados? Como mencionamos, é um axioma do banco de dados relacional que todas as colunas sejam atômicas. Se tivermos um atributo não atômico em nosso diagrama, precisamos forçá-lo a ser atômico para o mapeamento para o banco de dados relacional. Para atributos compostos, alcançamos a atomicidade registrando apenas as partes componentes do atributo. Nossa próxima regra de mapeamento mapeia atributos compostos.

+ Regra de mapeamento 3 — Mapeamento de atributos compostos. Para entidades com atributos compostos, mapeie as entidades para uma tabela e forme colunas de cada parte elementar \(atômica\) dos atributos compostos.

Consulte a Figura 4.4. Um banco de dados relacional, que corresponde ao diagrama de entidades da Figura 4.4, seria:

+ ALUNO\(nome.primeiro, nome.sobrenome, nome.mi, escola, endereço\)

Nesta notação abreviada de um banco de dados relacional, o atributo composto \(nome\) é frequentemente incluído com uma notação de ponto \(por exemplo, nome.primeiro\). Aqui, nome é chamado de qualificador para as partes compostas do atributo.

Com alguns dados de amostra para a Figura 4.4 na Tabela 4.5.
TABELA 4.5 Dados de amostra para a Figura 4.4.   **nome.primeiro**  **nome.sobrenome**  **nome.mi**  **escola**  **endereço**    
* * *
      `Richard`  `Earp`  `w`  `U. Alabama`  `222 2nd St`    `Boris`  `Backer`   `Heidelberg`  `333 Dreistrasse`    `Helga`  `Hog an`  `H`  `U. Hoover`  `88 Half Moon Ave`    `Arpan`  `Bagui`  `K`  `Cambridge`  `33 Bloom Ave`    `Hema`  `Malini`   `Fashion U`  `100 Livingstone`     
Um atributo multivalorado é representado na Figura 4.5A. Neste diagrama de entidade, a entidade ALUNO possui um atributo composto, nome, e um atributo multivalorado, escola. Isso significa que os alunos podem ter mais de uma escola registrada para sua linha. Os dados representados pela Figura 4.5A podem se parecer com a Tabela 4.6.
TABELA 4.6 Dados de amostra para a Figura 4.5A.   **nome.primeiro nome.sobrenome.meu endereço**  **escola**    
* * *
      `Richard`  `Earp`  `W`  `222 2nd St`  `U. Alabama, St Helens, Mountain, Volcano`    `Boris`  `Backer`   `333 Dreistrasse`  `Heidelberg, Manatee U, UCF, UWF`    `Helga`  `Hog an`  `H`  `88 Half Moon Ave`  `U. Hoover, Mount Union U, Manatee U`    `Arpan`  `Bagui`  `K`  `33 Bloom Ave`  `Cambridge, USF, Harvard`    `Hema`  `Malini`   `100 Livingstone`  `Fashion U, Milan U`     


Esta não é considerada uma tabela relacional porque o atributo "school" não é atômico. Para ser uma tabela relacional, todo atributo precisa ser atômico. Para mapear este atributo multivalorado atomicamente, seguimos a seguinte regra de mapeamento:

+ Regra de mapeamento 4 — Mapeamento de atributos multivalorados. Crie uma tabela separada para o atributo multivalorado. Registre uma linha para cada valor do atributo multivalorado, juntamente com a chave da tabela original. A chave da nova tabela será a concatenação do atributo multivalorado mais a chave da entidade proprietária. Remova o atributo multivalorado da tabela original.

De acordo com a regra de mapeamento 4, precisamos de uma chave para mapear atributos multivalorados; portanto, usamos a Figura 4.6 para mapear corretamente o atributo multivalorado. A Figura 4.6 seria mapeada nas duas relações a seguir:

+ ALUNO\(número\_aluno, nome.primeiro, nome.sobrenome, nome.mi, endereço\)

e

+ ESCOLA\_ALUNO\(número\_aluno, escola\)

Alguns dados de amostra seriam mostrados nas Tabelas 4.7A e 4.7B.
TABELA 4.7A Dados de amostra para ALUNO.   **número\_do\_aluno**  **nome.primeiro**  **nome.sobrenome**  **nome.mi**  **endereço**    
* * *
      `111–11–2222`  `Richard`  `Earp`  `w`  `222 2nd St`    `222–11–2222`  `Boris`  `Backer`   `333 Dreistrasse`    `234–45–4567`  `Helga`  `Hogan`  `H`  `88 Half Moon Ave`    `888–77–9990`  `Arpan`  `Bagui`  `K`  `33 Bloom Ave`    `123–45–4321`  `Hema`  `Malini`   `100 Livingstone`      TABELA 4.7B Dados de amostra para STUDENT\_SCHOOL.   **número\_do\_aluno**  **escola**    
* * *
      `111–11–2222`  `U. Alabama`    `111–11–2222`  `St. Helens`    `111–11–2222`  `Mountain`    `111–11–2222`  `Volcano`    `222–11–2222`  `Heidelberg`    `222–11–2222`  `Manatee U`    `222–11–2222`  `UCF`    `222–11–2222`  `UWF`    `234–45–4567`  `U. Hoover`    `234–45–4567`  `Mount Union U`    `234–45–4567`  `Manatee U`    `888–77–9990`  `Cambridge`    `888–77–9990`  `USF`    `888–77–9990`  `Harvard`    `123–45–4321`  `Fashion U`    `123–45–4321`  `Milan U`     
Em bancos de dados relacionais, cada linha de uma tabela contém atributos atômicos e cada linha é única. Portanto, uma chave candidata em qualquer tabela é sempre a soma de todos os atributos. Normalmente, um subconjunto de "todos os atributos" pode ser considerado uma chave, mas como duas linhas nunca são iguais, é sempre verdade que uma chave candidata é a coleção de todos os atributos.

Ponto de verificação 4.3

1. Como você mapeia atributos multivalorados? 
2. Como você mapeia atributos compostos? 
3. O que é um identificador único? É uma chave candidata? É "a" chave primária? Discuta.





## 4.8 RESUMO DO CAPÍTULO

O foco principal deste capítulo foi o desenvolvimento do conceito de entidade e o desenvolvimento de um diagrama de uma entidade utilizando o modelo Chen-like. O conceito de atributos também foi discutido, e a última seção abordou como um diagrama de uma entidade poderia ser mapeado para um banco de dados relacional. A gramática para um diagrama de uma entidade e seus atributos também foi desenvolvida. Essa gramática será desenvolvida com mais detalhes nos capítulos seguintes. O próximo capítulo discute o desenvolvimento de uma segunda entidade e o relacionamento entre esta segunda entidade e a entidade primária.





## CAPÍTULO 4 EXERCÍCIOS

Nota: O usuário deve esclarecer as suposições feitas ao relatar seu trabalho.



### Exercício 4.1

Você quer criar um banco de dados sobre empresas. Cada empresa terá um nome, endereço, número de telefone comercial, número de telefone do proprietário e os primeiros nomes dos funcionários que trabalham nela. Desenhe o diagrama ER usando o modelo Chen e, em seguida, escreva a descrição em inglês para seus diagramas. Compare o inglês com seus diagramas e declare quaisquer suposições que você tenha feito ao desenhá-los. Mapeie seus diagramas para um banco de dados relacional.

Quais atributos você consideraria atributos compostos neste banco de dados? Quais atributos você consideraria atributos multivalorados neste banco de dados? Poderia haver atributos derivados? Quais seriam boas chaves?



### Exercício 4.2

Você quer criar um banco de dados sobre os livros em sua estante. Cada livro tem autores \(apenas o sobrenome é necessário\), título, editora, cursos utilizados \(apenas o número do curso\). Desenhe o diagrama ER usando o modelo Chen e, em seguida, escreva a descrição em inglês para seus diagramas. Compare o inglês com seus diagramas e indique quaisquer suposições que você tenha feito ao desenhá-los.

Quais atributos você consideraria atributos compostos neste banco de dados? Quais atributos você consideraria atributos multivalorados neste banco de dados? Poderia haver atributos derivados? Quais seriam boas chaves? Mapeie seu diagrama para um banco de dados relacional.



## ESTUDO DE CASO



### Shopping West Florida

Um novo shopping, o West Florida Mall, foi inaugurado há três semanas em Pensacola, Flórida. Este novo shopping está atraindo muitos clientes e lojas. O West Florida Mall, que faz parte de uma série de shoppings pertencentes a uma empresa controladora, agora precisa de um banco de dados para acompanhar a gestão do shopping em termos de todas as suas lojas, bem como dos proprietários e funcionários das lojas. Antes de construirmos um banco de dados para este sistema de shoppings, o primeiro passo será projetar um diagrama ER para o proprietário do shopping. Reunimos as seguintes especificações iniciais do usuário sobre o shopping, com as quais podemos começar a criar o diagrama ER:

1. Precisamos registrar informações sobre o shopping e cada loja. Precisamos registrar o nome e o endereço do shopping. Um shopping, em qualquer momento, deve conter uma ou mais lojas. 
2. Para cada loja, precisaremos manter as seguintes informações: número da loja \(que será único\), nome da loja, localização da loja \(número da sala\), departamentos, proprietário e gerente. Cada loja pode ter mais de um departamento, com cada departamento tendo um gerente. Cada loja terá apenas um gerente. Cada loja pertence a apenas um proprietário. Cada loja está localizada em um único shopping. 
3. Um gerente de loja pode gerenciar apenas uma loja. Precisamos registrar informações sobre ele: nome, número do Seguro Social, loja em que trabalha e salário. 
4. O proprietário da loja é uma pessoa. Registraremos o nome, endereço e telefone comercial do proprietário da loja. O proprietário da loja deve possuir pelo menos uma loja, mas pode possuir mais de uma.



### Desenvolvendo o Estudo de Caso

Conforme a etapa 1 na criação do diagrama ER, temos que selecionar nossa entidade primária e, em seguida, os atributos para nossa entidade primária \(a etapa 1 é mostrada a seguir\):

+  ** *Etapa 1. Selecione uma entidade primária na descrição dos requisitos do banco de dados e mostre os atributos a serem registrados para essa entidade.***  

Escolheremos o MALL como nossa entidade principal.

Nosso próximo passo é traduzir o diagrama para o inglês:

+  ** *Etapa 2. Use inglês estruturado para entidades, atributos e chaves para descrever o banco de dados que foi obtido.***  



### A Entidade

Este banco de dados registra dados sobre um SHOPPING.

Para cada MALL no banco de dados, registramos um nome, um endereço e nomes de lojas.



### Os atributos para MALL

+ Para cada MALL, haverá apenas um nome. O valor do nome não será subdividido. 
+ Para cada SHOPPING, haverá apenas um endereço. O valor do endereço não será subdividido. 
+ Para cada MALL, registre store\_names. Pode haver mais de um store\_name registrado para cada MALL. O valor de cada store\_name não será subdividido.



### As Chaves

Para cada SHOPPING, presumimos que o nome do shopping será único.

A entidade MALL é mostrada na Figura 4.9.
FIGURA 4.9 A entidade MALL. 
Até o momento, para este estudo de caso, selecionamos uma entidade primária, MALL, mostramos seus atributos conhecidos e usamos inglês estruturado para descrever a entidade e seus atributos. Em seguida, mapeamos esse diagrama de entidade para um banco de dados relacional.



### Mapeando a entidade para um banco de dados relacional

MALL é uma entidade forte, então usamos a regra de mapeamento 1, que afirma:

+ Desenvolva uma nova tabela \(relação\) para cada entidade forte e torne a chave indicada da entidade forte a chave primária da tabela. Se mais de uma chave candidata for indicada no diagrama ER, escolha uma para a chave primária.

Desenvolvemos uma nova relação para a entidade MALL \(como mostrado na Figura 4.9\), e nome será nossa chave primária. Os dados representados pela Figura 4.9 podem se parecer com a Tabela 4.8.
TABELA 4.8 Dados de amostra para a Figura 4.9.   **nome**  **endereço**  **nome\_da\_loja**    
* * *
      `West Florida Mall`  `N Davis Hwy, Pensacola, FL`  `Penney’s, Sears, Dollar Store, Rex`    `Cordova Mall`  `9th Avenue, Pensacola, FL`  `Dillards, Parisian, Circuit City`    `Navy Mall`  `Navy Blvd, Pensacola, FL`  `Belks, Wards, Pearl Vision`    `BelAir Mall`  `10th Avenue, Mobile, AL`  `Dillards, Sears, Penney’s`     
Podemos ver que MALL tem um atributo multivalorado, store\_name. Isso não torna a tabela uma tabela relacional, pois store\_name não é atômica; ela é multivalorada. Para atributos multivalorados, a regra de mapeamento é:

+ Crie uma tabela separada para o atributo multivalor. Registre uma linha para cada valor do atributo multivalor, juntamente com a chave da tabela original. A chave da nova tabela será a concatenação do atributo multivalor mais a chave da entidade proprietária. Remova o atributo multivalor da tabela original.

Usando essa regra de mapeamento, duas relações ou tabelas relacionais seriam desenvolvidas \(e observe que a chave de MALL-STORE, a tabela com o atributo multivalorado, tem tanto o nome quanto o store\_name sublinhados\):
> ` MALL(*name, address*) MALL-STORE(*name, store_name*) ` 
E os dados ficariam como na Tabela 4.9.
TABELA 4.9 Dados de amostra para MALL.   **nome**  **endereço**    
* * *
      `West Florida Mall`  `1234 N Davis Hwy, Pensacola, FL`    `Cordova Mall`  `613 9th Avenue, Pensacola, FL`    `Navy Mall`  `31458 Navy Blvd, Pensacola, FL`    `BelAir Mall`  `12 10th Avenue, Mobile, AL`     
E a tabela com o atributo multivalorado, Tabela 4.10.
TABELA 4.10 Dados de amostra para MALL-STORE.   **nome**  **nome\_da\_loja**    
* * *
      `West Florida Mall`  `Phillip’s`    `West Florida Mall`  `Sikha’s`    `West Florida Mall`  `Popcorn Store`    `West Florida Mall`  `Richard’s`    `Cordova Mall`  `Darnley’s`    `Cordova Mall`  `Pensacola’s Finest`    `Cordova Mall`  `TV City`    `Navy Mall`  `Bell Bottoms`    `Navy Mall`  `Waverly`    `Navy Mall`  `Pearl Divers`    `BelAir Mall`  `Darnley’s`    `BelAir Mall`  `Sikha’s`    `BelAir Mall`  `Phillip’s`     
Este estudo de caso continua no final do próximo capítulo.



## NOTAS

+ 1 C. J. Date \(1995\), An Introduction to Database Systems, 6ª edição, preferiu a palavra “propriedade” a “atributo” por ser mais genérica e porque atributo é usado em outros contextos. Usamos atributo porque acreditamos que seja mais comumente usado. 
+ 2 O domínio de valores é o conjunto de valores que um determinado atributo pode assumir. O domínio consiste em todos os valores legais possíveis que são permitidos em um atributo. Um tipo de dado é um termo mais amplo usado para descrever atributos, mas o tipo de dado inclui a ideia de quais operações são permitidas. Como as pessoas que criam um banco de dados geralmente se preocupam mais com armazenamento e recuperação, os tipos de dados de banco de dados geralmente se concentram apenas no domínio de valores. 
+ 3 Os detalhes do relacionamento entidade fraca/entidade forte ficarão mais claros à medida que introduzirmos os relacionamentos no Capítulo 5. 
+ 4 Essas regras de mapeamento são adaptadas de Elmasri e Navathe \(2016\).



## BIBLIOGRAFIA

+ Batini, C., Ceri, S. e Navathe, S.B. \(1992\). Projeto Conceitual de Banco de Dados. Redwood City, CA: Benjamin Cummings. 
+ Chen, P.P. \(1976\). O modelo entidade-relacionamento — em direção a uma visão unificada dos dados. ACM Transactions on Database Systems, 1\(1\): 9–37. 
+ Chen, P.P. \(1977\). O modelo entidade-relacionamento: Uma base para a visão empresarial dos dados. Anais do IFIPS NCC, 46: 76–84. 
+ Codd, E. \(1990\). Modelo Relacional para Gerenciamento de Dados — Versão 2. Reading, MA: Addison-Wesley. 
+ Date, C.J. \(1995\). Uma Introdução aos Sistemas de Banco de Dados, 6ª edição. Reading, MA: Addison-Wesley. 
+ Date, C.J. \(2003\). Uma Introdução aos Sistemas de Banco de Dados. Reading, MA: Addison-Wesley. 
+ Earp, R. e Bagui, S. \(2000\). Construindo um diagrama entidade-relacionamento: Uma abordagem de engenharia de software. Database Management Journal, 22–10–41: 1–16. 
+ Elmasri, R., e Navathe, S.B. \(2016\). Fundamentos de Sistemas de Banco de Dados. Reading, MA: Addison-Wesley. 
+ Jeffry, A., Hoffer, V. e Heikki, T. \(2011\). Gerenciamento Moderno de Banco de Dados. Upper Saddle River, NJ: Prentice Hall. 
+ Navathe, S. e Cheng, A. \(1983\). Uma metodologia para mapeamento de esquemas de banco de dados a partir de modelos estendidos de entidade-relacionamento para o modelo hierárquico. Em "A Abordagem Entidade-Relacionamento para Engenharia de Software", G.C. Davis et al. \(editores\). Amsterdã: Elsevier, Holanda do Norte, 223–248. 
+ Scheuermann, P., Scheffner, G. e Weber, H. \(1980\). Capacidades de abstração e modelagem de propriedades invariantes na abordagem entidade-relacionamento. Em Abordagem Entidade-Relacionamento para Análise e Projeto de Sistemas, P. Chen \(editor\). Amsterdã: Elsevier, Holanda do Norte, 121–140. 
+ Teorey, T.J., Yang, D. e Fry, J.P. \(1986\). Uma metodologia de design lógico para bancos de dados relacionais usando o modelo entidade-relacionamento estendido. ACM Computing Surveys, 18\(2\): 197–222. 
+ Valacich, J.S., George, J.F. e Hoffer, J.A. \(2009\). Fundamentos de Análise e Projeto de Sistemas. Upper Saddle River, NJ: Prentice Hall.





# 5 Além do Primeiro Diagrama de Entidade



DOI: 10.1201/9781003314455-5



## 5.1 INTRODUÇÃO

Agora que elaboramos um processo para desenhar, interpretar e refinar uma entidade primária, precisamos avançar para bancos de dados mais complexos. Para prosseguir, continuamos com nossa entidade primária e buscamos outras informações associadas \(relacionadas\) a essa entidade.

A primeira técnica empregada neste capítulo é metódica: testamos nossa entidade primária para verificar se nossos atributos devem ser entidades. Em seguida, procuramos outras informações em nossa descrição e as adicionamos a:

1. Uma entidade existente e examinar o diagrama entidade-relacionamento \(ER\) existente 
2. Crie uma nova entidade diretamente

Após a criação das novas entidades, verificamos quais relacionamentos existem entre elas. Um banco de dados é uma coleção de dados relacionados; portanto, novas entidades podem ser adicionadas, desde que haja uma maneira de conectá-las às existentes. Este capítulo desenvolve as etapas 3 a 5 da metodologia de projeto de ER apresentada neste livro. A etapa 3 examina os atributos da entidade primária; a etapa 4 discute o que fazer se outra entidade for necessária; e a etapa 5 discute o desenvolvimento do relacionamento entre as duas entidades.

Embora o conceito de relacionamentos seja introduzido neste capítulo, não incluímos nenhuma nova regra de mapeamento, pois elas podem ser melhor compreendidas após o desenvolvimento de restrições estruturais em relacionamentos, discutido no Capítulo 6. No final deste capítulo, continuamos com o caso iniciado no Capítulo 4.



## 5.2 EXAMINANDO UMA ENTIDADE: ALTERANDO UM ATRIBUTO PARA SER UMA ENTIDADE

Considere a Figura 5.1. Nesta figura, temos uma entidade ALUNO com os seguintes atributos: nome \(um atributo composto\), número\_do\_aluno \(um atributo atômico e chave\), escola \(um atributo multivalorado\) e endereço \(um atributo atômico\). Suponha que, durante nossa primeira sessão com o usuário, mostremos o diagrama, o inglês e os dados de exemplo, e o usuário diga: "Espere um minuto. Quero registrar todas as escolas que um aluno frequentou e quero registrar não apenas o nome da escola, mas também a localização \(cidade e estado\) e o tipo de escola \(faculdade comunitária, universidade, ensino médio, etc.\)".
FIGURA 5.1 Entidade ALUNO com um Atributo Multivalorado. 
O que o usuário acabou de nos dizer é que o atributo school deveria ser, na verdade, uma entidade. Lembre-se, a definição de uma entidade era algo sobre o qual queríamos registrar informações. Nossa ideia original era registrar schools-atended, mas agora nos dizem que queremos registrar informações sobre as escolas. O primeiro indicador de que um atributo deve ser considerado uma entidade é que precisamos armazenar informações sobre o atributo. O que fazemos então é migrar da Figura 5.1 para a Figura 5.2. Na Figura 5.2, SCHOOL agora é uma entidade por si só, então temos duas entidades separadas, SCHOOL e STUDENT. Assumimos que school\_name é único e o escolhemos como a chave para a entidade SCHOOL.
FIGURA 5.2 Dois diagramas ER: um de ALUNO e um de ESCOLA. 
O próximo passo seria definir um relacionamento entre as duas entidades.





## 5.3 DEFININDO UM RELACIONAMENTO PARA NOSSA NOVA ENTIDADE

Bancos de dados são projetados para armazenar dados relacionados. Por exemplo, normalmente não faria sentido registrar dados sobre alunos e moedas estrangeiras ou sobre voos e funcionários de uma fábrica de bolas de tênis listados no mesmo banco de dados. Esses conceitos não estão relacionados. Em um banco de dados, deveríamos estar criando uma coleção de dados relacionados. Seguindo nosso método, temos claramente uma situação em que um atributo fazia parte de uma entidade \(escola era considerada "parte de" aluno\), mas agora escola se tornou uma entidade por si só. O que precisamos fazer agora é relacionar a entidade ESCOLA à entidade ALUNO.

Na Figura 5.2, temos duas entidades, mas elas parecem independentes. Para que as entidades ESCOLA e ALUNO funcionem como um banco de dados, precisamos adicionar algo: o relacionamento que a entidade ESCOLA tem com a entidade ALUNO.

Um relacionamento em um diagrama ER é uma conexão entre duas ou mais entidades ou entre uma entidade e ela mesma. Este último tipo de relacionamento, entre uma entidade e ela mesma, é conhecido como relacionamento recursivo, que discutiremos no Capítulo 8. O nome de um relacionamento geralmente é um verbo ou locução verbal que denota a conexão entre entidades. Uma vez que tenhamos entendido como o relacionamento é denotado, temos uma "ferramenta" para desenhar uma descrição de banco de dados na forma de um diagrama ER.

No modelo semelhante ao de Chen, um relacionamento é representado por um losango na linha que une as duas entidades, conforme mostrado na Figura 5.3.
FIGURA 5.3 A entidade ALUNO com relacionamento com a entidade ESCOLA. 
Na Figura 5.3, o relacionamento é representado como "atender". O sentido do relacionamento é um verbo conectando dois substantivos \(entidades\). Todos os relacionamentos são bidirecionais. Como veremos, é necessário declarar todos os relacionamentos em ambas as direções. Por exemplo, no modelo do tipo Chen, diríamos informalmente: "UM ALUNO frequentou uma ESCOLA" ou "ALUNOS frequentam ESCOLAS".

O grau de um relacionamento refere-se ao número de entidades que participam dele. Na Figura 5.3, duas entidades participam do relacionamento, atendendo, o que é chamado de relacionamento binário.

Agora temos uma ferramenta para desenhar uma descrição de banco de dados na forma de diagramas ER. Nos diagramas ER, registramos informações sobre x e y \(x e y são entidades\) e, em seguida, expressamos a relação de x com y.

Nossa metodologia crescente e modificada será discutida a seguir.



### 5.3.1 Metodologia de Projeto ER

+  ** *Etapa 1. Selecione uma entidade primária da descrição dos requisitos do banco de dados e mostre os atributos a serem registrados para essa entidade. Identifique as chaves, se apropriado, e mostre alguns dados de exemplo.***  
+  ** *Etapa 2. Use inglês estruturado para entidades, atributos e chaves para descrever o banco de dados obtido.***  
+  ** *Etapa 3. Examine os atributos na entidade primária \(possivelmente com assistência do usuário\) para descobrir se as informações sobre um dos atributos devem ser registradas.***  
+  ** *Etapa 3a. Se forem necessárias informações sobre um atributo, torne o atributo uma entidade e, em seguida,***  
+  ** *Etapa 3b. Defina o relacionamento de volta à entidade original.***  
+  ** *Etapa 4. Mostre alguns dados de exemplo.***  



## 5.4 UMA GRAMÁTICA PRELIMINAR PARA DIAGRAMAS ER

No Capítulo 4, delineamos uma gramática para descrever uma entidade. Agora, adicionamos um relacionamento ao nosso diagrama e precisamos aprimorar nossa descrição em inglês do banco de dados proposto. Também queremos mostrar ao usuário alguns dados de exemplo para solidificar a compreensão do caminho que estamos percorrendo. Queremos adicionar o seguinte à nossa lista de expressões gramaticais:

Para cada relacionamento, adicionamos o seguinte comentário \(em inglês livre \[por enquanto\]\):

+ Uma\(n\) Entidade Relacionamento Entidadevn2 \(voz ativa\) e uma\(n\) Entidade Relacionamento Entidade2 \(voz passiva\).

Segue uma discussão sobre isso.



### 5.4.1 O Relacionamento

+ Um ALUNO frequenta uma ESCOLA, e uma ESCOLA é frequentada por um ALUNO.

O usuário pode ser o juiz final da adequação da expressão que usamos, mas em breve adicionaremos algo a essa gramática. O usuário pode preferir um tempo verbal diferente e escolher um verbo que considere mais apropriado para avaliar a situação. Por exemplo, o usuário pode optar por descrever o relacionamento como "ALUNOS irão matricular-se em ESCOLAS". Como exercício, você será solicitado a fornecer uma descrição completa do diagrama ER na Figura 5.3, com todas as entidades, atributos, chaves e relacionamentos.



## 5.5 DEFININDO UMA SEGUNDA ENTIDADE

Após examinar a entidade primária original em busca de atributos "suspeitos", podemos agora começar a adicionar mais dados. Suponhamos que o usuário queira adicionar informações sobre os automóveis que os alunos possuem ou dirigem. Ignorando a entidade ESCOLA por enquanto, suponhamos que, desta vez, desenvolvemos a seguinte descrição adicional:

Queremos registrar informações sobre os alunos — seus nomes e números de alunos. Além das informações sobre os alunos, queremos registrar informações sobre seus automóveis — o número de identificação do veículo, a marca do carro, o tipo de carroceria, a cor e o ano do modelo. Suponhamos ainda que decidimos escolher ALUNO como a entidade primária e queremos adicionar as informações do automóvel.

O automóvel é claramente uma entidade — é algo sobre o qual queremos registrar informações. Se o adicionássemos ao banco de dados, poderíamos tê-lo incluído na etapa 1 da nossa metodologia adicionando um atributo chamado automóvel, para posteriormente executar a etapa 3 da metodologia e migrar Automóvel e escola para o status de entidades. A representação de automóvel como um atributo da entidade ALUNO é mostrada na Figura 5.4 no modelo do tipo Chen. \(Ignoramos a entidade ESCOLA por enquanto.\)
FIGURA 5.4 Uma entidade STUDENT com um atributo chamado automóvel. 
Se adicionássemos o atributo automóvel à entidade ALUNO e reconhecêssemos que automóvel deveria ser uma entidade, criaríamos a entidade AUTOMÓVEL e adicionaríamos o relacionamento ao modelo. A Figura 5.4 poderia ser suficiente se o usuário não quisesse armazenar informações sobre os próprios automóveis.

Claro, poderíamos ter reconhecido que o atributo automóvel seria uma entidade desde o início e simplesmente registrado como tal em nosso diagrama desde o início. Ao reconhecer AUTOMÓVEL como uma entidade, desenharíamos as duas entidades ALUNO e AUTOMÓVEL e, em seguida, buscaríamos uma relação entre elas — Figura 5.5 com duas entidades, ALUNO e AUTOMÓVEL, e alguma relação entre as duas entidades.
FIGURA 5.5 Um diagrama ER do banco de dados STUDENT-AUTOMOBILE. 


Na notação Chen-like, agora escolhemos um verbo para descrever o relacionamento entre as duas entidades \(ALUNO e AUTOMÓVEL\); neste caso, escolhemos dirigir \(mostrado no losango na Figura 5.5\). Posteriormente, o usuário pode optar por identificar o relacionamento como algo diferente, mas sem outras informações, presumimos que o usuário quer dizer: "Um aluno dirige um automóvel". Outros candidatos para um relacionamento entre as entidades ALUNO e AUTOMÓVEL podem ser "registrar", "possuir" e assim por diante. O relacionamento entre essas duas entidades é um relacionamento binário.

Relacionamentos em diagramas ER geralmente recebem nomes que descrevem como as entidades se relacionam. Às vezes, um relacionamento é difícil de descrever \(ou é desconhecido\); neste caso, um código de duas letras para o relacionamento é usado. Esse relacionamento de duas letras é mostrado na Figura 5.6. Demos ao relacionamento o nome SA para indicar que entendemos que existe um relacionamento, mas não temos certeza de como chamá-lo exatamente \(SA = ESTUDANTE-AUTOMÓVEL\). É claro que, se tivéssemos certeza de que "impulsionar" é o relacionamento, usaríamos "impulsionar".
FIGURA 5.6 Um diagrama ER do banco de dados ESTUDANTE-AUTOMÓVEL com um relacionamento “Desconhecido” e “Ainda a ser determinado”. 
A descrição em inglês das entidades e relacionamentos implica que as entidades são substantivos \(N\) e os relacionamentos são verbos \(V\). Usando o relacionamento "dirigir" \(como mostrado na Figura 5.6\), "Alunos" \(N\) dirigem "V" \(Automóveis\) \(N\). Se o relacionamento "desconhecido" for realmente desconhecido, poderíamos dizer "Alunos" \(N\) estão relacionados a "V" \(Automóveis\) \(N\)" ou "Um aluno" \(N\) está relacionado a "V" \(Automóvel\) \(N\)". No próximo capítulo, desenvolveremos mais essa descrição em inglês, bem como a parte de relacionamento do diagrama.

Neste ponto, introduzimos as entidades ALUNO, AUTOMÓVEL e ESCOLA. Com todas as três entidades, o banco de dados ALUNO-AUTOMÓVEL-ESCOLA ficaria como na Figura 5.7.
FIGURA 5.7 Um diagrama ER do banco de dados AUTOMÓVEL-ALUNO-ESCOLA.  
Ponto de verificação 5.1

1. A natureza de uma entidade pode mudar ao longo do tempo? Explique. 
2. O que é um relacionamento? 
3. Quais são as diferenças entre uma entidade e um relacionamento? 
4. Quando seria preferível considerar um atributo uma entidade? 
5. Faz sentido ter uma entidade com um atributo? Por que sim ou por que não?



## 5.6 EXISTE UM RELACIONAMENTO?

Algumas situações podem ocorrer para as quais um relacionamento pode não ser claro. Por exemplo, considere esta descrição do usuário de um banco de dados desejado:
> Crie um banco de dados para CLIENTES e FORNECEDORES. Os CLIENTES terão nome, endereço, número de telefone e número do cliente. OS FORNECEDORES terão número do fornecedor, nome e endereço. 
Neste banco de dados, temos claramente duas entidades: CLIENTE e FORNECEDOR. Queremos armazenar informações sobre clientes \(nome, endereço, …\) e fornecedores \(número do fornecedor, nome do fornecedor, …\). Mas qual é a conexão entre os dois?

O que temos aqui é uma descrição de usuário incompleta e vaga a partir da qual projetaremos nosso banco de dados. A conexão para a empresa que deseja o banco de dados é que ela possui clientes e fornecedores; no entanto, o que ela pode não perceber é que o relacionamento do CLIENTE com o FORNECEDOR se dá por meio de uma empresa ou fornecedor, e não de um relacionamento direto. Portanto, o que temos até agora nesta descrição são duas partes diferentes de um banco de dados da empresa — uma para clientes e outra para fornecedores. Se posteriormente tivermos alguma outra entidade, como ESTOQUE ou FORNECEDOR, que esteja relacionada a CLIENTES e FORNECEDORES, pode haver entidades e relacionamentos de ligação. Por enquanto, com apenas duas ideias não relacionadas \(cliente e fornecedor\), não há relacionamento aparente — então a solução seria deixar qualquer relacionamento fora do diagrama geral até que mais informações sejam obtidas do usuário. Dois bancos de dados não relacionados podem precisar ser desenvolvidos.



## 5.7 ATRIBUTO OU RELACIONAMENTO?

Às vezes, pode não ser claro se algo é um atributo ou um relacionamento. Tanto atributos quanto relacionamentos expressam algo sobre uma entidade. Os atributos de uma entidade expressam qualidades em termos de propriedades ou características. Relacionamentos expressam associações com outras entidades.

Suponha que estejamos construindo um banco de dados de biblioteca e criemos outra entidade primária, BOOK, que possui um atributo borrower\_name. Em alguns casos, uma construção de atributo provavelmente é inadequada para expressar uma associação opcional que, na verdade, deveria ser um relacionamento entre duas entidades. Como uma questão secundária, BORROWER exigiria o uso de um valor nulo para as entidades BOOK que não estão emprestadas. Na realidade, apenas uma fração dos livros em uma biblioteca está emprestada em um determinado momento. Assim, o atributo "borrower" seria nulo para algumas das entidades BOOK. Essa recorrência de muitos nulos pode indicar que o atributo borrower\_name pode ser um atributo de uma entidade. Se uma entidade BORROWER fosse criada e a associação entre as entidades BOOK e BORROWER fosse explicitamente declarada como um relacionamento, o projetista do banco de dados provavelmente estaria mais perto de colocar atributos e entidades em seus devidos lugares. É importante entender a distinção entre os tipos de informação expressos como atributos e aqueles tratados como relacionamentos e entidades.

Ponto de verificação 5.2

1. Os relacionamentos entre duas entidades são permanentes ou a natureza desse relacionamento pode mudar com o tempo? 
2. Os atributos de uma entidade são permanentes? 
3. Sempre existe uma relação entre duas entidades? 
4. O que é um relacionamento binário?

Nossa metodologia de elicitação e design de ER é descrita a seguir.



### 5.7.1 Metodologia de Projeto ER

+  ** *Etapa 1. Selecione uma entidade primária na descrição dos requisitos do banco de dados e mostre os atributos a serem registrados para essa entidade. Identifique as chaves, se apropriado, e mostre alguns dados de exemplo.***  
+  ** *Etapa 2. Use inglês estruturado para entidades, atributos e chaves para descrever o banco de dados obtido.***  
+  ** *Etapa 3. Examine os atributos na entidade primária \(possivelmente com assistência do usuário\) para descobrir se as informações sobre um dos atributos devem ser registradas.***  
+  ** *Etapa 3a. Se forem necessárias informações sobre um atributo, torne o atributo uma entidade e, em seguida,***  
+  ** *Etapa 3b. Defina o relacionamento de volta à entidade original.***  
+  ** *Passo 4. Se outra entidade for apropriada, desenhe a segunda entidade com seus atributos. Repita o passo 2 para ver se essa entidade deve ser dividida em mais entidades.***  
+   ** *Etapa 5. Conecte entidades com relacionamentos, se houver relacionamentos.***  
+  ** *Etapa 6. Mostre alguns dados de exemplo.***  





## 5.8 RESUMO DO CAPÍTULO

Entidades, atributos e relacionamentos foram definidos no Capítulo 4. No entanto, na prática, ao projetar bancos de dados, muitas vezes é difícil determinar se algo deve ser um atributo, entidade ou relacionamento. Este capítulo discutiu maneiras \(técnicas\) de determinar se algo deve ser uma entidade, atributo ou relacionamento.

Este capítulo também introduziu o conceito de relacionamentos binários. Bancos de dados reais terão mais de uma entidade, portanto, este capítulo desenvolveu o diagrama ER de um diagrama de uma entidade para um diagrama de duas entidades e mostrou como determinar e representar relacionamentos binários entre as duas entidades usando o modelo do tipo Chen. Como o conceito de relacionamentos foi apenas introduzido e as restrições estruturais dos relacionamentos ainda não foram discutidas \(Capítulo 6\), não incluímos regras de mapeamento neste capítulo.





## CAPÍTULO 5 EXERCÍCIOS



### Exercício 5.1

Desenhe um diagrama ER \(usando o modelo Chen-like\) para uma entidade chamada HOTEL e inclua no mínimo cinco atributos para a entidade. Dos cinco atributos, inclua pelo menos um atributo composto e um atributo multivalorado.



### Exercício 5.2

Suponhamos que reconsideremos nosso exemplo ALUNO e que os únicos atributos de aluno sejam número e nome. Suponhamos que temos outra entidade chamada ENSINO MÉDIO — a escola de ensino médio na qual o aluno se formou. Para a entidade ENSINO MÉDIO, registraremos o nome da escola e a localização \(ou seja, cidade e estado\). Desenhe o diagrama ER usando a forma concisa \(como na Figura 4.1c\). Como você nomearia o relacionamento aqui? Escreva a gramática para o relacionamento entre as duas entidades.



### Exercício 5.3

Suponha que uma faculdade tenha um dormitório com vários quartos. A entidade DORMITÓRIO, que na verdade é uma entidade "dormitório", visto que há apenas um dormitório, possui os atributos número do quarto e individual/duplo \(ou seja, há quartos individuais e duplos\). Suponhamos que a entidade ALUNO, neste caso, contenha os atributos número do aluno, nome do aluno e número de telefone celular. Desenhe o diagrama ER no modelo Chen-like, ligando as duas entidades. Nomeie seus relacionamentos. Escreva a gramática para o relacionamento entre as duas entidades.



### Exercício 5.4

Se tivermos duas entidades, um AVIÃO e um PILOTO, e descrevermos a relação entre as duas entidades como
> “UM PILOTO pilota um AVIÃO.” 
O que o relacionamento deve ler do lado da outra entidade?



### Exercício 5.5

Complete a metodologia adicionando dados de amostra às Figuras 5.3, 5.5 e aos Exercícios 5.1, 5.2, 5.3 e 5.4.



## ESTUDO DE CASO



### West Florida Mall \(continuação\)

No Capítulo 4, escolhemos nossa entidade primária, MALL, usamos inglês estruturado para descrevê-la, seus atributos e chaves, e mapeamos MALL para um banco de dados relacional \(com alguns dados de amostra\). Neste capítulo, continuamos a desenvolver este estudo de caso, analisando as etapas 3, 4 e 5 da metodologia de design ER. A etapa 3 diz:

+  ** *Etapa 3. Examine os atributos na entidade primária \(com assistência do usuário\) para descobrir se as informações sobre um dos atributos devem ser registradas.***  

Ao reexaminar os atributos da entidade primária MALL, parece que precisamos armazenar informações sobre o repositório de atributos. Então, olhamos para a etapa 3a, que diz

+  ** *Etapa 3a. Se forem necessárias informações sobre um atributo, transforme-o em uma entidade e prossiga para a etapa 3b.***  

Então, transformando o armazenamento de atributos em uma entidade, temos o seguinte \(repetindo o passo 2\):



### A Entidade

Este banco de dados registra dados sobre uma LOJA.

+ Para cada LOJA no banco de dados, registramos um nome de loja \(sname\), um número de loja \(snum\), um local de loja \(sloc\) e departamentos \(dept\).



### Os atributos para STORE

+ Para cada LOJA, haverá apenas um sname \(nome da loja\). O valor de sname não será subdividido. 
+ Para cada LOJA, haverá apenas um snum \(número da loja\). O valor de snum será único e não será subdividido. 
+ Para cada LOJA, registraremos um sloc \(local da loja\). Haverá um sloc registrado para cada LOJA. O valor de sloc não será subdividido. 
+ Para cada LOJA, registraremos o departamento \(departamentos\). Haverá mais de um departamento registrado para cada LOJA. O valor do departamento não será subdividido.



### As Chaves

Para cada STORE, assumiremos que o snum será único.

Observação: depois que STORE é transformado em uma entidade, o atributo store é removido da entidade MALL, conforme mostrado na Figura 5.8.
FIGURA 5.8 Diagrama ER do banco de dados do shopping até o momento. 
Tendo definido STORE, precisamos agora seguir o passo 3b, que diz

+  ** *Etapa 3b. Defina o relacionamento de volta à entidade original.***  

Existe um relacionamento, located\_in, entre STORE e MALL. Isso é mostrado na Figura 5.8.

A seguir, o passo 4 diz

+  ** *Passo 4. Se outra entidade for apropriada, desenhe a segunda entidade com seus atributos. Repita o passo 2 para ver se essa entidade deve ser dividida em mais entidades.***  

Selecionamos outra entidade, STORE\_MANAGER.

Agora, repetindo o passo 2 para STORE\_MANAGER:



### As Entidades

Este banco de dados registra dados sobre um STORE\_MANAGER.

+ Para cada STORE\_MANAGER no banco de dados, registramos o nome do gerente da loja \(sm\_name\), o número do Seguro Social do gerente da loja \(sm\_ssn\) e o salário do gerente da loja \(sm\_salary\).



### Os atributos para STORE\_MANAGER

+ Para cada STORE\_MANAGER, haverá apenas um sm\_name \(nome do gerente da loja\). O valor de sm\_name não será subdividido. 
+ Para cada GERENTE\_DE\_LOJA, haverá apenas um sm\_ssn \(número de previdência social do gerente da loja\). O valor do sm\_ssn será único e não será subdividido. 
+ Para cada GERENTE\_DE\_LOJA, registraremos um sm\_salary \(salário do gerente de loja\). Haverá apenas um sm\_salary registrado para cada GERENTE\_DE\_LOJA. O valor de sm\_salary não será subdividido.



### As Chaves

Para cada STORE\_MANAGER, assumiremos que o sm\_ssn será único. Definido o STORE\_MANAGER, seguimos agora o passo 5, que diz

+  ** *Etapa 5. Conecte entidades com relacionamentos, se houver relacionamentos.***  

Existe um relacionamento, manages, entre STORE e STORE\_MANAGER. Isso é mostrado na Figura 5.9.
FIGURA 5.9 Um diagrama ER do banco de dados do West Florida Mall em desenvolvimento. 
Em seguida, selecionamos nossa próxima entidade primária, PROPRIETÁRIO.

Agora, repetindo o passo 2 para OWNER:



### A Entidade

Este banco de dados registra dados sobre um PROPRIETÁRIO.

+ Para cada PROPRIETÁRIO no banco de dados, registramos o nome do proprietário da loja \(so\_name\), o número do Seguro Social do proprietário da loja \(so\_ssn\), o telefone do escritório do proprietário da loja \(so\_off\_phone\) e o endereço do proprietário da loja \(so\_address\).



### Os atributos do PROPRIETÁRIO

+ Para cada PROPRIETÁRIO, haverá apenas um so\_name \(nome do proprietário da loja\). O valor de so\_name não será subdividido. 
+ Para cada PROPRIETÁRIO, haverá apenas um so\_ssn \(número de previdência social do proprietário da loja\). O valor de so\_ssn será único e não será subdividido. 
+ Para cada PROPRIETÁRIO, haverá apenas um so\_off\_phone \(telefone do escritório do proprietário da loja\). O valor de so\_off\_phone será único e não será subdividido. 
+ Para cada PROPRIETÁRIO, registraremos um so\_address \(endereço do proprietário da loja\). Haverá apenas um so\_address registrado para cada PROPRIETÁRIO. O valor de so\_address não será subdividido.



### As Chaves

Para cada PROPRIETÁRIO, assumiremos que o so\_ssn será único. Definido o PROPRIETÁRIO, seguimos agora o passo 5, que diz:

+  ** *Etapa 5. Conecte entidades com relacionamentos, se houver relacionamentos.***  

Existe uma relação, "propriedade", entre LOJA e PROPRIETÁRIO. Isso é mostrado na Figura 5.10.
FIGURA 5.10 Um diagrama ER do West Florida Mall com quatro entidades.   


### Mapeamento para um banco de dados relacional

Após descrever as entidades, atributos e chaves, o próximo passo seria mapear para um banco de dados relacional. Também mostraremos alguns dados para as entidades desenvolvidas nesta parte do estudo de caso. \(Os mapeamentos dos relacionamentos são apresentados no final do Capítulo 6.\)



### Relação para a Entidade MALL

A relação da entidade MALL com alguns dados de amostra é mostrada na Tabela 5.1.
TABELA 5.1 Dados de amostra para MALL.   **nome**  **endereço**    
* * *
      `West Florida Mall`  `N Davis Hwy, Pensacola, FL`    `Cordova Mall`  `9th Avenue, Pensacola, FL`    `Navy Mall`  `Navy Blvd, Pensacola, FL`    `BelAir Mall`  `10th Avenue, Mobile, AL`     
Observe que não precisamos do mapeamento MALL-STORE apresentado no Capítulo 4, pois STORE mudou de um atributo multivalorado para uma entidade.



### Relação para a entidade STORE

A entidade STORE possui um atributo multivalor dept, então precisamos usar novamente a regra de mapeamento 4 para mapear essa entidade. Primeiro, mostraremos a relação com o atributo multivalor excised e, em seguida, mostraremos a relação com o atributo multivalor.

+ STORE \(com alguns dados de amostra\) é mostrado na Tabela 5.2. TABELA 5.2 Dados de amostra para STORE. slocsnamesnum
* * *
`Rm 101``Penneys``1``Rm 102``Sears``2``Rm 109``Dollar Store``3``Rm 110``Rex``4` 
+ A entidade STORE-DEPT \(usando a regra de mapeamento 1 e a regra de mapeamento 2\) com alguns dados de amostra é mostrada na Tabela 5.3. TABELA 5.3 Dados de amostra para STORE-DEPT. snumdept
* * *
`1``Tall men’s clothing``1``Women’s clothing``1``Children’s clothing``1``Men’s clothing`...`2``Men’s clothing``2``Women’s clothing``2``Children’s clothing`...



Dados de amostra para STORE MANAGER são mostrados na Tabela 5.4.
TABELA 5.4 Dados de amostra para GERENTE DE LOJA.   **sm\_ssn**  **sm\_nome**  **sm\_salário**    
* * *
      `234-87-0988`  `Saha`  `45,900`    `456-89-0987`  `Becker`  `43,989`    `928-82-9882`  `Ford`  `44,000`    `283-72-0927`  `Raja`  `38,988`      
+ A entidade OWNER \(usando a regra de mapeamento 1 e a regra de mapeamento 2\) com alguns dados de amostra é mostrada na Tabela 5.5. TABELA 5.5 Dados de amostra para OWNER. so\_ssnso\_nameso\_off\_phoneso\_address
* * *
`879-87-0987``Earp``(850)474-2093``1195 Gulf Breeze Pkwy, Pensacola, FL``826-89-0877``Sardar``(850)474-9873``109 Navy Blvd, Pensacola, FL``928-88-7654``Bagui``(850)474-9382``89 Highland Heights, Tampa, FL``982-76-8766``Bush``(850)474-9283``987 Middle Tree, Mobile, AL`

Até agora, nosso banco de dados relacional se desenvolveu no seguinte:
SHOPPING CENTER   * nome*   *endereço*     LOJA   *sloc*  *nome*  * snum*      Departamento de LOJA   * snum*   * departamento*      PROPRIETÁRIO   * então\_ssn*   *nome\_de\_esse*  *então\_off\_phone*  *então\_endereço*      GERENTE DE LOJA   * sm\_ssn*   *sm\_nome*  *sm\_salário*    
Este estudo de caso continua no final do próximo capítulo.



## BIBLIOGRAFIA

+ Elmasri, R., e Navathe, S.B. \(2016\). Fundamentos de Sistemas de Banco de Dados. Reading, MA: Addison-Wesley. 
+ Hoffer, J., Ramesh, V. e Topi, H. \(2022\). Gestão Moderna de Bancos de Dados. Nova York, NY: Pearson Education.





# 6 Ampliando relacionamentos/restrições estruturais



DOI: 10.1201/9781003314455-6



## 6.1 INTRODUÇÃO

Nos Capítulos 4 e 5, apresentamos alguns componentes dos diagramas entidade-relacionamento \(ER\): entidades, atributos e relacionamentos. Para a elicitação de requisitos, não basta definir relacionamentos sem também definir restrições estruturais — informações sobre como duas \(ou mais\) entidades se relacionam entre si. Existem dois tipos de restrições estruturais: cardinalidade e participação.

Neste capítulo, além das restrições estruturais dos relacionamentos, introduzimos uma gramática para descrever o que desenhamos. A gramática auxiliará no processo de elicitação de requisitos, pois especificaremos um modelo para o inglês que pode ser imposto a um diagrama, o que, por sua vez, nos fará dizer exatamente o que o diagrama significa. Este capítulo desenvolve as etapas 6 e 7 da metodologia de projeto ER. A etapa 6 declara a natureza de um relacionamento em inglês, e a etapa 7 discute a apresentação do banco de dados \(projetado até o momento\) ao usuário.

Regras de mapeamento para relacionamentos também são desenvolvidas e discutidas com exemplos e dados de amostra. Ao final do capítulo, continuamos o estudo de caso em andamento, iniciado no Capítulo 4 e continuado no Capítulo 5.



## 6.2 A RELAÇÃO DE CARDINALIDADE DE UM RELACIONAMENTO

Cardinalidade é uma medida aproximada do número de entidades \(uma ou mais\) relacionadas a outra entidade \(ou entidades\). Por exemplo, como mostrado na Figura 6.1, há quatro maneiras pelas quais as entidades AUTOMÓVEL e ESTUDANTE podem estar "numericamente envolvidas" em um relacionamento: um para um \(1:1\), muitos para um \(M:1\), um para muitos \(1:M\) e muitos para muitos \(M:N\). Os relacionamentos mais comuns são 1:M e M:N.
FIGURA 6.1A Relação Um-para-Um ALUNO:AUTOMÓVEL∷1:1  


### 6.2.1 Um para um \(1:1\)

No relacionamento do tipo um-para-um \(1:1\), uma entidade está associada a outra entidade e vice-versa. Por exemplo, se em nosso relacionamento de direção \(veja a Figura 6.2\), declarássemos que um automóvel é dirigido por um aluno e um aluno dirige um automóvel, então o relacionamento aluno/automóvel seria um-para-um, simbolicamente:
> ALUNO: AUTOMÓVEL∷1:1  FIGURA 6.2 Diagrama ER de um banco de dados ESTUDANTE-AUTOMÓVEL com um relacionamento de unidade nomeada e proporções de cardinalidade. 
Diagramaticamente, podemos representar um relacionamento 1:1, como mostrado na Figura 6.1A.



### 6.2.2 Muitos para um \(M:1\)

Se a relação SA \(ALUNO:AUTOMÓVEL\) \(mostrada na Figura 5.6\) fosse de muitos para um, estaríamos dizendo que muitos alunos estão associados a um automóvel e um automóvel está associado a muitos alunos; ou seja,
> ALUNO: AUTOMÓVEL∷M:1 
Usamos intencionalmente a locução verbal "está associado a" no lugar de "dirigir" aqui porque a afirmação "muitos alunos dirigem um automóvel" pode ser interpretada de várias maneiras. Além disso, usar um verbo específico para um relacionamento nem sempre é a melhor opção quando o diagrama é desenhado pela primeira vez, a menos que o analista tenha absoluta certeza de que o verbo descreve corretamente a intenção do usuário. Poderíamos também ter usado a locução verbal "está relacionado a" em vez de "está associado a" se quiséssemos ser imparciais quanto ao verbo exato a ser usado.

Vamos refinar a linguagem usada para descrever relacionamentos, mas o que implica um relacionamento ALUNO:AUTOMÓVEL∷M:1? Representaria uma situação em que talvez uma família possuísse um carro e esse carro fosse dirigido por várias pessoas da família.

Diagramaticamente, podemos representar um relacionamento M:1 como mostrado na Figura 6.1B.
FIGURA 6.1B Relacionamento Muitos-para-Um ALUNO:AUTOMÓVEL∷M:1   


### 6.2.3 Um para muitos \(1:M\)

Um relacionamento SA um-para-muitos \(ALUNO:AUTOMÓVEL\) \(mostrado na Figura 5.6\) implicaria que um aluno está associado a muitos automóveis e um automóvel está associado a um aluno. Se definirmos um relacionamento como 1:M \(ou M:1\), precisamos ser muito claros sobre qual entidade é 1 e qual é M. Aqui,
> ALUNO:AUTOMÓVEL∷1:M 
Diagramaticamente, podemos representar um relacionamento 1:M, como mostrado na Figura 6.1C.
FIGURA 6.1C Relacionamento Um-para-Muitos ALUNO:AUTOMÓVEL∷1:M   


### 6.2.4 Muitos para muitos \(M:N\)

Em relacionamentos muitos-para-muitos, muitas ocorrências de uma entidade estão associadas a muitas ocorrências da outra entidade. A relação muitos-para-muitos é representada como M:N, como em M de uma coisa relacionada a N de outra coisa.

Se nosso relacionamento SA fosse de muitos para muitos, um aluno estaria associado a muitos automóveis e um automóvel a muitos alunos:
> ALUNO:AUTOMÓVEL∷M:N 
Neste caso, se assumirmos SA = dirigir, como mostrado na Figura 5.6, vários alunos podem dirigir vários carros \(espera-se que nem todos dirijam ao mesmo tempo\) e vários carros podem ser dirigidos por vários alunos. Ou, um aluno pode dirigir vários carros, e um carro pode ser dirigido por vários alunos. Imagine, por exemplo, uma família com vários carros, e qualquer membro da família pode dirigir qualquer um dos carros, e qualquer carro pode ser dirigido por qualquer membro da família.

+ Diagramaticamente, podemos representar um relacionamento M:N, conforme mostrado na Figura 6.1D.FIGURA 6.1D Relacionamento Muitos-para-Muitos ALUNO:AUTOMÓVEL∷M:N

Ao expressar a cardinalidade, essa proporção x:x, onde x = 1 ou M ou N, é chamada de proporção de cardinalidade.

De que forma descrevemos a situação real para nossos alunos e automóveis? Esta é uma pergunta interessante. A resposta é que precisamos modelar a realidade conforme definida pelo nosso usuário. Ouvimos o usuário, fazemos algumas suposições e desenhamos o modelo. Em seguida, repassamos o modelo ao usuário usando um inglês estruturado, que o usuário então aprova ou corrige.

Uma armadilha no design de ER é tentar modelar todas as situações para todas as possibilidades. Isso não é possível. O objetivo da criação de um banco de dados normalmente é uma situação local governada pelo processo de análise de sistemas \(engenharia de software\). Na análise de sistemas clássica, o analista ouve o usuário, cria uma especificação e, em seguida, apresenta o resultado ao usuário. Aqui, o analista \(o analista/designer de banco de dados\) modela a realidade que o usuário vivencia — não a aparência que todos os bancos de dados do mundo deveriam ter. Se o usuário discordar, o analista pode facilmente modificar o modelo conceitual; mas é necessário que haja um consenso sobre o que o modelo deve representar.

Em nosso exemplo ALUNO:AUTOMÓVEL, a escolha que faremos é que um aluno está associado a \(dirige\) um automóvel. Embora seja claro que se possa pensar em exceções a este caso, adotaremos um modelo para escolher como identificaremos a relação entre as entidades, bem como as informações que pretendemos inserir nas próprias entidades. Tenha em mente que estamos lidando com um modelo conceitual que pode mudar dependendo da realidade da situação; no entanto, precisamos escolher algum tipo de modelo para começar, e o que estamos escolhendo é uma relação um-para-um entre alunos e automóveis.

No modelo do tipo Chen, descreveremos a unicidade desse relacionamento adicionando os números de cardinalidade às linhas no diagrama ER que conectam os relacionamentos e as entidades \(veja a Figura 6.2\).

Na Figura 6.2, colocamos um "1" na linha entre a caixa de entidade para o ALUNO e a caixa de losango para o relacionamento. Colocamos outro "1" na linha entre o relacionamento de losango e a caixa de entidade para o AUTOMÓVEL. Esses 1s significam, de forma geral, que um aluno está relacionado a um automóvel, e um automóvel está relacionado a um aluno. Devemos ser bastante cuidadosos ao dizer exatamente o que esse relacionamento significa. Isso não significa que um aluno possui um automóvel ou que um aluno paga seguro por um automóvel. Em nosso modelo, queremos dizer que um aluno dirigirá no máximo um automóvel em um campus universitário. Além disso, estamos dizendo que um automóvel será dirigido por um e apenas um aluno. Como estamos esclarecendo \(refinando\) o banco de dados, tentamos definir o nome do relacionamento para incluir o conceito que estamos modelando, dirigir, nomeando o relacionamento dirigir. Novamente, veja a Figura 6.2 para o modelo renomeado com cardinalidade 1:1.



## 6.3 PARTICIPAÇÃO: TOTAL/PARCIAL

É provável que em qualquer campus nem todos os alunos dirijam um automóvel. Para o nosso modelo, normalmente poderíamos assumir que todos os automóveis no campus estão associados a um aluno. \(Por enquanto, estamos excluindo professores e funcionários dirigindo, modelando apenas a relação aluno/automóvel.\)

Para mostrar que todo automóvel é dirigido por um aluno, mas nem todo aluno dirige um automóvel, aprimoramos nossos modelos de diagramas ER do tipo Chen, colocando uma linha dupla entre o relacionamento losango e a entidade AUTOMÓVEL para indicar que todo automóvel é dirigido por um aluno. Em outras palavras, todo automóvel no banco de dados participa do relacionamento. Do lado do aluno, deixamos a linha entre a entidade ALUNO e o relacionamento como uma única linha para indicar que nem todo aluno dirige um automóvel. Alguns alunos não participarão do relacionamento dirigir porque não dirigem um carro no campus. As linhas simples/duplas são chamadas de restrições de participação \(também conhecidas como restrições de opcionalidade\) e são representadas na Figura 6.3.
FIGURA 6.3 Um diagrama ER do banco de dados STUDENT-AUTOMOBILE com o relacionamento Unidade nomeada, taxas de cardinalidade e participação. 
A linha dupla indica participação total. Alguns designers preferem chamar essa participação de obrigatória. A questão é que, se parte de um relacionamento for obrigatória ou total, você não pode ter um valor nulo \(um valor ausente\) para esse atributo no relacionamento. No nosso caso, se um automóvel estiver no banco de dados, ele precisa estar relacionado a algum aluno.

A linha única, participação parcial, também é chamada de participação opcional. O sentido de participação parcial ou opcional é que pode haver alunos que não têm qualquer vínculo com um automóvel.

Ponto de verificação 6.1

1. O que são restrições estruturais? 
2. Que tipo de informação a razão de cardinalidade nos dá? 
3. De quantas maneiras diferentes duas entidades podem estar envolvidas em um relacionamento de cardinalidade? Dê exemplos. 
4. Que tipo de informação a restrição de participação nos fornece? 
5. É sempre necessário ter razões de cardinalidade, bem como restrições de participação, no mesmo diagrama ER? Por quê? Explique.



## 6.4 DESCRIÇÕES EM INGLÊS

Agora, aperfeiçoamos a gramática inglesa para descrever como um relacionamento afeta entidades usando nossas restrições estruturais e adotamos uma maneira padrão de declarar o relacionamento. A linguagem padrão deve aparecer no modelo, ou pelo menos junto com ele. Além disso, usar uma abordagem de linguagem padrão para descrever os diagramas ER nos permite não apenas fechar o ciclo com o usuário no processo de análise de sistemas, mas também facilitar o feedback e "definir" o significado exato do relacionamento.

No modelo Chen-like, as linhas duplas definem a participação plena, como em "Os automóveis participam plenamente da relação de condução". Melhor ainda, as linhas duplas nos convidam a definir a relação como:

+ Os automóveis devem ser conduzidos por um \(e somente um\) aluno.

O dever vem da participação plena \(obrigatória\) e o da cardinalidade.

A gramática para descrever o relacionamento parcial ou opcional da entidade ALUNO com a entidade AUTOMÓVEL seria:

+ Os alunos podem dirigir apenas um automóvel.

O "pode" vem da única linha que sai da caixa de entidade ALUNO, e o "um e somente um" vem da cardinalidade. A questão é que, ao expressar o sentido dos diagramas ER, utiliza-se a linguagem que transmite o que a relação realmente significa \(ou seja, um aluno pode dirigir um automóvel, e um automóvel deve ser dirigido por um e somente um aluno\). Um gráfico sobre como ler um diagrama ER é apresentado na Figura 6.4.
FIGURA 6.4 Banco de dados STUDENT-AUTOMOBILE: Traduzindo o diagrama para o inglês   


## 6.5 INGLÊS MAIS PRECISO

Recomendamos fortemente que cada diagrama seja acompanhado por uma frase em inglês para reforçar o significado da figura \(consulte a Figura 6.4\). O inglês costuma ser uma língua ambígua. A afirmação:

+ Os automóveis devem ser conduzidos por um e somente um aluno.

na verdade significa:

+ Os automóveis que constam no banco de dados devem ser conduzidos por um e somente um aluno.

O relacionamento não deve ser declarado de forma leviana, como em:

+ Um estudante dirige um automóvel.

Isso poderia ser interpretado vagamente.

Outra maneira de colocar isso é:

+ Cada automóvel deve ser conduzido por apenas um aluno. Os alunos podem conduzir apenas um automóvel.

Para aliviar a ambiguidade na declaração da relação, tomaremos a declaração em inglês da relação como ilustramos e definiremos quatro possibilidades de padrão para expressar nossa relação. Todas as relações binárias devem ser declaradas de duas maneiras, de ambos os lados. Como você verá, tentamos nos ater à correspondência exata do padrão nos exemplos a seguir, mas o bom senso e a gramática razoável devem prevalecer quando o padrão não se encaixa perfeitamente. Não há nada de errado em reafirmar a linguagem precisa para torná-la mais clara, mas você precisa dizer a mesma coisa.



### 6.5.1 Padrão 1—x:y∷k:1

Do lado k, participação plena \(k = 1 ou M\): Os x, registrados no banco de dados, devem estar relacionados a um e somente um y. Nenhum x está relacionado a mais de um y.

EXEMPLO 6.1 ALUNO:ORIENTADOR∷M:1, PARTICIPAÇÃO PLENA

+ Os alunos devem ser orientados por um orientador. 
+ ou, 
+ Os alunos registrados no banco de dados devem ser orientados por um único orientador. Nenhum aluno é orientado por mais de um orientador.

A frase, registrada no banco de dados, provou ser útil porque alguns projetistas de banco de dados tendem a generalizar além do problema em questão. Por exemplo, pode-se argumentar razoavelmente que pode haver um caso em que "tal e tal" são verdadeiros/não verdadeiros, mas a questão é: esse caso algum dia será encontrado neste banco de dados específico? A afirmação negativa costuma ser útil para solidificar o significado da relação.



### 6.5.2 Padrão 2—x:y∷k:1

Do lado k, participação parcial \(k = 1 ou M\): x, mas não necessariamente todos os x registrados no banco de dados, podem estar relacionados a um e apenas um y. Alguns x não estão relacionados a um y. Os x não podem estar relacionados a mais de um y.

EXEMPLO 6.2 ALUNO:FRATERNIDADE∷M:1

+ Alguns estudantes ingressam em uma fraternidade. 
+ que se torna: 
+ Os alunos, mas não necessariamente todos os alunos \(registrados no banco de dados\), podem ingressar em uma fraternidade. Alguns alunos podem não ingressar em uma fraternidade. Os alunos não podem ingressar em mais de uma fraternidade.



### 6.5.3 Padrão 3—x:y∷k:M

Do lado k, participação plena \(k = 1 ou M\): Os x, registrados no banco de dados, devem estar relacionados a muitos \(um ou mais\) y. Às vezes, é útil incluir uma frase como: "Nenhum x está relacionado a um não-y" ou "Não-x não estão relacionados a um y". A negativa dependerá do sentido da afirmação.

EXEMPLO 6.3 AUTOMÓVEL:ALUNO∷M:N

+ Automóveis são dirigidos por \(registrados em nome de\) muitos estudantes. 
+ que significa: 
+ Os automóveis, registrados em nosso banco de dados, devem ser dirigidos por muitos \(um ou mais\) alunos.

Há várias ideias implícitas aqui.

Primeiro, estamos falando apenas de veículos registrados nesta escola.

Em segundo lugar, neste banco de dados, apenas carros de estudantes são registrados.

Terceiro, se um automóvel deste banco de dados for conduzido, ele deverá ser registrado e conduzido por um estudante \(pelo menos um\).

Em quarto lugar, o “um ou mais” vem da restrição de cardinalidade.

Quinto, há uma forte tentação de dizer algo sobre o y, o lado M, voltando para o x. Isso deve ser evitado, pois já foi abordado em outro padrão e porque desencorajamos inferir outras relações a partir daquela abordada. Por exemplo, pode-se tentar dizer aqui que todos os alunos dirigem carros ou que todos os alunos têm parentesco com um veículo — e nenhuma das afirmações é verdadeira.



### 6.5.4 Padrão 4—x:y∷k:M

Do lado k, participação parcial \(k = 1 ou M\): x, mas não necessariamente todos os x \(registrados no banco de dados\), podem estar relacionados a muitos \(zero ou mais\) y. Alguns x podem não estar relacionados a um y.

EXEMPLO 6.4 CURSO:LIVRO∷K:M

+ Alguns cursos podem exigir \(usar\) muitos livros. 
+ que reformulado se torna: 
+ Os cursos, mas não necessariamente todos os cursos \(registrados no banco de dados\), podem usar muitos \(zero ou mais\) livros didáticos. Alguns cursos podem não exigir livros didáticos.

Observe que, devido à participação parcial \(as linhas únicas\), a frase "zero ou mais" é usada para cardinalidade. Se um relacionamento for modelado com os padrões que usamos e o inglês soar incorreto, pode ser que o modelo errado tenha sido escolhido. Geralmente, a expressão gramatical será mais útil para \(a\) reafirmar o banco de dados projetado para um "usuário ingênuo" e \(b\) verificar o significado do banco de dados projetado entre os projetistas. A versão completa do inglês pode eventualmente se mostrar cansativa para um projetista de banco de dados. No entanto, nunca se deve perder de vista o fato de que uma afirmação como "x estão relacionados a um y" pode ser interpretada de várias maneiras, a menos que seja reforçada com restrições declaradas de forma inequívoca. Além disso, uma declaração de negação pode ser útil para elicitar definições de requisitos, embora às vezes a negação seja tão complexa que possa ser omitida. O que estamos dizendo é para adicionar a gramática negativa ou outra gramática não contraditória se fizer sentido e ajudar na elicitação de requisitos. O perigo de adicionar frases é que podemos acabar com observações contraditórias ou confusas.



### 6.5.5 Resumo dos Padrões e Relacionamentos



#### 6.5.5.1 Padrão 1

O relacionamento é:
> x:y∷1\(completo\):1 
e é mostrado diagramaticamente pela Figura 6.5.
FIGURA 6.5 Modelo Chen de 1\(completo\):1 Relacionamento: Padrão 1.   


#### 6.5.5.2 Padrão 1

O relacionamento é:
> x:y∷M\(completo\):1 
e é mostrado diagramaticamente pela Figura 6.6.
FIGURA 6.6 Modelo Chen de M\(completo\):1 Relacionamento: Padrão 1. 
Esse padrão implica que uma instância de ENTITY1 deve participar de um relacionamento com ENTITY2 e só pode existir para uma \(e somente uma\) ENTITY2.



#### 6.5.5.3 Padrão 2

O relacionamento é:
> x:y∷1\(parcial\):1 
e é mostrado diagramaticamente pela Figura 6.7.
FIGURA 6.7 Modelo Chen de 1\(parcial\):1 Relacionamento: Padrão 2.   


#### 6.5.5.4 Padrão 2

O relacionamento é:
> x:y∷M\(parcial\):1 
e é mostrado diagramaticamente pela Figura 6.8.
FIGURA 6.8 Modelo Chen de M\(parcial\):1 Relacionamento: Padrão 2. 
Nesse padrão, algumas instâncias em ENTITY1 podem existir sem um relacionamento com ENTITY2; mas quando ENTITY1 está relacionada a ENTITY2, ela só pode estar relacionada a uma e somente uma das ENTITY2.



#### 6.5.5.5 Padrão 3

O relacionamento é:
> x:y∷1\(completo\):M 
e é mostrado diagramaticamente pela Figura 6.9.
FIGURA 6.9 Modelo Chen de 1\(completo\):M Relacionamento: Padrão 3.   


#### 6.5.5.6 Padrão 3

O relacionamento é:
> x:y∷M\(completo\):N 
e é mostrado diagramaticamente pela Figura 6.10.
FIGURA 6.10 Modelo Chen do relacionamento M\(completo\):N: Padrão 3. 
Esse padrão implica que uma instância de ENTITY1 deve participar de um relacionamento com ENTITY2 e pode existir por mais de uma instância de ENTITY2.



#### 6.5.5.7 Padrão 4

O relacionamento é:
> x:y∷1\(parcial\):M 
e é mostrado diagramaticamente pela Figura 6.11.
FIGURA 6.11 Modelo Chen de 1\(parcial\):M Relacionamento: Padrão 4.   


#### 6.5.5.8 Padrão 4

O relacionamento é:
> x:y∷M\(parcial\):N 
e é mostrado diagramaticamente pela Figura 6.12.
FIGURA 6.12 Modelo Chen do relacionamento M\(parcial\):N: Padrão 4. 
Nesse padrão, algumas instâncias em ENTITY1 podem existir sem um relacionamento com ENTITY2; mas quando ENTITY1 está relacionado a ENTITY2, ele pode estar relacionado a mais de uma ENTITY2.

Ponto de verificação 6.2

1. Esboce um diagrama ER mostrando as taxas de participação \(total/parcial\) e as cardinalidades para os seguintes itens: Os alunos devem ser orientados por um orientador, e um orientador pode orientar muitos alunos. Os alunos, mas não necessariamente todos os alunos, podem ingressar em uma fraternidade. Alguns alunos podem não ingressar em uma fraternidade. Os alunos não podem ingressar em mais de uma fraternidade. Uma fraternidade pode ter muitos alunos \(em seus membros\).

Nossa metodologia refinada agora pode ser reformulada com as informações de relacionamento adicionadas.



### 6.5.6 Metodologia de Projeto ER

+  ** *Etapa 1. Selecione uma entidade primária na descrição dos requisitos do banco de dados e mostre os atributos a serem registrados para essa entidade. Identifique as chaves, se apropriado, e mostre alguns dados de exemplo.***  
+  ** *Etapa 2. Use inglês estruturado para entidades, atributos e chaves para descrever o banco de dados obtido.***  
+  ** *Etapa 3. Examine os atributos na entidade primária \(possivelmente com assistência do usuário\) para descobrir se as informações sobre um dos atributos devem ser registradas.***  
+   ** *Etapa 3a. Se forem necessárias informações sobre um atributo, torne o atributo uma entidade e, em seguida,***  
+  ** *Etapa 3b. Defina o relacionamento de volta à entidade original.***  
+  ** *Passo 4. Se outra entidade for apropriada, desenhe a segunda entidade com seus atributos. Repita o passo 2 para ver se essa entidade deve ser dividida em mais entidades.***  
+  ** *Etapa 5. Conecte entidades com relacionamentos, se houver relacionamentos.***  
+  ** *Etapa 6. Indique a natureza exata dos relacionamentos no inglês estruturado de todos os lados; por exemplo, se um relacionamento é A:B∷1:M, então há um relacionamento de A\(1\) para B\(M\) e de B\(M\) de volta para A\(1\).***  
+  ** *Etapa 7. Apresente o banco de dados "como projetado" ao usuário, completo com os termos em inglês para entidades, atributos, chaves e relacionamentos. Refine o diagrama conforme necessário.***  
+  ** *Etapa 8. Mostre alguns dados de exemplo.***  



## 6.6 ALGUNS EXEMPLOS DE OUTROS RELACIONAMENTOS

Nesta seção, consideramos três outros exemplos de relacionamentos — dois relacionamentos 1:M e um relacionamento M:N — com mais detalhes para praticar e esclarecer melhor o processo que apresentamos. Como mencionado, os relacionamentos 1:M e M:N são comuns em um banco de dados.



### 6.6.1 Um exemplo do relacionamento um-para-muitos \(1:M\)

Relacionamentos 1:M ou M:1 são, na verdade, visões relativas do mesmo problema. Ao especificar 1:M ou M:1, precisamos ser especialmente cuidadosos ao especificar qual entidade é 1 e qual é M. A designação é qual visão é mais natural para o projetista do banco de dados. Como exemplo de um relacionamento 1 para M, considere dormitórios e alunos. Um dormitório pode ter muitos alunos morando nele, e muitos alunos podem morar em um dormitório. Portanto, o relacionamento entre dormitório e alunos seria considerado uma situação um-para-muitos \(1:M∷DORMITÓRIO:ALUNO\) e seria representado como na Figura 6.13 \(sem atributos\). Deixaremos que o termo DORMITÓRIO signifique dormitório.
FIGURA 6.13 Um diagrama ER \(sem atributos\) de um relacionamento 1:M. 
Na Figura 6.13 \(modelo semelhante ao de Chen\), o nome que escolhemos para o relacionamento DORMITÓRIO-ALUNO foi ocupar.

Observe que nem todos os dormitórios têm estudantes morando neles; portanto, a participação dos dormitórios no relacionamento é parcial. Informalmente:

+ Os dormitórios podem ser ocupados por muitos estudantes.

Além disso, nem todos os alunos podem residir em dormitórios, então a relação de ALUNO com DORMITÓRIO também é parcial:

+ Os alunos podem ocupar um dormitório.

Agora, vamos reafirmar os relacionamentos nas formas curta e longa do inglês.

A primeira afirmação, os dormitórios podem ser ocupados por muitos alunos, se encaixa no padrão 4, x:y∷1\(parcial\):M.



#### 6.6.1.1 Padrão 4–1:M, Do Lado 1, Participação Parcial
> “Alguns x estão relacionados a muitos y.” 
Portanto, a afirmação mais precisa é:

+ x, mas não necessariamente todos os x \(registrados no banco de dados\) podem estar relacionados a muitos \(zero ou mais\) y. Alguns x não estão relacionados a um y...

ou

+ Os dormitórios, mas não necessariamente todos os dormitórios \(registrados no banco de dados\), podem ser ocupados por muitos \(zero ou mais\) alunos.

Para a relação inversa:

+ Os alunos podem ocupar um dormitório.

Isso se encaixa no padrão 2, M\(parcial\):1.



#### 6.6.1.2 Padrão 2—M\(Parcial\):1, Do Lado M, Participação Opcional

+ “Alguns x’s estão relacionados a um y.”

Portanto, a longa “tradução” da afirmação é

+ x, mas não necessariamente todos os x \(registrados no banco de dados\), podem estar relacionados a um e somente um y. Alguns x podem não estar relacionados a y. \(Nenhum x está relacionado a mais de um y.\) \[.\] indica esclarecimento opcional.

Essa notação x e y se resolve em x = alunos, y = dormitórios e, portanto:

+ Os alunos, mas não necessariamente todos os alunos \(registrados no banco de dados\), podem ocupar apenas um dormitório. Alguns alunos podem não ocupar um dormitório. Nenhum aluno ocupa mais de um dormitório.

Ou dito de outra forma:

+ Um aluno pode ocupar um \(apenas um\) dormitório e um dormitório pode ser ocupado por muitos alunos.





### 6.6.2 Um exemplo de relacionamento muitos-para-um \(M:1\)

Para outro banco de dados, uma escola que estamos modelando possui estacionamentos para alunos, e cada aluno é designado a estacionar seu carro em um estacionamento específico. Temos uma entidade chamada ESTACIONAMENTO\_PARKING\_LOT que descreve os locais de estacionamento por meio de alguma notação descritiva, como Lote 7 Leste, Lote 28 Norte e assim por diante. Nesse caso, se considerássemos muitos automóveis atribuídos a um estacionamento e um estacionamento contendo muitos automóveis, poderíamos representar essa relação como uma relação de muitos para um, M:1∷AUTOMOBILE:PARKING\_LOT. Este diagrama é mostrado na Figura 6.14 \(novamente sem atributos\).
FIGURA 6.14 Um diagrama ER \(sem atributos\) de um relacionamento M:1. 
Descrevemos a participação do relacionamento entre AUTOMÓVEL e ESTACIONAMENTO como completa em ambos os casos, o que significa que todos os automóveis têm um estacionamento e todos os estacionamentos são atribuídos aos automóveis dos alunos.

As expressões gramaticais dessa relação são discutidas a seguir.



#### 6.6.2.1 Padrão 1—M:1, Do Lado M, Participação Plena

O x, registrado no banco de dados, deve estar relacionado a um e somente um y. Nenhum x está relacionado a mais de um y.

+ x = automóvel, y = estacionamento, relacionamento = parque 
+ Os automóveis registrados no banco de dados devem ser estacionados em apenas um estacionamento. Nenhum automóvel pode ser estacionado em mais de um estacionamento. Um automóvel deve ser estacionado em apenas um estacionamento.

O inverso é discutido a seguir.



#### 6.6.2.2 Padrão 3–1:M, Do Lado 1, Participação Plena

O x, registrado no banco de dados, deve estar relacionado a muitos \(um ou mais\) y's. \(Nenhum x está relacionado a um não-y" ou "Não-x's não estão relacionados a um y" — o negativo dependerá do sentido da afirmação.\)

+ Os estacionamentos, registrados no banco de dados, devem estacionar muitos \(um ou mais\) automóveis.

A negativa neste caso parece enganosa, então a omitiremos. A questão é que os estacionamentos registrados devem ter alunos estacionando lá.

Ou dito de outra forma:

+ Um automóvel deve ser estacionado em um \(único e somente um\) estacionamento, e um estacionamento deve ter pelo menos um automóvel estacionado nele \(e pode ter muitos automóveis estacionados nele\).



### 6.6.3 Um exemplo de relacionamento muitos-para-muitos \(M:N\)

O exemplo clássico da relação M:N que estudamos aqui são os alunos que fazem cursos. Inicialmente, sabemos que os alunos fazem \(se matriculam\) em muitos cursos e que qualquer curso é frequentado por muitos alunos. O diagrama básico da relação ALUNO-CURSO é mostrado na Figura 6.15.
FIGURA 6.15 Um diagrama ER \(sem atributos\) de um relacionamento M:N. 
Escolhemos a palavra "enroll" para representar a relação. A participação dos alunos em "enroll" é representada como "full" \(obrigatória\); a matrícula no curso é representada como "partial". Essa escolha foi arbitrária, pois ambas poderiam ser "full" ou "parcial", dependendo das necessidades e desejos do usuário. Observe atentamente as expressões gramaticais exatas e observe o impacto da escolha de "full" em um caso e "parcial" no outro. As expressões gramaticais dessa relação são discutidas a seguir.



#### 6.6.3.1 Padrão 3 — M:N, Do Lado M, Participação Plena

O x, registrado no banco de dados, deve estar relacionado a muitos \(um ou mais\) y. \(“Nenhum x está relacionado a um não-y” ou “Não-x não estão relacionados a um y” ou “Nenhum x não está relacionado a um y” — a negativa dependerá do sentido da afirmação.\)

+ x = alunos, y = cursos, relacionamento = matrícula 
+ Os alunos registrados no banco de dados devem estar matriculados em muitos \(um ou mais\) cursos.

O inverso é explicado a seguir.



#### 6.6.3.2 Padrão 4—N:M, Do Lado N, Participação Parcial

O x, mas não necessariamente todo x \(registrado no banco de dados\), pode estar relacionado a muitos \(um ou mais\) y. Alguns x podem não estar relacionados a y.

+ x = curso, y = aluno, relacionamento = matricular 
+ Os cursos, mas não necessariamente todos os cursos \(registrados no banco de dados\), podem matricular muitos \(um ou mais\) alunos. Alguns cursos podem não matricular alunos.

Ou dito de outra forma:

+ Um aluno deve se matricular em um ou mais cursos, e um curso pode ter um ou mais alunos matriculados nele.

Essa "parcialidade do curso" provavelmente reflete cursos no banco de dados, mas sem alunos matriculados no momento. Isso pode significar cursos em potencial ou cursos que não são mais oferecidos. Obviamente, se o curso estiver no banco de dados apenas se os alunos estiverem matriculados, a restrição de participação se torna completa — e o sentido da entidade-relacionamento muda.

Além disso, este banco de dados nos diz que, embora possamos ter cursos sem alunos, armazenamos apenas informações sobre alunos ativos. Obviamente, poderíamos tornar a conexão entre alunos parcial e, portanto, armazenar todos os alunos — mesmo os inativos. Optamos por representar os relacionamentos dessa maneira para enfatizar que a restrição de participação deve representar a realidade — a realidade sobre a qual o usuário pode querer armazenar dados.

Observe que todos os exemplos neste capítulo tratam de apenas duas entidades, ou seja, são relacionamentos binários. O exemplo na seção a seguir também é outro exemplo de relacionamento binário.

Ponto de verificação 6.3

1. Dê um exemplo de uma relação 1\(completo\):1. Essa relação precisa ser sempre obrigatória? Explique com exemplos. 
2. Dê um exemplo de uma relação 1\(parcial\):1. Essa relação sempre precisa ser opcional? Explique com exemplos. 
3. Dê um exemplo de uma relação M\(completo\):N. Essa relação seria sempre opcional ou obrigatória? Explique com exemplos. 
4. Dê um exemplo de uma relação M\(parcial\):N. Essa relação seria sempre opcional ou obrigatória? Explique com exemplos.



## 6.7 UM EXEMPLO FINAL

Como exemplo final para concluir o capítulo, apresentamos mais um problema e, em seguida, nossa metodologia. 1 Considere um modelo para um aeroporto simplificado onde PASSAGEIROS e VOOS devem ser registrados. Suponha que os atributos de PASSAGEIRO sejam nome, bagagens e número de passageiro frequente. Suponha que os atributos de VOO sejam número do voo, destino, horário de chegada e horário de partida. Desenhe o diagrama ER.

Observação: estamos omitindo muitos atributos que poderíamos considerar. Suponha que essas sejam todas as informações que escolhemos registrar.

A solução é dada a seguir.



### 6.7.1 Metodologia de Projeto ER

+  ** *Etapa 1. Selecione uma entidade primária na descrição dos requisitos do banco de dados e mostre os atributos a serem registrados para essa entidade. Identifique as chaves, se apropriado, e mostre alguns dados de exemplo.***  

Suponha que escolhemos PASSAGEIRO como nossa entidade primária. PASSAGEIRO tem os seguintes atributos: número\_de\_passageiro\_frequente, nome \[nome, nome do meio, sobrenome\], peças\_de\_bagagem.

Desenhamos esta parte do diagrama, escolhendo frequent\_flier\_no como chave e anotando o nome do atributo composto. Este diagrama é mostrado na Figura 6.16.
FIGURA 6.16 Diagrama de entidade PASSENGER.  
+  ** *Etapa 2. Use inglês estruturado para entidades, atributos e chaves para descrever o banco de dados obtido.***  



#### 6.7.1.1 A Entidade

Este banco de dados registra dados sobre PASSAGEIROS. Para cada passageiro, registramos número\_de\_passageiro\_frequente, nome \[nome, nome do meio, sobrenome\], peças\_de\_bagagem \(bagagem-peças\).



##### 6.7.1.1.1 Os Atributos

Para atributos atômicos, att\(j\):

+ Para cada PASSAGEIRO, haverá apenas um frequent\_flier\_no. O valor de frequent\_flier\_no não será subdividido. 
+ Para cada PASSAGEIRO, haverá apenas uma e única gravação de bagagens. O valor das bagagens não será subdividido.

Para atributos compostos, att\(j\):

+ Para cada PASSAGEIRO, registraremos seu nome, que é composto de nome, nome do meio e sobrenome. Nome, nome do meio e sobrenome são as partes componentes do nome.



##### 6.7.1.1.2 As Chaves

+ Para cada PASSAGEIRO, teremos a seguinte chave primária: frequent\_flier\_no.

Observe que escolhemos frequent\_flier\_no como chave primária para PASSAGEIRO. Se isso não fosse verdade, outro meio de identificação única seria necessário. Aqui, estas são todas as informações que nos são fornecidas.

+  ** *Etapa 3. Examine os atributos na entidade primária \(possivelmente com assistência do usuário\) para descobrir se as informações sobre um dos atributos devem ser registradas.***  

Nenhuma informação adicional é sugerida.

+  ** *Passo 4. Se outra entidade for apropriada, desenhe a segunda entidade com seus atributos. Repita o passo 2 para ver se essa entidade deve ser dividida em mais entidades.***  

A outra entidade neste problema é o VOO, com atributos flight\_no, destination, depart\_time, arrive\_time.

Novamente, usamos inglês estruturado como no exemplo a seguir.



#### 6.7.1.2 A Entidade

Este banco de dados registra dados sobre voos. Para cada voo, registramos o número do voo, o destino, o horário de partida e o horário de chegada.



##### 6.7.1.2.1 Os Atributos

Para atributos atômicos, att\(j\):

+ Para cada VOO, haverá apenas um flight\_no. O valor de flight\_no não será subdividido. 
+ Para cada VOO, haverá apenas uma e única gravação de destino. O valor por destino não será subdividido. 
+ Para cada VOO, haverá apenas uma gravação de depart\_time. O valor de depart\_time não será subdividido. 
+ Para cada VOO, haverá apenas uma gravação de arrive\_time. O valor de arrive\_time não será subdividido.



##### 6.7.1.2.2 As Chaves

Para a\(s\) chave\(s\): Uma chave candidata \(entidade forte\):
> Para cada VOO, teremos a seguinte chave primária: flight\_no. 
Estamos assumindo que flight\_no é único.

+  ** *Etapa 5. Conecte entidades com relacionamentos, se houver relacionamentos.***  

Que relação existe entre voos e passageiros?

Todos os passageiros voarão em um único voo. Todos os voos terão vários passageiros. O diagrama para este problema é ilustrado nas Figuras 6.17 e 6.18.
FIGURA 6.17 Diagrama ER para banco de dados PASSENGER-FLIGHT.   FIGURA 6.18 Problema de amostra — Apresentação alternativa de atributos com explicação e dados de amostra. 
Observe que, mais uma vez, fizemos uma escolha: representaremos um voo por passageiro neste banco de dados. As especificações não nos dizem se deve ser 1 ou M, então escolhemos 1. Também escolhemos a participação total de ambos os lados. Pareceria ilógico registrar dados sobre passageiros que não voaram em um voo e voos para os quais não havia passageiros. Mas, novamente, se o banco de dados exigisse o armazenamento de informações sobre passageiros em potencial que talvez não reservassem um voo específico ou voos sem passageiros, teríamos que alterar o design conceitual. A Figura 6.17 é adequada para exibir apenas as entidades e os atributos. A Figura 6.18 usa a forma concisa de descrever atributos e inclui algumas das etapas anteriores e alguns dados de amostra. Para a conceituação, a Figura 6.17 pode ser usada e posteriormente convertida para o estilo da Figura 6.18 para documentação. Ambas as figuras requerem acompanhamento de inglês estruturado \(etapa 6\).

Como designers, fazemos uma escolha e a apresentamos ao usuário. Se o usuário decidisse armazenar informações sobre todos os voos e passageiros ao longo de um período, esse seria um banco de dados diferente \(uma relação M:N e talvez participações parciais para voos sem passageiros e passageiros sem voo\). A questão é que, em última análise, essa é uma escolha do usuário, e neste ponto estamos tentando gerar um modelo para apresentar ao usuário para validação.

+  ** *Etapa 6. Indique a natureza exata dos relacionamentos no inglês estruturado de todos os lados, como, por exemplo, se um relacionamento é A:B∷1:M, então há um relacionamento de A\(1\) para B\(M\) e de B\(M\) de volta para A\(1\).***  



### 6.7.2 Padrão 1—M:1, Do Lado M, Participação Plena

O x, registrado no banco de dados, deve estar relacionado a um e somente um y. Nenhum x está relacionado a mais de um y.

+ x = passageiro, y = voo, relacionamento = voar 
+ Os passageiros registrados no banco de dados devem voar em apenas um voo. Nenhum passageiro pode voar em mais de um voo.



### 6.7.3 Padrão 3–1:M, Do Lado 1, Participação Plena

O x, registrado no banco de dados, deve estar relacionado a muitos \(um ou mais\) y’s.

+ x = voo, y = passageiro, relacionamento = voo 
+ Os voos registrados no banco de dados devem transportar muitos \(um ou mais\) passageiros.

Ou, dito de outra forma:
> Um passageiro deve voar em um voo, e um voo deve ter pelo menos um \(e pode ter muitos\) passageiros. 
As descrições de atributos seguem padrões anteriores e são deixadas para os exercícios.

+  ** *Etapa 7. Apresente o banco de dados "como projetado" ao usuário, completo com os termos em inglês para entidades, atributos, chaves e relacionamentos. Refine o diagrama, conforme necessário.***  
+  ** *Etapa 8. Mostre alguns dados de exemplo.***  

Veja Figura 6.18.



## 6.8 MAPEANDO RELACIONAMENTOS COM UM BANCO DE DADOS RELACIONAL

Nesta seção, continuamos com as regras de mapeamento que iniciamos no final do Capítulo 4. No Capítulo 4, aprendemos como mapear entidades — entidades com atributos compostos e entidades com atributos multivalorados. Neste capítulo, tendo abordado as restrições estruturais dos relacionamentos, aprendemos como mapear relacionamentos.



### 6.8.1 Mapeando relacionamentos binários M:N

Para mapear relacionamentos binários M:N, apresentamos a regra de mapeamento 5.

+ Regra de mapeamento 5 — Mapeando relacionamentos binários M:N. Para cada relacionamento M:N, crie uma nova tabela \(relação\) com as chaves primárias de cada uma das duas entidades \(entidades proprietárias\) relacionadas no relacionamento M:N. A chave primária dessa nova tabela será a concatenação das chaves das entidades proprietárias. Inclua quaisquer atributos que o relacionamento M:N possa ter nessa nova tabela.

Por exemplo, consulte a Figura 6.15. Se as tabelas ALUNO e CURSO contiverem os dados mostrados nas Tabelas 6.1 e 6.2.
TABELA 6.1 Dados de amostra para a tabela ALUNO na Figura 6.15.   **nome.primeiro**  **nome.sobrenome**  **nome.mi**  **número\_do\_aluno**  **endereço**    
* * *
      `Richard`  `Earp`  `w`  `589`  `222 2nd St`    `Boris`  `Backer`   `909`  `333 Dreistrasse`    `Helga`  `Hog an`  `H`  `384`  `88 Half Moon Ave`    `Arpan`  `Bagui`  `K`  `876`  `33 Bloom Ave`    `Hema`  `Malini`   `505`  `100 Livingstone`      TABELA 6.2 Dados de amostra para a tabela COURSE na Figura 6.15.   **cname**  **c\_número**  **horas\_de\_crédito**    
* * *
      `Database`  `COP4710`  `4`    `Visual Basic`  `CGS3464`  `3`    `Elements of Stats`  `STA3023`  `3`    `Indian History`  `HIST2022`  `4`     
Antes de executar a regra de mapeamento 5, é necessário garantir que as chaves primárias das entidades envolvidas tenham sido estabelecidas. Se c\_number e student\_number forem as chaves primárias de COURSE e STUDENT, respectivamente, para mapear o relacionamento M:N, criamos um relacionamento chamado ENROLL, conforme mostrado na Tabela 6.3.
TABELA 6.3 Dados de amostra para ENROLL na Figura 6.15.   **c\_número**  **número\_do\_aluno**    
* * *
      `COP4710`  `589`    `CGS3464`  `589`    `CGS3464`  `909`    `STA3023`  `589`    `HIST2022`  `384`    `STA3023`  `505`    `STA3023`  `876`    `HIST2022`  `876`    `HIST2022`  `505`     
Tanto c\_number quanto student\_number juntos são a chave primária da relação ENROLL.

O mapeamento relacional da Figura 6.15 seria o seguinte:

+ ALUNO\(nome.primeiro, nome.sobrenome, nome.mi, número\_aluno, endereço\) 
+ CURSO \(cname, c\_number, créditos\_horas\) 
+ MATRÍCULA\(c\_número, número\_aluno\)

O que frequentemente acontece em relacionamentos M:N é que surgem dados que se encaixam melhor com o relacionamento do que com qualquer uma das entidades. Os atributos de relacionamento são abordados no Capítulo 8, mas caso surja um atributo de relacionamento, ele será mapeado com as chaves primárias.



### 6.8.2 Mapeando relacionamentos binários 1:1

Para mapear um relacionamento binário 1:1, inclua a chave primária de ENTITYA em ENTITYB como chave estrangeira. A questão é: qual é ENTITYA e qual é ENTITYB? Essa pergunta é respondida nas regras de mapeamento apresentadas nesta seção.

+ Regra de mapeamento 6 — Mapeamento de um relacionamento binário 1:1 quando um lado do relacionamento tem participação total e o outro tem participação parcial. Quando um dos lados do relacionamento tem participação total e o outro tem participação parcial, armazene a chave primária do lado com a restrição de participação parcial no lado com a restrição de participação total como uma chave estrangeira. Inclua quaisquer atributos do relacionamento no mesmo lado ao qual a chave foi adicionada. \(Abordamos os atributos dos relacionamentos no Capítulo 8 e, em seguida, aprimoramos as regras de mapeamento de acordo.\)

Por exemplo, consulte a Figura 6.3. Ela diz:

+ Um automóvel, registrado no banco de dados, deve ser conduzido por um e somente um aluno.

e

+ Um aluno pode dirigir apenas um automóvel.

Aqui, a participação total é do lado do AUTOMÓVEL, já que “Um automóvel ‘deve’ ser conduzido por um aluno”.

Portanto, pegamos a chave primária do lado da restrição de participação parcial, ALUNO, e a incluímos na tabela AUTOMÓVEL. A chave primária de ALUNO é número\_do\_aluno, portanto, ela será incluída na relação AUTOMÓVEL como chave estrangeira. Uma implementação de banco de dados relacional do diagrama ER na Figura 6.3 terá a seguinte aparência:

+ AUTOMÓVEL\(id\_veículo, marca, estilo\_carroceria, cor, ano, número\_aluno\) 
+ ALUNO\(nome.primeiro, nome.sobrenome, nome.mi, número\_aluno, endereço\)

e com alguns dados, ficaria parecido com as Tabelas 6.4 e 6.5.
TABELA 6.4 Dados de amostra para AUTOMÓVEL na Figura 6.3.   **id\_do\_veículo**  **fazer**  **estilo corporal**  **cor**  **ano**  **número\_do\_aluno**    
* * *
      `A39583`  `Ford`  `Compact`  `Blue`  `1999`  `589`    `B83974`  `Chevy`  `Compact`  `Red`  `1989`  `909`    `E98722`  `Mazda`  `Van`  `Green`  `2002`  `876`    `F77665`  `Ford`  `Compact`  `White`  `1998`  `384`      TABELA 6.5 Dados de amostra para ALUNO na Figura 6.3.   **nome.primeiro**  **nome.sobrenome**  **nome.mi**  **número\_do\_aluno**  **endereço**    
* * *
      `Richard`  `Earp`  `W`  `589`  `222 2nd St`    `Boris`  `Backer`   `909`  `333 Dreistrasse`    `Helga`  `Hog an`  `H`  `384`  `8 8 Half Moon Ave`    `Arpan`  `Bagui`  `K`  `876`  `33 Bloom Ave`    `Hema`  `Malini`   `505`  `100 Livingstone`     


Como ALUNO tem um atributo multivalorado escola, precisamos mapear o atributo multivalorado para sua própria tabela \(conforme regra de mapeamento 4, mapeamento de atributos multivalorados\), conforme mostrado na Tabela 6.6.
TABELA 6.6 Dados de amostra para atributo multivalorado na Figura 6.3.   **número\_do\_aluno**  **escola**    
* * *
      `589`  `St. Helens`    `589`  `Mountain`    `589`  `Volcano`    `909`  `Manatee U`    `909`  `Everglades High`    `384`  `PCA`    `384`  `Pensacola High`    `876`  `UWF`    `505`  `Cuttington`    `505`  `UT`     
Nesse caso, se o relacionamento tivesse algum atributo, ele seria incluído no relacionamento AUTOMÓVEL, pois era lá que a chave estava.

+  ** *Regra de mapeamento 7 — Mapeamento de um relacionamento binário 1:1 quando ambos os lados têm restrições de participação parcial.***  

Quando ambos os lados têm restrições de participação parcial em um relacionamento binário 1:1, os relacionamentos podem ser mapeados de duas maneiras. Para a primeira opção:

+ Regra de mapeamento 7A. Selecione uma das relações para armazenar a chave da outra \(e conviver com alguns valores nulos\).

Novamente, consulte a Figura 6.2. As restrições de participação são parciais de ambos os lados \(e vamos supor que, por enquanto, não haja nenhum atributo escolar\). Então, a Figura 6.2 seria:

+ Um automóvel pode ser conduzido por apenas um aluno.

e

+ Um aluno pode dirigir apenas um automóvel.

Uma realização relacional poderia ser a seguinte: O vehicle\_id \(chave primária de AUTOMOBILE\) deve ser armazenado em STUDENT da seguinte forma:

+ AUTOMÓVEL\(id\_veículo, marca, estilo\_carroceria, cor, ano\) 
+ ALUNO\(nome.primeiro, nome.sobrenome, nome.mi, número\_do\_aluno, endereço, id\_do\_veículo\)

e com alguns dados de amostra, conforme mostrado nas Tabelas 6.7 e 6.8.
TABELA 6.7 Dados de amostra para AUTOMÓVEL na Figura 6.2.   **id\_do\_veículo**  **fazer**  **estilo corporal**  **cor**  **ano**    
* * *
      `A39583`  `Ford`  `Compact`  `Blue`  `1999`    `B83974`  `Chevy`  `Compact`  `Red`  `1989`    `E98722`  `Mazda`  `Van`  `Green`  `2002`    `F77665`  `Ford`  `Compact`  `White`  `1998`    `G99999`  `Chevy`  `Van`  `Grey`  `1989`      TABELA 6.8 Dados de amostra para ALUNO na Figura 6.2.   **nome.primeiro**  **nome.sobrenome**  **nome.mi**  **número do aluno**  **endereço**  **id\_do\_veículo**    
* * *
      `Richard`  `Earp`  `W`  `589`  `222 2nd St.`  `A39583`    `Boris`  `Backer`   `909`  `333 Dreistrasse`  `B83974`    `Helga`  `Hog an`  `H`  `384`  `88 Half Moon Ave.`  `F77665`    `Arpan`  `Bagui`  `K`  `876`  `33 Bloom Ave`  `E98722`    `Hema`  `Malini`   `505`  `100 Livingstone`      
Na relação ALUNO, vehicle\_id é uma chave estrangeira.

Para a segunda opção:

+ Regra de mapeamento 7B. Dependendo da semântica da situação, você pode criar uma nova relação para abrigar o relacionamento e conter a chave das duas entidades relacionadas \(como é feito na regra de mapeamento 5\). Nesse caso, se houvesse valores nulos, eles seriam excluídos da tabela de ligação.

Ilustramos o mapeamento da Figura 6.2 usando esta regra. A realização relacional seria

+ AUTOMÓVEL\(id\_veículo, marca, estilo\_carroceria, cor, ano\) 
+ ALUNO\(nome.primeiro, nome.sobrenome, nome.mi, número\_aluno, endereço\) 
+ ESTUDANTE-AUTOMÓVEL\(id\_veículo, número\_aluno\)

e com alguns dados conforme mostrado na Tabela 6.9.
TABELA 6.9 Dados de amostra para representação alternativa de ESTUDANTE-AUTOMÓVEL na Figura 6.2.   **id\_do\_veículo**  **número\_do\_aluno**    
* * *
      `A39583`  `589`    `B83974`  `909`    `E98722`  `876`    `F77665`  `384`     
Neste caso, as duas relações, ALUNO e AUTOMÓVEL, permaneceriam conforme mostrado nas Tabelas 6.10 e 6.11.
TABELA 6.10 Dados de amostra para representação alternativa de ALUNO na Figura 6.2.   **nome.primeiro**  **nome.sobrenome**  **nome.mi**  **número do aluno**  **endereço**    
* * *
      `Richard`  `Earp`  `W`  `589`  `222 2nd St`    `Boris`  `Backer`   `909`  `333 Dreistrasse`    `Helga`  `Hog an`  `H`  `384`  `8 8 Half Moon Ave`    `Arpan`  `Bagui`  `K`  `876`  `33 Bloom Ave`    `Hema`  `Malini`   `505`  `100 Livingstone`      TABELA 6.11 Dados de amostra para representação alternativa de AUTOMÓVEL na Figura 6.2.   **id\_do\_veículo**  **fazer**  **estilo corporal**  **cor**  **ano**    
* * *
      `A39583`  `Ford`  `Compact`  `Blue`  `1999`    `B83974`  `Chevy`  `Compact`  `Red`  `1989`    `E98722`  `Mazda`  `Van`  `Green`  `2002`    `F77665`  `Ford`  `Compact`  `White`  `1998`    `G99999`  `Chevy`  `Van`  `Grey`  `1989`      
+ Regra de mapeamento 8 — Mapeamento de um relacionamento binário 1:1 quando ambos os lados têm restrições de participação total. Use a semântica do relacionamento para selecionar qual dos relacionamentos deve conter a chave do outro. Se essa escolha não for clara, use a regra de mapeamento 7B.

Agora, assumindo participação total em ambos os lados da Figura 6.2, as duas tabelas ALUNO e AUTOMÓVEL poderiam ser:

+ ALUNO\(nome.primeiro, nome.sobrenome, nome.mi, número\_aluno, endereço\) 
+ AUTOMÓVEL\(id\_veículo, marca, estilo\_carroceria, cor, ano, número\_aluno\)

e com alguns dados de amostra, conforme mostrado nas Tabelas 6.12 e 6.13,
TABELA 6.12 Dados de amostra para a Figura 6.2 com participação total de ambos os lados: Tabela ALUNO.   **nome.primeiro**  **nome.sobrenome**  **nome.mi**  **número\_do\_aluno**  **endereço**    
* * *
      `Richard`  `Earp`  `W`  `589`  `222 2nd St`    `Boris`  `Backer`   `909`  `333 Dreistrasse`    `Helga`  `Hogan`  `H`  `384`  `88 Half Moon Ave`    `Arpan`  `Bagui`  `K`  `876`  `33 Bloom Ave`    `Hema`  `Malini`   `505`  `100 Livingstone`      TABELA 6.13 Dados de amostra para a Figura 6.2 com participação total de ambos os lados: Tabela AUTOMÓVEL.   **id\_do\_veículo**  **fazer**  **estilo corporal**  **cor**  **ano**  **número\_do\_aluno**    
* * *
      `A39583`  `Ford`  `Compact`  `Blue`  `1999`  `589`    `B83974`  `Chevy`  `Compact`  `Red`  `1989`  `909`    `E98722`  `Mazda`  `Van`  `Green`  `2002`  `876`    `F77665`  `Ford`  `Compact`  `White`  `1998`  `384`    `G99999`  `Chevy`  `Van`  `Grey`  `1989`  `505`     
Neste caso, student\_number foi incluído em AUTOMOBILE, tornando student\_number uma chave estrangeira em AUTOMOBILE. Poderíamos também ter obtido a chave primária, vehicle\_id, de AUTOMOBILE e incluído na tabela STUDENT. Mas seria inadequado incluir chaves estrangeiras em ambas as tabelas, pois isso introduziria redundância no banco de dados.



### 6.8.3 Mapeando relacionamentos binários 1:N

Em seguida, desenvolvemos regras de mapeamento para mapear relacionamentos binários 1:N. Esses mapeamentos dependerão do tipo de restrição de participação que o lado N do relacionamento possui.

+ Regra de mapeamento 9 — Mapeamento de relacionamentos binários 1:N quando o lado N tem participação total. Inclua a chave da entidade no lado 1 do relacionamento como uma chave estrangeira no lado N.

Por exemplo, na Figura 6.13, se assumirmos a participação plena do lado do aluno, teremos

+ Os dormitórios podem ter zero ou mais alunos.

e

+ Os alunos devem morar em apenas um dormitório.

O "lado 1" é DORM; o "lado N" é STUDENT. Portanto, uma referência a DORM \(dname, a chave de DORM\) está incluída em STUDENT.
TABELA 6.14 Dados de amostra para ALUNO na Figura 6.13.   **nome.primeiro**  **nome.sobrenome**  **nome.mi**  **número\_do\_aluno**  **nome do domínio**    
* * *
      `Richard`  `Earp`  `W`  `589`  `A`    `Boris`  `Backer`   `909`  `C`    `Helga`  `Hogan`  `H`  `384`  `A`    `Arpan`  `Bagui`  `K`  `876`  `A`    `Hema`  `Malini`   `505`  `B`      TABELA 6.15 Dados de amostra para DORM na Figura 6.13.   **nome do domínio**  **supervisor**    
* * *
      `A`  `Saunders`    `B`  `Backer`    `C`  `Hogan`    `D`  `Eisenhower`     
E, se tivéssemos os seguintes dados de amostra, conforme mostrado nas Tabelas 6.14 e 6.15, o mapeamento relacional seria

+ ALUNO\(nome.primeiro, nome.sobrenome, nome.mi, numero\_aluno, dnome\) 
+ DORM\(nome, supervisor\)

+ Regra de mapeamento 10 — Mapeamento de relacionamentos binários 1:N quando o lado N tem participação parcial. Essa situação seria tratada como um relacionamento binário M:N, com uma tabela separada para o relacionamento. A chave do novo relacionamento consistiria em uma concatenação das chaves das entidades relacionadas. Inclua quaisquer atributos do relacionamento nesta nova tabela.

Ponto de verificação 6.4

1. Indique a\(s\) regra\(s\) de mapeamento que seriam usadas para mapear a Figura 6.14. Mapeie a Figura 6.14 para um banco de dados relacional e mostre alguns dados de exemplo. 
2. Indique a\(s\) regra\(s\) de mapeamento que seriam usadas para mapear a Figura 6.17. Mapeie a Figura 6.17 para um banco de dados relacional e mostre alguns dados de exemplo.





## 6.9 RESUMO DO CAPÍTULO

Este capítulo discutiu as razões de cardinalidade e participação em diagramas ER. Diversos exemplos e diagramas de relacionamentos binários com restrições estruturais \(desenvolvidos no modelo do tipo Chen\) foram discutidos. Uma gramática mais precisa do inglês foi apresentada para cada um dos diagramas, e as etapas 7 e 8 da metodologia de projeto ER foram definidas. A seção final do capítulo discutiu o mapeamento de relacionamentos. À medida que nosso modelo se torna mais complexo, revisitaremos as regras de mapeamento para acomodar essa complexidade em capítulos subsequentes.





## CAPÍTULO 6 EXERCÍCIOS



### Exercício 6.1

Vamos reconsiderar nosso exemplo de aluno no Exercício 5.2, no qual os únicos atributos de aluno são student\_number e name. Agora temos outra entidade chamada HIGH SCHOOL, que será a escola de ensino médio na qual o aluno se formou. Para a entidade HIGH SCHOOL, registraremos o nome da escola e a localização \(ou seja, cidade e estado\). Desenhe o diagrama ER usando o modelo Chen-like. Siga a metodologia e inclua todas as descrições em inglês dos seus diagramas. Mapeie o diagrama ER para um banco de dados relacional.



### Exercício 6.2

Suponha que uma faculdade tenha um dormitório com vários quartos. A entidade dormitório, que é uma entidade DORMITÓRIO, visto que há apenas um dormitório, possui os atributos número do quarto e individual/duplo \(ou seja, quartos individuais e duplos\). Suponhamos que a entidade ALUNO, neste caso, contenha os atributos número do aluno, nome do aluno e telefone residencial. Desenhe o diagrama ER usando o modelo Chen-like. Siga a metodologia e inclua todas as descrições em inglês do seu diagrama. Mapeie o diagrama ER para um banco de dados relacional.



### Exercício 6.3

Considere um banco de dados de ALUNOS com alunos e organizações do campus. Alunos terão os atributos número e nome do aluno. ORGANIZAÇÕES terão os atributos nome e tipo da organização. Desenhe o diagrama ER usando o modelo Chen. Siga a metodologia e inclua todas as descrições em inglês do seu diagrama. Mapeie o diagrama ER para um banco de dados relacional e inclua alguns dados de exemplo.



### Exercício 6.4

Considere um banco de dados de ALUNOS e ORIENTADORES. Os alunos têm um número de aluno e um nome de aluno. Os orientadores têm nomes, números de escritório e orientam em alguma área de estudo. A área de estudo em que o orientador orienta é designada por um código de área \(por exemplo, Química, QUÍMICA; Biologia, BIOL; Ciência da Computação, COMPSC; ...\). Desenhe o diagrama ER usando o modelo Chen-like. Siga a metodologia e inclua todas as descrições em inglês do seu diagrama. Mapeie o diagrama ER para um banco de dados relacional e inclua alguns dados de exemplo.



### Exercício 6.5

Você deseja registrar os seguintes dados em um banco de dados: nome e localização do restaurante, nomes e IDs dos funcionários, capacidade do restaurante, área para fumantes ou não fumantes no restaurante, horário de funcionamento do restaurante \(considere o mesmo horário todos os dias\), salários e cargos dos funcionários. Um funcionário pode trabalhar em apenas um restaurante. Um restaurante deve ter pelo menos um funcionário trabalhando nele. Desenhe o diagrama ER usando o modelo Chen-like. Siga a metodologia e inclua todas as descrições em inglês do seu diagrama. Mapeie o diagrama ER para um banco de dados relacional e inclua alguns dados de exemplo.



### Exercício 6.5a

Ajuste o exercício 6.5 para: Um funcionário pode trabalhar para um restaurante e pode trabalhar para muitos restaurantes, mas um restaurante deve ter pelo menos um funcionário trabalhando nele, e pode ter muitos funcionários trabalhando nele. Mostre o modelo ER do tipo Chen e o mapeamento relacional para isso \(você não precisa incluir dados\).



### Exercício 6.5b

Ajuste o exercício 6.5 para: Um funcionário deve trabalhar em pelo menos um restaurante e só pode trabalhar em um restaurante. Um restaurante pode ter funcionários trabalhando nele. Mostre o modelo ER do tipo Chen e o mapeamento relacional para isso \(você não precisa incluir dados\).



### Exercício 6.6

Registre os seguintes dados em um banco de dados: nome da empresa, proprietário, localização\(ões\), números de telefone, número do caminhão de entrega, capacidade do caminhão, descrição da rota usual \(por exemplo, Norte, Oeste, Centro, Lago, etc.\). Desenhe o diagrama ER usando o modelo Chen-like. Apresente o mapeamento relacional. Siga a metodologia e inclua todas as descrições em inglês do seu diagrama.



### Exercício 6.7

Consulte a Figura 6.19. Quais são as afirmações em inglês que você pode fazer sobre a figura?
FIGURA 6.19 Diagrama ER do shopping West Florida com quatro entidades e restrições estruturais.   


### Exercício 6.8

Consulte a Figura 6.18. Complete o diagrama adicionando uma descrição precisa em inglês de cada atributo. Mapeie a Figura 6.18 para um banco de dados relacional.



### Exercício 6.9

Qual é a cardinalidade do seguinte?

1. Cada aluno deve possuir um carro, podendo possuir apenas um. Cada carro pode ser propriedade de apenas um aluno. 
2. Cada aluno pode dirigir um carro e pode dirigir mais de um carro. Um carro 
3. ser conduzido por um aluno e só pode ser conduzido por um aluno. 
4. Cada aluno pode alugar muitos carros e os carros podem ser alugados por muitos alunos.

Quais destas regras de cardinalidade são opcionais? Quais regras são obrigatórias? Mostre essas relações em diagrama usando a notação ER semelhante à de Chen.



## ESTUDO DE CASO



### West Florida Mall \(Continuação\)

Nos últimos capítulos, selecionamos nossas entidades primárias \(conforme as especificações do usuário até o momento\) e definimos os relacionamentos entre elas. Neste capítulo, prosseguimos com o diagrama ER para este estudo de caso, analisando as etapas 6 e 7 da metodologia de projeto ER, e mapeamos o diagrama ER para um banco de dados relacional \(com alguns dados de amostra\) à medida que avançamos.

A etapa 6 desenvolve as restrições estruturais dos relacionamentos binários.

+  ** *Etapa 6. Indique a natureza exata dos relacionamentos no inglês estruturado de todos os lados; por exemplo, quando um relacionamento é A:B∷1:M, há um relacionamento de A\(1\) para B\(M\) e de B\(M\) de volta para A\(1\).***  

Consulte a Figura 6.20.
FIGURA 6.20 Diagrama ER do shopping West Florida com quatro entidades e restrições estruturais. 
Primeiro, para o relacionamento located\_in:

+ Do SHOPPING para a LOJA, isso se encaixa no padrão 3, 1\(completo\):N: 
+ Um shopping deve ter pelo menos uma loja e pode ter muitas lojas. 
+ Ou,



+ Os shoppings, registrados no banco de dados, devem ter muitas \(uma ou mais\) lojas localizadas neles.

+ Da LOJA ao SHOPPING, isso se encaixa no padrão 1, M\(full\):1: 
+ Muitas lojas \(uma ou mais\) devem estar em um shopping. 
+ Ou, 
+ As lojas registradas no banco de dados devem estar no mesmo shopping.

A entidade MALL é mapeada conforme mapeado no Capítulo 5, conforme mostrado na Tabela 6.16.
TABELA 6.16 Dados de amostra para MALL.   **nome**  **endereço**    
* * *
      `West Florida Mall`  `N Davis Hwy, Pensacola, FL`    `Cordova Mall`  `9th Avenue, Pensacola, FL`    `Navy Mall`  `Navy Blvd, Pensacola, FL`    `BelAir Mall`  `10th Avenue, Mobile, AL`     
Em seguida, precisamos mapear o relacionamento entre a entidade MALL e a entidade STORE. Este é um relacionamento binário 1:N; portanto, usamos a regra de mapeamento 9, que afirma:

+  ** *Inclua a chave da entidade no lado 1 do relacionamento para o lado N como uma chave estrangeira.***  

Portanto, a chave do lado 1, o lado MALL, será incluída no lado N, lado STORE, como a chave estrangeira. Mostramos isso a seguir com alguns dados de exemplo, apresentados na Tabela 6.17.
TABELA 6.17 Dados de amostra para STORE.   **sloc**  **nome**  **snum**  **nome\_do\_shopping**    
* * *
      `Rm 101`  `Penneys`  `l`  `West Florida Mall`    `Rm 102`  `Sears`  `2`  `West Florida Mall`    `Rm 109`  `Dollar Store`  `3`  `West Florida Mall`    `Rm 110`  `Rex`  `4`  `West Florida Mall`     
Devido ao atributo multivalorado dept em STORE, manteremos a relação com o atributo multivalorado \(conforme desenvolvido no Capítulo 5\). Isso é mostrado a seguir, com alguns dados de exemplo, na Tabela 6.18.
TABELA 6.18 Dados de amostra para STORE-DEPT.   **snum**  **departamento**    
* * *
      `1`  `Tall men’s clothing`    `1`  `Women’s clothing`    `1`  `Children’s clothing`    `1`  `Men’s clothing`    .    .    .    .     
Então, para o relacionamento possui:

+ Do PROPRIETÁRIO para a LOJA, isso se encaixa no padrão 3, 1\(completo\):M: 
+ Os proprietários, registrados no banco de dados, devem possuir uma ou mais lojas. 
+ Ou, 
+ Um proprietário deve possuir pelo menos uma loja e pode possuir muitas lojas.



+ Da LOJA para o PROPRIETÁRIO, isso se encaixa no padrão 1, M\(completo\):1: 
+ As lojas registradas no banco de dados devem ter um e somente um proprietário. 
+ Ou, 
+ Muitas lojas podem ter um único proprietário.

Para o relacionamento possui, de PROPRIETÁRIO para LOJA, um relacionamento 1:N:

Novamente, usando a regra de mapeamento 9, pegaremos a chave do lado 1, so\_ssn, e a incluiremos como chave estrangeira no lado N, STORE. STORE, com alguns dados de amostra, agora é como mostrado na Tabela 6.19.
TABELA 6.19 Dados de amostra para STORE com chave estrangeira.   **sloc**  **nome**  **snum**  **nome\_do\_shopping**  **então\_ssn**    
* * *
      `Rm 101`  `Penneys`  `1`  `West Florida Mall`  `879–987–0987`    `Rm 102`  `Sears`  `2`  `West Florida Mall`  `928–088–7654`    `Rm 109`  `Dollar Store`  `3`  `West Florida Mall`  `826–098–0877`    `Rm 110`  `Rex`  `4`  `West Florida Mall`  `982–876–8766`     
E a relação para a entidade PROPRIETÁRIO permanece conforme desenvolvida no Capítulo 5. Com alguns dados de amostra, ela é mostrada na Tabela 6.20.
TABELA 6.20 Dados de amostra para PROPRIETÁRIO na Figura 6.13.   **então\_ssn**  **nome\_de\_esse**  **então\_off\_phone**  **então\_endereço**    
* * *
      `879–987–0987`  `Earp`  `(850)474–2093`  `1195 Gulf Breeze Pkwy, Pensacola, FL`    `826–098–0877`  `Sardar`  `(850)474–9873`  `109 Navy Blvd, Pensacola, FL`    `928–088–7654`  `Bagui`  `(850)474–9382`  `8 9 Highland Heights, Tampa, FL`    `982–876–8766`  `Bush`  `(850)474–9283`  `987 Middle Tree, Mobile, AL`     
Para o relacionamento gerencia:

+ De LOJA para GERENTE DE LOJA, isso se encaixa no padrão 1, 1\(completo\):1: 
+ As lojas registradas no banco de dados devem ter um gerente de loja. 
+ Ou, 
+ As lojas devem ter um gerente de loja e só podem ter um e somente um gerente de loja.

+ De GERENTE-DE-LOJA para LOJA, isso também se encaixa no padrão 1, 1\(completo\):1: 
+ Os gerentes de loja, registrados no banco de dados, devem gerenciar uma e somente uma loja.

+ Ou, 
+ Os gerentes de loja devem gerenciar pelo menos uma loja e podem gerenciar apenas uma loja.

O relacionamento entre STORE e STORE MANAGER é um relacionamento binário 1:1; portanto, usando a regra de mapeamento 8, o relacionamento STORE se desenvolveria no seguinte com alguns dados de amostra \(estamos pegando a chave de STORE MANAGER e incluindo-a em STORE como a chave estrangeira\), conforme mostrado na Tabela 6.21.
TABELA 6.21 Dados de amostra para STORE com chave estrangeira.   **sloc**  **nome**  **snum**  **nome\_do\_shopping**  **então\_ssn**  **sm\_ssn**    
* * *
      `Rm 101`  `Penneys`  `1`  `West Florida Mall`  `879–987–0987`  `283–972–0927`    `Rm 102`  `Sears`  `2`  `West Florida Mall`  `928–088–7654`  `456–098–0987`    `Rm 109`  `Dollar Store`  `3`  `West Florida Mall`  `826–098–0877`  `234–987–0988`    `Rm 110`  `Rex`  `4`  `West Florida Mall`  `982–876–8766`  `928–982–9882`     
A relação para a entidade STORE-MANAGER permanece conforme desenvolvida no Capítulo 5. Mostramos isso com alguns dados de amostra, conforme mostrado na Tabela 6.22.
TABELA 6.22 Dados de amostra para STORE-MANAGER.   **sm\_ssn**  **sm\_nome**  **sm\_salário**    
* * *
      `234–987–0988`  `Saha`  `45,900`    `456–098–0987`  `Becker`  `43,989`    `928–982–9882`  `Ford`  `44,000`    `283–972–0927`  `Raja`  `38,988`     
Nosso próximo passo é o passo 7, que é

+  ** *Etapa 7. Apresente o banco de dados "como projetado" ao usuário, completo com os termos em inglês para entidades, atributos, chaves e relacionamentos. Refine o diagrama, conforme necessário.***  



Em resumo, nosso banco de dados relacional foi mapeado até agora para \(sem os dados\) \(observe que as chaves primárias estão sublinhadas\):
**SHOPPING CENTER**     *nome*   *endereço*      **LOJA**    *sloc*  *nome*   *snum*   *nome do shopping*  *então ssn*  *sm ssn*      **DEPARTAMENTO DE LOJA**     *snum*    *departamento*       **PROPRIETÁRIO**     *então \_ ssn*   *então \_ nome*  *então \_ desligue \_ o telefone*  *então \_ endereço*      **GERENTE DE LOJA**     *sm \_ ssn*   *sm \_ nome*  *sm \_ salário*    
Continuaremos o desenvolvimento deste estudo de caso no final do próximo capítulo.



## OBSERVAÇÃO

+ 1 Modelado após Elmasri e Navathe \(2016\).



## BIBLIOGRAFIA

+ Batini, C., Ceri, S. e Navathe, S.B. \(1992\). Projeto Conceitual de Banco de Dados. Redwood City, CA: Benjamin Cummings. 
+ Earp, R. e Bagui, S. \(2001\). Estendendo relacionamentos no diagrama entidade-relacionamento. Data Base Management Journal, 22–10–42: 1–14. 
+ Elmasri, R., e Navathe, S.B. \(2016\). Fundamentos de Sistemas de Banco de Dados. Reading, MA: Addison-Wesley. 
+ Kroenke, D.M. \(2010\). Processamento de Banco de Dados. Upper Saddle River, NJ: Prentice Hall. 
+ McFadden, F.R., e Hoffer, J.A. \(2007\). Gerenciamento Moderno de Banco de Dados. Upper Saddle River, NJ: Pearson Education. 
+ Ramakrishnan, R., e Gehrke, J. \(2003\). Sistemas de Gerenciamento de Banco de Dados. Nova Iorque: McGraw Hill.





# 7 A Entidade Fraca



DOI: 10.1201/9781003314455-7



## 7.1 INTRODUÇÃO

Os capítulos 4 e 5 introduziram os conceitos de entidade, atributo e relacionamento. O capítulo 6 abordou as restrições estruturais, ou seja, como duas entidades se relacionam entre si. Neste capítulo, discutimos o conceito de entidade "fraca", utilizado no modelo do tipo Chen. Entidades fracas podem não ter um atributo-chave próprio, pois dependem de uma entidade forte ou regular para sua existência. Entidades fortes sempre possuem uma chave primária. A entidade fraca possui algumas restrições quanto ao seu uso e gera alguns diagramas interessantes. Este capítulo revisita e redefine as etapas 3 e 4 da metodologia de projeto entidade-relacionamento \(ER\) para incluir o conceito de entidade fraca. Regras gramaticais e de mapeamento para a entidade fraca também são desenvolvidas.



## 7.2 ENTIDADES FORTES E FRACAS

Conforme mencionado no Capítulo 4, existem situações em que encontrar uma chave para uma entidade é difícil. Até agora, nos concentramos em exemplos com entidades fortes \(regulares\) — entidades com chaves facilmente identificáveis. Entidades fortes quase sempre possuem um identificador único que é um subconjunto de todos os atributos; no entanto, um identificador único pode ser um atributo ou um grupo de atributos. Por exemplo, um número de estudante, um número de identificação de veículo automotor \(VIN\), um número de carteira de motorista e assim por diante podem ser identificadores únicos de entidades fortes.

Uma entidade fraca claramente será uma entidade, mas dependerá de outra entidade para sua existência. Como mencionamos, uma entidade fraca não necessariamente terá um identificador único. Um exemplo clássico desse tipo de entidade é um DEPENDENTE em relação a uma entidade FUNCIONÁRIO. Se estivéssemos construindo um banco de dados sobre funcionários e seus dependentes, uma instância de um dependente dependeria inteiramente de alguma instância de um funcionário, caso contrário, o dependente não seria mantido no banco de dados. A entidade FUNCIONÁRIO é chamada de entidade proprietária ou entidade identificadora da entidade fraca DEPENDENTE.

Como uma entidade fraca pode surgir em nossos diagramas? Na criação de um banco de dados, podemos ter um nome dependente mostrado como um atributo multivalor, como na Figura 7.1. Um exemplo de dados para um diagrama como o da Figura 7.1 seria o mostrado na Tabela 7.1.
FIGURA 7.1 Entidade EMPLOYEE mostrando dependentes como um atributo multivalorado.  TABELA 7.1 Dados de amostra para FUNCIONÁRIO na Figura 7.1.   **nome de usuário**  **minit**  **Iname**  **ID do emp**  **dependentes**    
* * *
      `John`  `J`  `Jones`  `0001`  `John, Jr; Dumas; Sally`    `Sam`  `S`  `Smith`  `0004`  `Brenda; Richard`    `Adam`  `A`  `Adams`  `0007`  `John; Quincy; Maude`    `Santosh`  `C`  `Saha`  `0009`  `Ranu; Pradeep; Mala`     
Suponhamos que, em nossas conversas com o usuário, descobrimos que mais informações devem ser coletadas sobre os dependentes. Seguindo nossa metodologia, isso é um reconhecimento de que os dependentes devem ser entidades — eles se enquadram no critério de "entidade", onde estamos registrando informações sobre "algo" \(o dependente\). Portanto, estaríamos descrevendo uma entidade chamada DEPENDENTE. Se tornássemos DEPENDENTE uma entidade, embelezaríamos o diagrama da Figura 7.1 para a Figura 7.2.
FIGURA 7.2 Diagrama ER FUNCIONÁRIO-DEPENDENTE, primeira passagem. 
Como observação, ao projetar um banco de dados, os atributos são normalmente nomeados como substantivos singulares. Aqui, usamos a palavra "dependente" como plural \(dependentes\). Isso evidencia que projetamos uma entidade com um atributo multivalorado. Sem querer nos precipitar, mas como veremos, no banco de dados definitivo, atributos multivalorados serão um problema. Nesta fase inicial do projeto do banco de dados e da elicitação dos desejos e necessidades de um usuário, o atributo multivalorado pode permanecer no diagrama como o apresentamos. Como veremos mais adiante, resolveremos a dificuldade do atributo multivalorado no processo de normalização após o mapeamento do diagrama ER para um banco de dados relacional.

A Figura 7.2 apresenta um problema: a entidade DEPENDENTE depende do FUNCIONÁRIO para existir. Além disso, não possui um identificador único claro. Essa dependência do FUNCIONÁRIO torna DEPENDENTE uma entidade fraca. Como costuma acontecer com entidades fracas, nome, data\_nascimento e seguro não são chaves candidatas por si só. Nenhum desses atributos teria valores únicos. Não existe uma chave candidata única para cada atributo.

No modelo do tipo Chen, para entidades fracas, delimitamos a entidade em uma caixa dupla e o relacionamento correspondente com o proprietário em um losango duplo. Consulte a Figura 7.3. A entidade fraca na Figura 7.3, o DEPENDENTE, é considerada identificada pela entidade FUNCIONÁRIO. O FUNCIONÁRIO é chamado de entidade identificadora ou entidade proprietária da entidade fraca DEPENDENTE.
FIGURA 7.3 Diagrama ER FUNCIONÁRIO-DEPENDENTE 
Os atributos são tratados da mesma forma para entidades fracas e fortes \(exceto que pode não haver chaves primárias para entidades fracas\). Incluímos alguns atributos na Figura 7.3 para que a figura represente o seguinte \(em gramática livre\):

+ Um dependente deve ser parente de um funcionário, e um funcionário pode ter muitos dependentes.

Como a entidade fraca depende de uma entidade forte, a restrição de participação sempre será obrigatória e a cardinalidade será um na primeira parte da descrição gramatical.

A entidade DEPENDENTE tem os atributos dname, birth\_date e insurance.

Ao lidar com entidades fracas, é apropriado considerar como cada instância da entidade seria identificada. Como o proprietário da entidade fraca, DEPENDENTE, é a entidade forte FUNCIONÁRIO, o processo de identificação envolveria a chave de FUNCIONÁRIO mais algumas informações da entidade fraca DEPENDENTE. O atributo dname é um provável candidato a identificador para DEPENDENTE e será chamado de chave parcial.

Na Figura 7.3, sublinhamos dname com hífens. O atributo dname é uma chave parcial, pois identifica dependentes, mas não de forma única. Isso pressupõe que todos os dependentes tenham nomes únicos. Não "nomeamos" o relacionamento e o deixamos como ED para FUNCIONÁRIO-DEPENDENTE. Nomes adequados para o relacionamento poderiam ser "ter", como em:

+ Os funcionários podem ter muitos dependentes.

ou “dependente de” como em:

+ Os funcionários podem ter muitos dependentes.

Também poderíamos ter usado “relacionado a” como em:

+ Os funcionários são parentes de muitos dependentes.

Cada uma dessas locuções verbais parece ter um ar de redundância \(dependente de\) ou talvez de engano \(relacionado a\). Portanto, provavelmente a melhor coisa a fazer é deixar o relacionamento sem nome \(ED\). Se o usuário optar por usar uma caracterização verbal de relacionamento, o analista pode renomear o relacionamento.



## 7.3 ENTIDADES FRACAS E RESTRIÇÕES ESTRUTURAIS

Entidades fracas sempre têm participação plena ou obrigatória do lado fraco em relação ao proprietário. Se a entidade fraca não tivesse participação total, teríamos um item de dados no banco de dados não identificado de forma única e não vinculado a uma entidade forte. Em nosso exemplo de FUNCIONÁRIO-DEPENDENTE, isso seria como manter o controle de um dependente sem qualquer parentesco com um funcionário. A cardinalidade do relacionamento entre a entidade fraca e a forte geralmente será de 1:M, mas não necessariamente.



## 7.4 ENTIDADES FRACAS E O PROPRIETÁRIO IDENTIFICADOR

Há situações em que uma entidade fraca pode estar conectada a uma entidade proprietária, enquanto outros relacionamentos existem além do relacionamento "proprietário". Por exemplo, considere a Figura 7.4. Nesta figura, mostramos dois relacionamentos — possui e dirige — conectando as duas entidades EMPREGADO e AUTOMÓVEL. Aqui, a entidade AUTOMÓVEL é considerada uma entidade fraca; ou seja, se não houver funcionário, não haverá automóvel \(o automóvel precisa ter um funcionário para existir no banco de dados\). Além disso, o automóvel é identificado pelo proprietário; observe o losango duplo no relacionamento possui e a participação total da entidade AUTOMÓVEL no relacionamento possui.
FIGURA 7.4 Uma entidade fraca com dois relacionamentos 
Na Figura 7.4, também temos um relacionamento "drives" \(dirige\). O automóvel pode ser dirigido por outros funcionários além do proprietário. Todos os automóveis são dirigidos por algum funcionário; portanto, a participação é total nas viagens de AUTOMÓVEL para FUNCIONÁRIO. O motorista-funcionário pode não ser necessariamente o proprietário real. Para identificar AUTOMÓVEL, estamos dizendo que precisamos do relacionamento "owners" \(possui\), mas podem existir outros motoristas não proprietários.

De acordo com a Figura 7.4, um funcionário pode possuir vários automóveis. Para responder à pergunta sobre quais automóveis um funcionário possui, além do ID do funcionário, precisamos saber a marca, o modelo e a cor dos automóveis. Os atributos marca, modelo e cor da entidade AUTOMÓVEL são chaves parciais \(pontilhadas e sublinhadas na Figura 7.4\). Por que estão sublinhadas e pontilhadas? Porque esses três atributos não identificarão um automóvel de forma única.

Um último ponto sobre a situação AUTOMÓVEL-FUNCIONÁRIO: pode ser que o número de identificação do veículo \(VIN\) do AUTOMÓVEL possa ser registrado. VINs são únicos; portanto, a entidade fraca AUTOMÓVEL poderia ter uma chave primária. Nesse caso, embora AUTOMÓVEL tivesse uma chave primária, ela ainda poderia ser considerada fraca, pois não estaria no banco de dados sem o proprietário ou motorista funcionário. Ter uma chave primária não torna necessariamente uma entidade "forte".

Ponto de verificação 7.1

1. O que é uma entidade fraca? 
2. Como você identificaria uma entidade forte? 
3. Como você identificaria uma entidade fraca? 
4. Que tipo de linha de relacionamento \(simples ou dupla\) levaria à entidade fraca em um diagrama do tipo Chen? 
5. O que é uma chave parcial? 
6. Quais seriam geralmente as restrições estruturais de uma entidade fraca? 
7. Qual seria geralmente a cardinalidade de uma entidade fraca?



### 7.4.1 Outro exemplo de uma entidade fraca e o proprietário que a identifica

Como outro exemplo de uma entidade fraca em um diagrama ER e do proprietário identificador, considere a Figura 7.5. Na Figura 7.5, temos duas entidades fortes: PESSOA e VET. Há uma entidade fraca, PET. A Figura 7.5 ilustra que a PESSOA possui o PET, mas o VET trata o PET. No diagrama, PESSOA é a entidade identificadora ou controladora do PET; portanto, o relacionamento "possui" tem um losango duplo com PESSOA. Aqui, "possui" é um relacionamento fraco. PET é uma entidade fraca relacionada a PESSOA.
FIGURA 7.5 Diagrama ER PESSOA-PET-VET 
O relacionamento trata não tem um diamante duplo porque VET não é o proprietário de PET. Aqui, trata não é um relacionamento fraco, e PET não é uma entidade fraca em relação a VET.



## 7.5 ENTIDADES FRACAS CONECTADAS A OUTRAS ENTIDADES FRACAS

Gostaríamos de fazer uma última observação sobre entidades fracas. Só porque uma entidade é fraca não a impede de ser proprietária de outra entidade fraca. Por exemplo, considere a Figura 7.6. Nesta figura, o relacionamento FUNCIONÁRIO-DEPENDENTE foi aprimorado para incluir os hobbies dos dependentes. \(Não importa por que alguém desejaria registrar essas informações, mas vamos supor que o usuário insista.\)
FIGURA 7.6 Diagrama ER FUNCIONÁRIO-DEPENDENTE-HOBBY. 
DEPENDENTE é uma entidade fraca. A entidade HOBBY também é fraca. Hobbies podem ser identificados por seu tipo \(colecionar selos, beisebol, dar nós, observar trens, etc.\). O atributo de tipo de HOBBY é uma chave parcial para HOBBY.

A entidade DEPENDENTE é a proprietária da entidade fraca HOBBY, e a entidade FUNCIONÁRIO é a proprietária da entidade fraca DEPENDENTE.

A razão pela qual essa situação é levantada aqui é para mostrar que ela pode existir. Em discussões mais aprofundadas, quando mapearmos essa situação, trataremos essa situação específica com cuidado.

Ponto de verificação 7.2

1. Uma entidade fraca pode ser dependente de outra entidade fraca? 
2. Uma entidade fraca pode ter um relacionamento que não seja “fraco” com a entidade identificadora? 
3. Uma entidade fraca pode estar relacionada a mais de uma entidade \(forte ou fraca\)?



## 7.6 REVISITANDO A METODOLOGIA

A inclusão de uma entidade fraca em um diagrama ER nos leva a revisitar nossa metodologia e fazer alguns ajustes. Podemos descobrir a entidade fraca em um de dois lugares: um seria como ilustramos com a evolução do atributo multivalorado, o "dependente"; isso ocorreria nas etapas 3a e 3b:

+  ** *Etapa 3. Examine os atributos na entidade primária \(possivelmente com assistência do usuário\) para descobrir se as informações sobre um dos atributos devem ser registradas.***  
+  ** *Etapa 3a. Se forem necessárias informações sobre um atributo, torne o atributo uma entidade e, em seguida,***  
+  ** *Etapa 3b. Defina o relacionamento de volta à entidade original.***  

Então, nós adicionamos

+  ** *Etapa 3c. Se a nova entidade depender inteiramente de outra entidade para sua existência, desenhe a entidade como fraca \(em caixa dupla\) e mostre a conexão com a entidade identificadora como um losango duplo. A participação da entidade fraca no relacionamento é plena. Sublinhe com um traço o\(s\) identificador\(es\)-chave parcial\(is\) na entidade fraca.***  

O segundo lugar onde uma entidade fraca pode aparecer seria como parte da etapa 4, quando novas entidades são consideradas:

+  ** *Passo 4. Se outra entidade for apropriada, desenhe a segunda entidade com seus atributos. Repita o passo 2 para ver se algum atributo precisa ser dividido em mais entidades.***  

Então, acrescentamos:

+  ** *Etapa 4a. Se a\(s\) entidade\(s\) adicional\(is\) não possuir\(em\) chaves candidatas, desenhe-as como entidades fracas \(conforme explicado na etapa 3c\) e mostre a conexão com uma entidade identificadora. A participação da entidade fraca no relacionamento é plena ou obrigatória. Sublinhe com hífen ou ponto o\(s\) identificador\(es\) de chave parcial\(is\) na entidade fraca.***  

Novamente, uma entidade fraca não pode existir sem uma entidade identificadora. Se a entidade fraca for "descoberta" independentemente de uma entidade identificadora, a conexão de relacionamento deve ser estabelecida imediatamente.



## 7.7 GRAMÁTICA DE ENTIDADE FRACA

Anteriormente, abordamos alguma gramática associada a entidades fracas. Agora, queremos revisar e aprimorar a ideia quando não temos uma chave primária para a entidade fraca. É possível que uma entidade fraca tenha uma chave primária; portanto, ela pode aparecer no item \(b\), então adicionamos a parte \(c\) à gramática para as chaves, apresentada a seguir.



### 7.7.1 As Chaves

Para a\(s\) chave\(s\):

1.  
Mais de uma chave candidata \(entidade forte\):

Uma chave é escolhida como chave primária… \(abordada anteriormente\).

2.  
Uma chave candidata \(entidade forte ou fraca\):

A chave primária é a chave candidata. Para cada entidade fraca, assume-se que nenhuma entidade fraca será registrada sem uma entidade proprietária \(forte\) correspondente.


Para cada entidade fraca com uma chave primária, também devemos registrar a chave primária da entidade proprietária.

+ \(c\) Nenhuma chave candidata \(entidade fraca\):

Para cada entidade \(fraca\), não assumimos que qualquer atributo será único o suficiente para identificar entidades individuais.

Neste caso, a entidade DEPENDENTE seria descrita como:

+ Para cada entidade DEPENDENTE, não assumimos que nenhum atributo será único o suficiente para identificar entidades individuais.

Agora, aprimoramos esta descrição para incluir a entidade de identificação:

+ Como a entidade fraca não possui uma chave candidata, cada entidade fraca será identificada pela\(s\) chave\(s\) pertencente\(s\) à sua entidade forte. Para cada DEPENDENTE, as entidades serão identificadas pela concatenação de sua chave parcial e da chave primária do proprietário: \(DEPENDENTE. NOME\_DEP\+FUNCIONÁRIO.ID\_FUNCIONÁRIO\).

Neste caso, a entidade DEPENDENTE é identificada pela entidade FUNCIONÁRIO, e esta segunda declaração se torna:

+ Como a entidade DEPENDENTE não tem uma chave candidata, cada entidade DEPENDENTE será identificada por chave\(s\) pertencentes à entidade FUNCIONÁRIO mais dname na entidade DEPENDENTE.



## 7.8 MAPEAMENTO DE ENTIDADES FRACAS PARA UM BANCO DE DADOS RELACIONAL

Nesta seção, desenvolvemos as regras de mapeamento para mapear entidades fracas para um banco de dados relacional.

+ Regra de Mapeamento 11 — Mapeando entidades fracas. Desenvolva uma nova tabela \(relação\) para cada entidade fraca. Como no caso da entidade forte, inclua quaisquer atributos atômicos da entidade fraca na tabela. Se houver um atributo composto, inclua apenas as partes atômicas do atributo composto e certifique-se de qualificar as partes atômicas para não perder informações. Para relacionar a entidade fraca ao seu proprietário, inclua a chave primária da entidade proprietária na relação fraca. A chave primária da relação fraca será a chave parcial da entidade fraca concatenada à chave primária da entidade proprietária. 
+ Se uma entidade fraca possuir outras entidades fracas, a entidade fraca conectada à entidade forte deverá ser mapeada primeiro. A chave da entidade proprietária fraca deverá ser definida antes que a entidade "mais fraca" \(a mais distante da entidade forte\) possa ser mapeada.

Por exemplo, consulte a Figura 7.3. A relação EMPREGADO e a relação DEPENDENTE seriam mapeadas como

+ FUNCIONÁRIO\(nome\_f, minit, nome\_l, id\_funcionário\) 
+ DEPENDENTE\(id\_funcionário, nome\_do\_empregador, seguro, data\_de\_nascimento\)

e com os dados apresentados nas Tabelas 7.2 e 7.3.
TABELA 7.2 Dados de amostra do EMPREGADO na Figura 7.3.   **nome de usuário**  **Iname**  **minit**  **ID do funcionário**    
* * *
      `Richard`  `Earp`  `W`  `589`    `Boris`  `Backer`   `909`    `Helga`  `Hogan`  `H`  `384`    `Arpan`  `Bagui`  `K`  `876`    `Hema`  `Malini`   `505`      TABELA 7.3 Dados de amostra de DEPENDENTE na Figura 7.3.   **nome do domínio**  **data de nascimento**  **seguro**  **ID do funcionário**    
* * *
      `Beryl`  `1/1/94`  `Vista`  `589`    `Kaityln`  `2/25/07`  `Vista`  `909`    `David`  `3/4/05`  `BlueCross`  `589`    `Dumas`  `3/7/08`  `BlueCross`  `589`    `Abbie`  `5/6/08`  `SE`  `384`     
Aqui, employee\_id é a chave primária de EMPLOYEE. O employee\_id da relação de proprietário EMPLOYEE está incluído na relação fraca DEPENDENT. O employee\_id agora se torna parte da chave primária de DEPENDENT. Como dname é a chave parcial da relação DEPENDENT, a chave primária da relação DEPENDENT agora se torna dname e employee\_id concatenados.

Agora, consulte a Figura 7.6. Aqui, a entidade DEPENDENTE é dependente da entidade FUNCIONÁRIO, e a entidade PASSATEMPO é dependente da entidade DEPENDENTE. A relação FUNCIONÁRIO e a relação DEPENDENTE seriam mapeadas conforme mostrado, e então a relação PASSATEMPO seria mapeada como:

+ HOBBY\(nome, id\_funcionário, tipo, anos\_envolvidos\)

E, com alguns dados de amostra, conforme mostrado na Tabela 7.4.
TABELA 7.4 Dados de amostra de HOBBY na Figura 7.6.   **nome do domínio**  **ID do funcionário**  **tipo**  **anos\_envolvidos**    
* * *
      `Beryl`  `589`  `swimming`  `3`    `Kaityln`  `909`  `reading`  `5`    `David`  `589`  `hiking`  `1`    `Dumas`  `589`  `fishing`  `2`    `Abbie`  `384`  `singing`  `4`     
A chave parcial de HOBBY era type. A chave primária da relação HOBBY agora se torna dname, employee\_id e type, todos juntos.

Ponto de verificação 7.3

1. Quais são as regras para mapear entidades fracas? Mapeie a Figura 7.5 e mostre alguns dados de exemplo. 
2. Ao mapear entidades fracas, o que se torna sua nova chave primária? 
3. Como você mapearia atributos multivalorados em uma entidade fraca? Explique com um exemplo. 
4. Como as entidades fracas são geralmente identificadas?





## 7.9 RESUMO DO CAPÍTULO

Este capítulo discutiu e desenvolveu o conceito de entidade fraca. A gramática para a entidade fraca foi aprimorada, juntamente com a metodologia de design de ER. As regras de mapeamento para a entidade fraca também foram desenvolvidas. Este conceito de entidade fraca está disponível no modelo do tipo Chen, mas é tratado de forma diferente em outros modelos de ER.





## CAPÍTULO 7 EXERCÍCIOS



### Exercício 7.1

Construa um diagrama ER \(um modelo semelhante ao de Chen\) para um banco de dados contendo o nome do funcionário, número do funcionário, endereço do funcionário e habilidades. Um funcionário pode ter mais de uma habilidade. Em seguida, aprimore o diagrama para incluir o nível de habilidade, a data em que você obteve a certificação da habilidade \(se certificada\) e a data em que começou a usar a habilidade. Há alguma entidade fraca neste banco de dados? Mapeie este diagrama ER para um banco de dados relacional.



### Exercício 7.2

Construa um diagrama ER para esportes e jogadores. Os atributos de ESPORTE são nome do esporte, tipo de esporte, cronometrado ou não cronometrado. Os atributos de JOGADORES são nome, ID da pessoa e data de nascimento. Os jogadores podem praticar vários esportes. Qual\(is\) entidade\(s\) você consideraria fraca\(s\)? Escreva a gramática do diagrama ER. Mapeie este diagrama ER para um banco de dados relacional.



### Exercício 7.3

Quais regras de mapeamento seriam usadas para mapear a Figura 7.4? Mapeie a Figura 7.4 para um banco de dados relacional e mostre alguns dados de exemplo.



### Exercício 7.4

Mapeie a Figura 7.6 para um banco de dados relacional \(Observação: certifique-se de mostrar as chaves\). Não preciso ver dados de exemplo aqui, apenas as tabelas e atributos, por exemplo: TABELA1\(atributo1, atributo2, atributo3\).



### Exercício 7.5

“Escreva” a cardinalidade e a participação para as Figuras 6.3 e 7.5. Certifique-se de que as proporções de cardinalidade e participação sejam escritas de ambos os lados.



## ESTUDO DE CASO



### West Florida Mall \(continuação\)

Nos capítulos anteriores, selecionamos nossas entidades primárias, definimos os atributos e relacionamentos para este estudo de caso e o mapeamos para um banco de dados relacional \(com alguns dados de amostra\). No Capítulo 6, também determinamos as restrições estruturais dos relacionamentos e ajustamos alguns dos mapeamentos de acordo. A etapa 7 diz:

+  ** *Etapa 7. Apresente o banco de dados "como projetado" ao usuário, completo com os termos em inglês para entidades, atributos, chaves e relacionamentos. Refine o diagrama conforme necessário.***  

Suponhamos que obtivemos alguma entrada adicional do usuário:

Uma loja deve ter um ou mais departamentos. Um departamento não existirá sem uma loja. Para cada departamento, armazenaremos o nome, o número e o gerente do departamento. Cada departamento tem pelo menos um funcionário trabalhando nele.

Temos que registrar informações sobre os funcionários da loja. Para cada funcionário da loja, teremos que manter o nome, o número do Seguro Social e o departamento em que trabalha. Os funcionários devem trabalhar em apenas um departamento.

No Capítulo 5, determinamos que departamentos era um atributo multivalorado de LOJA \(ou seja, uma loja tinha muitos departamentos\). Mas, ao revisar essas especificações adicionais, podemos ver que DEPARTAMENTO precisa ser uma entidade independente, já que precisamos registrar informações sobre um DEPARTAMENTO. Além disso, podemos ver que precisamos registrar informações sobre outra nova entidade, FUNCIONÁRIO. Portanto, essas especificações atuais adicionam duas novas entidades, DEPARTAMENTO e FUNCIONÁRIO. Observe que, ao adicionar essas duas entidades, podemos torná-las entidades fortes com as chaves, número\_departamento e id\_funcionário, respectivamente.

Primeiro, selecionamos uma entidade, DEPARTAMENTO.

Agora, repetindo o passo 2 para DEPARTAMENTO:



### A Entidade

Este banco de dados registra dados sobre um DEPARTAMENTO.

+ Para cada DEPARTAMENTO no banco de dados, registramos um nome de departamento \(dname\) e um número de departamento \(dnum\).



### Os Atributos para DEPARTAMENTO

+ Para cada DEPARTAMENTO haverá apenas um dname. O valor do dname não será subdividido. 
+ Para cada DEPARTAMENTO, haverá apenas um dnum. O valor do dnum não será subdividido.



### As Chaves

+ Para cada DEPARTAMENTO, precisaremos vincular o número do departamento à entidade proprietária usando a chave da entidade proprietária, store\_id. Portanto, a chave de DEPARTAMENTO será store\_ID\+dnum.

Observe que a linguagem leva você a pensar no DEPARTAMENTO como uma entidade fraca.

Em seguida, selecionamos nossa próxima entidade, FUNCIONÁRIO.

Agora, repetindo o passo 2 para EMPLOYEE:



### A Entidade

Este banco de dados registra dados sobre um FUNCIONÁRIO.

+ Para cada FUNCIONÁRIO no banco de dados, registramos um nome de funcionário \(ename\) e um número de Seguro Social \(essn\).



### Os Atributos para FUNCIONÁRIO

+ Para cada FUNCIONÁRIO, haverá apenas um e-mail. O valor do e-mail não será subdividido. 
+ Para cada FUNCIONÁRIO, haverá apenas um salário-desemprego. O valor do salário-desemprego não será subdividido.



### As Chaves

+ Para cada FUNCIONÁRIO, assumiremos que a essn será única \(portanto, o FUNCIONÁRIO será uma entidade forte\).

Essas entidades foram adicionadas ao diagrama na Figura 7.7.
FIGURA 7.7 Diagrama ER do shopping West Florida desenvolvido até agora. 
Usando a etapa 6 para determinar as restrições estruturais dos relacionamentos, obtemos:

Primeiro, para o relacionamento, dept\_of:

Da LOJA para o DEPARTAMENTO, isso se encaixa no padrão 3, 1\(completo\):N:

+ As lojas, registradas no banco de dados, devem ter muitos \(um ou mais\) departamentos.

Do DEPARTAMENTO para a LOJA, isso se encaixa no padrão 1, M\(completo\):1:

+ Muitos departamentos \(um ou mais\) devem estar em uma loja.



### Para mapear esta relação

O relacionamento entre LOJA e DEPARTAMENTO é um relacionamento forte/fraco, então usando a regra de mapeamento 11, pegaremos a chave do proprietário, snum, e incluiremos isso como parte da chave no lado fraco, DEPARTAMENTO, então o relacionamento DEPARTAMENTO se torna:

+ DEPARTAMENTO\(dnome, dnum, snum\).

E, com alguns dados conforme mostrado na Tabela 7.5.
TABELA 7.5 Dados de amostra para DEPARTAMENTO na Figura 7.7.   **nome do domínio**  **dnum**  **snum**    
* * *
      `Tall Men’s Clothing`  `501`  `1`    `Men’s Clothing`  `502`  `1`    `Women’s Clothing`  `503`  `1`    `Children’s Clothing`  `504`  `1`    `Men’s Clothing`  `601`  `2`    .     .     .      
A tabela STORE será a mesma do Capítulo 6, mas não precisaremos da relação store\_depts. \(No Capítulo 6, os departamentos ainda eram um atributo multivalorado de STORE, então tínhamos as relações STORE e store\_depts.\) Pelas especificações no início do estudo de caso neste capítulo, fica evidente que DEPARTMENT é uma entidade por si só, então a relação store\_depts é substituída pela tabela DEPARTMENT.

Então, para o relacionamento works\_for:

+ De FUNCIONÁRIO para DEPARTAMENTO, isso se encaixa no padrão 1, 1\(completo\):1: 
+ Os funcionários registrados no banco de dados devem trabalhar para um e somente um departamento.

+ Do DEPARTAMENTO para o FUNCIONÁRIO, isso se encaixa no padrão 3, 1\(completo\):N: 
+ Os departamentos registrados no banco de dados devem ter um ou mais funcionários trabalhando neles.



### Para mapear esse relacionamento:

De FUNCIONÁRIO para DEPARTAMENTO, o relacionamento é 1:1. Como ambos os lados têm participação total, usando a regra de mapeamento 8, podemos selecionar qual lado pode armazenar a chave do outro. Mas, como o relacionamento entre DEPARTAMENTO e FUNCIONÁRIO é um relacionamento binário 1\(completo\):N, usando a regra de mapeamento 9, pegaremos a chave do lado 1 \(lado DEPARTAMENTO\), dnum e snum, e incluiremos essa chave concatenada como a chave estrangeira no lado N \(lado FUNCIONÁRIO\), então a relação FUNCIONÁRIO se torna: FUNCIONÁRIO\(nome, essn, dnum, snum\)

E, com alguns dados de amostra, conforme mostrado na Tabela 7.6.
TABELA 7.6 Dados de amostra para FUNCIONÁRIO na Figura 7.7.   **ename**  **essn**  **dnum**  **snum**    
* * *
      `Kaitlyn`  `987–754–9865`  `501`  `1`    `Dumas`  `276–263–9182`  `502`  `1`    `Katie`  `98–928–2726`  `503`  `1`    `Seema`  `837–937–9373`  `501`  `1`    `Raju`  `988–876–3434`  `601`  `2`    .      .      .       
Em resumo, nosso banco de dados relacional foi mapeado até agora \(sem os dados\)
**SHOPPING CENTER**    * nome*   *endereço*      **LOJA**    *sloc*  *nome*  * snum*   *nome\_do\_shopping*  *então\_proprietário*  * sm\_ssn*       **PROPRIETÁRIO**     *então\_ssn*   *nome\_de\_esse*  *então\_off\_phone*  *então\_endereço*      **GERENTE DE LOJA**     *sm\_ssn*   *sm\_nome*  *salário*      **DEPARTAMENTO**    *nome do domínio*  * dnum*   * snum*       **FUNCIONÁRIO**    *ename*   *essn*   *dnum*  *snum*    
Continuaremos o desenvolvimento deste estudo de caso no final do próximo capítulo.



## BIBLIOGRAFIA

+ Chen, P.P. \(1976\). O modelo entidade-relacionamento — em direção a uma visão unificada dos dados. ACM Transactions on Database Systems, 1\(1\). 
+ Connolly, E., e Begg, C. \(2009\). Sistemas de Banco de Dados: Uma Abordagem Prática para Design, Implementação e Gestão. Reading, MA: Addison-Wesley. 
+ Elmasri, R., e Navathe, S.B. \(2016\). Fundamentos de Sistemas de Banco de Dados. Reading, MA: Addison-Wesley. 
+ Ramakrishnan, R., e Gehrke, J. \(2003\). Sistemas de Gerenciamento de Banco de Dados. Nova Iorque: McGraw Hill.





# 8 extensões adicionais para diagramas ER com relacionamentos binários



DOI: 10.1201/9781003314455-8



## 8.1 INTRODUÇÃO

Tendo desenvolvido o modelo básico de entidade-relacionamento \(ER\) nos Capítulos 4 a 7, este capítulo aborda algumas extensões ao modelo básico. Introduzimos um novo conceito — atributos de relacionamentos — e apresentamos diversos exemplos. Em seguida, revisitamos a etapa 6 da metodologia de projeto de ER para incluir atributos de relacionamentos. Em seguida, o capítulo analisa como mais entidades e relacionamentos são adicionados ao modelo de ER e como atributos e relacionamentos evoluem para entidades, ao mesmo tempo em que refinamos nossa metodologia de projeto de ER. Relacionamentos podem se desenvolver em entidades, criando uma entidade de interseção. A gramática e o inglês estruturado para a entidade de interseção são apresentados, e o conceito de relacionamentos recursivos é introduzido.

Além disso, nos capítulos anteriores, examinamos principalmente casos em que duas entidades tinham um \(um\) relacionamento entre si. Neste capítulo, apresentamos cenários adicionais de como duas entidades podem ter mais de um relacionamento entre si. A etapa 5 da metodologia de projeto ER também é redefinida para incluir mais de um relacionamento entre duas entidades. Este capítulo discute relacionamentos derivados e redundantes, e a metodologia de projeto ER é novamente refinada; a etapa 6b é incluída para lidar com essas estruturas. Por fim, neste capítulo, incluímos uma seção opcional para examinar uma notação ER alternativa para especificar restrições estruturais em relacionamentos.



## 8.2 ATRIBUTOS DE RELACIONAMENTOS

No Capítulo 6, consideramos o relacionamento M:N ALUNO-CURSO. O relacionamento ALUNO-CURSO é M:N porque os alunos fazem muitos cursos e os cursos são feitos por muitos alunos. Agora, considere adicionar o atributo nota ao diagrama ER. Se tentássemos colocar o atributo nota com a entidade ALUNO, teríamos um atributo multivalorado que teria que estar de alguma forma relacionado à entidade CURSO para fazer sentido. Da mesma forma, se tentássemos colocar o atributo nota com a entidade CURSO, a entidade CURSO teria então um atributo multivalorado. O lugar correto para nota no diagrama seria no relacionamento matricular porque nota requer um ALUNO e um CURSO para fazer sentido. Veja a Figura 8.1 para o posicionamento do atributo nota em um modelo de participação M:N, total:total.
FIGURA 8.1 Relacionamento M:N mostrando um atributo de relacionamento 
Alguns outros atributos foram adicionados à Figura 8.1 para mostrar a posição relativa dos atributos. Novamente, como a nota é identificada tanto por ALUNO quanto por CURSO, ela não pode residir em nenhuma das entidades isoladamente. Um atributo como nota é chamado de atributo de relacionamento ou atributo de interseção.

Um atributo de interseção pode surgir inicialmente como um atributo multivalorado em alguma entidade durante o processo de design, para depois ser questionado; isto é, por que esse atributo está aqui se requer outra entidade para identificá-lo? Quando se reconhece que o atributo deve ser identificado por mais de uma entidade, ele é movido para o relacionamento entre as duas \(ou mais\) entidades que o identificam.

Atributos de relacionamento podem ocorrer em um diagrama ER contendo qualquer cardinalidade, mas é mais comum encontrar atributos de relacionamento no modelo binário M:N. Agora, precisamos revisitar nossa metodologia para adicionar uma diretriz para os atributos de um relacionamento:

+  ** *Etapa 6. Indique a natureza exata dos relacionamentos no inglês estruturado de todos os lados. Por exemplo, se um relacionamento é A:B::1:M, então há um relacionamento de A para B, 1 para Muitos e de B de volta para A, Muitos para 1.***  

E acrescentamos:

+  ** *Etapa 6a. Examine a lista de atributos e determine se algum deles precisa ser identificado por duas \(ou mais\) entidades. Em caso afirmativo, coloque o atributo no relacionamento apropriado que une as duas entidades.***  

A gramática para descrever o atributo de um relacionamento é discutida a seguir.



### 8.2.1 Os Atributos
Para atributos atômicos, att\(j\):… \(o mesmo dos capítulos anteriores\)  Para atributos compostos, att\(j\):… \(o mesmo dos capítulos anteriores\)  Para atributos multivalorados, att\(j\):… \(o mesmo dos capítulos anteriores\)  Para atributos de relacionamentos att\(j\):    
Para o relacionamento entre ENTIDADE1 e ENTIDADE2, registraremos um att\(j\). O att\(j\) depende de ambas as entidades, ENTIDADE1 e ENTIDADE2, para identificação.

EXEMPLO 8.1

Para o relacionamento entre a entidade ALUNO e a entidade CURSO, registraremos um atributo de nota. O atributo de nota depende das entidades ALUNO e CURSO para identificação.



## 8.3 RELACIONAMENTOS QUE SE DESENVOLVEM EM ENTIDADES: O RELACIONAMENTO M:N REVISITADO

Definimos anteriormente o relacionamento M:N e frequentemente notamos que aparece um atributo que deveria estar associado ao relacionamento e não a uma entidade específica. O exemplo foi a nota, que claramente não se encaixaria nem na entidade ALUNO nem na CURSO. De certa forma, parece que o próprio relacionamento assumiu uma "qualidade de entidade".

Há duas opções para representar essa situação de relacionamento-atributo. Uma opção é deixar o atributo onde está, como mostramos, no relacionamento. Se o número de atributos for pequeno \(um ou dois\), o sentido do diagrama permanecerá intacto e a gramática que o representa será compreensível para o usuário.

A outra opção para atributos de relacionamento seria tornar o relacionamento uma entidade e vincular ambas as "entidades identificadoras" a ela. Essa opção é mostrada na Figura 8.2. Nesta figura, a entidade do meio, ALUNO\+CURSO, é representada como fraca porque ALUNO\+CURSO depende inteiramente das entidades ALUNO e CURSO. Observe que as participações são sempre completas entre a nova "entidade de interseção" fraca e o relacionamento que a une aos proprietários fortes. Por quê? Porque a entidade fraca deve ter uma entidade forte correspondente, ou ela não estaria lá. A participação no lado do relacionamento forte \(entre ALUNO e REL1 \[abreviação de relacionamento 1\] ou entre CURSO e REL2 \[novamente, abreviação de relacionamento 2\]\) pode ser parcial ou total, dependendo se era parcial ou total originalmente. O que significaria uma conexão parcial CURSO-REL2? Isso indicaria que existiam aulas no banco de dados que não são oferecidas e, portanto, não há alunos nelas.
FIGURA 8.2 Relação M:N que foi substituída por relações 1:M 
Agora, com uma entidade ALUNO\+CURSO \(uma entidade de interseção\), nossa descrição gramatical dessa entidade de interseção seria como discutida a seguir.



### 8.3.1 A Entidade

Este banco de dados registra dados sobre combinações ALUNO-CURSO: ALUNO\+CURSO. Para cada ALUNO\+CURSO no banco de dados, registramos uma nota.



#### 8.3.1.1 Os Atributos

+ Para cada combinação ALUNO\+CURSO, haverá apenas uma nota. O valor da nota não será subdividido.



#### 8.3.1.2 As Chaves

+ \(d\) Entidade de interseção: A chave da entidade de interseção consistirá na concatenação das chaves estrangeiras das entidades proprietárias.

No exemplo ALUNO-CURSO, a entidade de interseção conterá um ID\_do\_aluno e um ID\_do\_curso — ambos chaves estrangeiras; portanto, a chave dessa entidade será ID\_do\_aluno\+ID\_do\_curso \(o sinal de mais aqui significa concatenação\). Ambos os atributos são necessários para identificar uma linha única no banco de dados.

A última afirmação é muito próxima \(e, para um usuário, espera-se que seja indistinguível\) das principais afirmações encontradas na gramática “atributo em um relacionamento” fornecida:

+ Para o relacionamento entre ALUNO e CURSO, registraremos uma nota. A nota depende de ambas as entidades, ALUNO e CURSO, para identificação.



## 8.4 MAIS ENTIDADES E RELACIONAMENTOS

Ao manipular um banco de dados, precisamos modelar as informações apresentadas. Provavelmente, teremos situações que exigem mais de duas entidades e mais de um relacionamento binário. Novamente, um relacionamento binário é um relacionamento entre duas entidades. \(No Capítulo 9, examinamos combinações de relacionamentos ternários e superiores.\) Esta seção aborda situações em que as informações sobre o banco de dados indicam que precisamos expandir nossos diagramas com mais entidades, mas todas as conexões serão binárias.



### 8.4.1 Mais de duas entidades

Vamos reconsiderar o diagrama ALUNO-CURSO ER \(Figura 8.1\). Se este banco de dados fosse voltado para uma faculdade, os cursos teriam instrutores, e os instrutores estariam relacionados aos cursos. Podemos adicionar INSTRUTOR ao nosso banco de dados, seguindo as etapas 4 e 5 da nossa metodologia, que dizem:

+  ** *Passo 4. Se outra entidade for apropriada, desenhe a segunda entidade com seus atributos. Repita o passo 2 para ver se essa entidade deve ser dividida em mais entidades.***  
+  ** *Etapa 5. Conecte entidades com relacionamentos \(um ou mais\), se houver relacionamentos.***  

Se adicionarmos instrutores à Figura 8.1, chegaremos à Figura 8.3 \(atributos que não sejam as chaves primárias foram omitidos intencionalmente para organizar o diagrama\). A relação entre INSTRUTOR e CURSO é ensinar; instrutores ministram muitos cursos, e um curso é ministrado por um instrutor. A participação seria determinada pela situação real, mas escolheremos uma para o nosso exemplo. Em termos mais precisos, diríamos da seguinte forma:
FIGURA 8.3 Um diagrama ER \(com apenas chaves primárias\) mostrando um banco de dados ALUNO/CURSO/INSTRUTOR.  


#### 8.4.1.1 Padrão 4—x:y::1:M, Do Lado 1, Participação Parcial

+ Versão curta: Um instrutor pode ministrar muitos cursos.

que na verdade significa:

+ Versão mais longa: Um instrutor, mas não necessariamente todos os instrutores \(registrados no banco de dados\), pode ministrar muitos \(um ou mais\) cursos. Alguns instrutores podem não ministrar cursos.



#### 8.4.1.2 Padrão 1—x:y::M:1, Do Lado M, Participação Total

+ Resumindo: os cursos devem ser ministrados por instrutores.

que significa:

+ Longo: Os cursos registrados no banco de dados devem ser ministrados por apenas um instrutor. Nenhum curso é ministrado por mais de um instrutor.

Neste diagrama \(Figura 8.3\), a entidade INSTRUTOR está relacionada à entidade CURSO. Pode haver um relacionamento entre as entidades INSTRUTOR e ALUNO, mas os relacionamentos na Figura 8.3 são considerados os únicos existentes. Pode-se argumentar que os outros relacionamentos possíveis são orientador, mentor, conselheiro, coach, etc., mas lembre-se de que estamos modelando apenas o que existe e não o que poderia ser. Assumimos que o diagrama representa as informações fornecidas por um usuário a um analista e apenas as informações fornecidas.



### 8.4.2 Adicionando mais atributos que evoluem para entidades

Agora, considere adicionar um edifício a cada uma das entidades. Os alunos moram em edifícios \(dormitórios\), os cursos são ministrados em edifícios \(salas de aula e laboratórios\) e os instrutores têm escritórios em edifícios. "Edifício" pode ser adicionado como um atributo de cada uma das três entidades e não considerado uma entidade em si. Por que não é uma entidade? Nesta fase, não expressamos o desejo de registrar informações sobre edifícios. Se edifícios \(dormitórios, salas de aula, escritórios\) fossem considerados como itens de atributo para entidades apropriadas, teríamos o diagrama ER como na Figura 8.4.
FIGURA 8.4 Um diagrama ER \(com apenas chaves primárias\) mostrando um banco de dados ALUNO/CURSO/INSTRUTOR com atributos de construção. 
Agora, adicionamos edifícios ao nosso banco de dados \(Figura 8.4\). Suponhamos que evoluamos novamente para o ponto em que decidimos que queremos registrar mais informações sobre edifícios — ou, em outras palavras, queremos tornar EDIFÍCIO uma entidade. Teríamos então que conectar outras entidades a EDIFÍCIO com relacionamentos apropriados. Tal projeto é ilustrado na Figura 8.5 \(apenas os atributos-chave são mostrados\). Quer comecemos com a ideia de EDIFÍCIO como uma entidade ou evoluamos para ela começando com ALUNOS, CURSOS e INSTRUTORES, precisamos constantemente nos perguntar: "Este item no diagrama ER é um item sobre o qual queremos registrar informações ou não?". Deveria ser uma entidade? Na Figura 8.5, descrevemos EDIFÍCIO como uma entidade com apenas atributos-chave. Na evolução do nosso banco de dados, adicionaremos atributos às entidades assim que o diagrama em forma de quadro estiver claro. Para um diagrama ER aprimorado com mais atributos e cardinalidades, veja a Figura 8.6.
FIGURA 8.5 Diagrama ER \(com apenas chaves primárias\) mostrando um banco de dados ALUNO/CURSO/INSTRUTOR/EDIFÍCIO   FIGURA 8.6 Diagrama ER mostrando um banco de dados ALUNO/CURSO/INSTRUTOR/EDIFÍCIO.  
Ponto de verificação 8.1

1. Na Figura 8.6, por que BUILDING é uma entidade e não um atributo de outra entidade? 
2. Por que o atributo room\_number está anexado ao relacionamento lives\_in em vez da entidade STUDENT? 
3. O que fará você decidir se um atributo deve ser conectado a ENTITYA ou ENTITYB ou ao relacionamento que conecta ENTITYA e ENTITYB? 
4. Por que todas as linhas que saem de BUILDING \(na Figura 8.6\) são linhas únicas \(participação parcial\)? 
5. De acordo com a Figura 8.6, um aluno precisa se matricular em um curso? 
6. De acordo com a Figura 8.6, quantos cursos um instrutor pode ministrar? 
7. De acordo com a Figura 8.6, um instrutor precisa ministrar um curso? 
8. De acordo com a Figura 8.6, um curso precisa ser ministrado por um instrutor? 
9. De acordo com a Figura 8.6, um curso pode ser ministrado por quantos instrutores?



## 8.5 MAIS EVOLUÇÃO DO BANCO DE DADOS

Vamos reconsiderar o diagrama ER da Figura 8.6. À medida que o diagrama é analisado, o usuário pode se perguntar: Por que o atributo room\_number não está incluído no relacionamento de classe? Por que não há um número de escritório para o relacionamento de escritório? Pode haver vários motivos para a omissão:

1. Esta informação não foi mencionada na fase de análise. 
2. Os dados não são necessários \(pode haver apenas uma sala de aula por prédio, ou os números dos escritórios podem não ser registrados para os orientadores\). 
3. Foi um descuido, e os dados devem ser adicionados.

Suponhamos que agora esteja decidido que room\_number é importante para todos os relacionamentos ou entidades. Suponhamos que queremos identificar o número da sala associado a instrutores e prédios, cursos e prédios, e alunos e prédios. Podemos "evoluir" o diagrama para a Figura 8.7.
FIGURA 8.7 Diagrama ER mostrando um banco de dados ALUNO/CURSO/INSTRUTOR/PRÉDIO com room\_number adicionado aos relacionamentos quando necessário. 
Na Figura 8.7, temos o número do cômodo como um atributo de relacionamento. Neste caso, também adicionamos informações anexadas a BUILDING: bldg\_number, ocupação, supervisor de manutenção e pés quadrados.



## 8.6 ATRIBUTOS QUE EVOLUEM EM ENTIDADES

Nesta seção, ilustramos mais uma vez a ideia de modelar "o que é" e não necessariamente "o que poderia ser". Além disso, vemos novamente como um atributo pode se tornar uma entidade. Suponha que, no processo de design, você receba alguns dados de um usuário e seja instruído a projetar o banco de dados. Suponha que o seguinte seja sugerido:

Aqui, você tem um nome de curso, um número de curso, horas de crédito, um instrutor e um livro. O diagrama ER inicial pode se parecer com a Figura 8.8. Por que "pode se parecer com..."? A resposta está em obter os requisitos corretos do nosso usuário.
FIGURA 8.8 Entidade CURSO com Atributos. 
Se todas as informações a serem registradas sobre esses dados fossem mencionadas, este diagrama ER de entidade única poderia descrever parte do banco de dados. No entanto, pode-se argumentar realisticamente que as coisas que descrevemos como atributos poderiam ser entidades. Tanto o instrutor quanto o livro deveriam ser candidatos a serem diagramados como entidades, se o banco de dados pretendido assim o exigisse. Já concluímos que o instrutor deveria ser uma entidade.

Suponhamos que ajustemos o banco de dados para incluir mais informações sobre os instrutores. Se esse fosse o caso, poderíamos ir além do registro de instructor\_id e instructor\_name e incluir atributos como o departamento do instrutor, data de contratação e a instituição de ensino onde o instrutor obteve o diploma final. Com as informações adicionais sobre o INSTRUTOR, a parte do diagrama ER com INSTRUTOR e CURSO teria duas entidades e se pareceria com a Figura 8.9.
FIGURA 8.9 Diagrama ER do banco de dados COURSE-INSTRUCTOR com INSTRUCTOR como uma entidade fraca. 
Na Figura 8.9, descrevemos a entidade INSTRUCTOR como fraca devido à dependência de COURSE. Além disso, presume-se que os nomes dos instrutores podem não ser únicos. Se o instrutor fosse identificado exclusivamente com um atributo como instructor\_id ou instructor\_ssno \(número do Seguro Social\) e os instrutores pudessem existir independentemente do curso, a entidade poderia se tornar forte e se pareceria com a Figura 8.10. O objetivo desta seção é mostrar que uma entidade não é uma entidade apenas porque alguém pode querer registrar informações "algum dia". Teria que haver alguma intenção planejada para incluir os dados que seriam identificados pela entidade. Além disso, a definição de entidade fraca ou forte dependeria das informações fornecidas. O usuário deve ser questionado: como os instrutores serão identificados exclusivamente?
FIGURA 8.10 Diagrama ER do banco de dados COURSE-INSTRUCTOR com INSTRUCTOR como uma entidade forte. 
Por fim, se nenhuma informação sobre instrutores tivesse sido planejada, a Figura 8.8 poderia muito bem descrever o banco de dados. Deixaremos como exercício a extensão da Figura 8.10 para incluir BOOK como entidade.



## 8.7 RELACIONAMENTOS RECURSIVOS

Em um relacionamento recursivo, a mesma entidade participa mais de uma vez em papéis diferentes. Relacionamentos recursivos também são chamados de relacionamentos unários.

Considere o departamento de recursos humanos de uma empresa. Os funcionários provavelmente têm um número de funcionário, um nome e assim por diante. Além de existir como uma entidade para todos os funcionários de uma organização, existem relacionamentos entre os indivíduos do conjunto de entidades, funcionários. O relacionamento mais óbvio é o de funcionário-supervisor. Como representaríamos o relacionamento funcionário-supervisor quando temos apenas uma entidade? A resposta é mostrada na Figura 8.11.
FIGURA 8.11 Um relacionamento recursivo clássico: FUNCIONÁRIO-SUPERVISOR 
A Figura 8.11 mostra a entidade PERSONNEL com alguns atributos. Em seguida, o relacionamento supervisionar é adicionado e conectado a PERSONNEL em ambas as extremidades. A cardinalidade do relacionamento é 1:N, com o supervisor de algum funcionário supervisionando muitos outros funcionários e funcionários tendo um supervisor. Usamos a participação parcial do lado do supervisor, pois nem todos os funcionários são supervisores — um funcionário pode supervisionar muitos outros funcionários. A participação do funcionário supervisionado também é parcial. Embora a maioria dos funcionários seja supervisionada por um supervisor, alguns funcionários estarão no topo da hierarquia sem supervisor. Em relacionamentos recursivos, estamos representando uma hierarquia. Todas as hierarquias têm uma posição superior sem "supervisão" \(no que diz respeito ao banco de dados\). Todas as hierarquias são sempre parciais-parciais.

Portanto, quando surge um relacionamento entre indivíduos dentro do mesmo conjunto de entidades, seria impróprio ter duas entidades, visto que a maioria das informações nelas contidas é basicamente a mesma. Se criássemos duas entidades, teríamos redundância no banco de dados. Usando o exemplo dado, se usássemos duas entidades diferentes em vez de um relacionamento recursivo, um funcionário seria registrado em dois locais diferentes.



### 8.7.1 Relacionamentos recursivos e restrições estruturais

Relacionamentos recursivos só podem ter participação parcial, mas a cardinalidade pode ser de um para um, de um para muitos e de muitos para muitos. A participação total em um relacionamento recursivo significaria que cada instância de uma entidade participa de um relacionamento consigo mesma, o que não faria sentido.

A seguir, veremos alguns exemplos de cardinalidades interpretadas em relacionamentos recursivos usando nosso exemplo de banco de dados de recursos humanos.



#### 8.7.1.1 Relacionamento recursivo um-para-um \(participação parcial em ambos os lados\)

A Figura 8.12 apresenta um exemplo de uma entidade, PERSONNEL, relacionada a si mesma por meio de um relacionamento casado\_com. Isso significa que uma pessoa neste banco de dados pode ser casada com outra pessoa neste mesmo banco de dados. Neste exemplo, temos um relacionamento que não é uma hierarquia.
FIGURA 8.12 Relacionamento recursivo um-para-um \(participação parcial em ambos os lados\). 
Alguns exemplos desse relacionamento são mostrados na Figura 8.13. Nela, podemos ver que Seema é casada com Dev Anand, Arpan é casado com Rekha e assim por diante.
FIGURA 8.13 Instâncias de relacionamento recursivo um-para-um \(participação parcial em ambos os lados\). 




#### 8.7.1.2 Relacionamento recursivo um-para-muitos \(participação parcial em ambos os lados\)

O relacionamento recursivo um-para-muitos \(participação parcial de ambos os lados\) é a cardinalidade mais comum em relacionamentos recursivos. Um exemplo desse relacionamento pode ser quando um funcionário supervisiona muitos outros funcionários \(como mostrado na Figura 8.14\). Como mencionamos, esse é um relacionamento hierárquico e é sempre parcial-parcial.
FIGURA 8.14 Relacionamento recursivo um-para-muitos \(participação parcial em ambos os lados\). 
Exemplos dessa relação são mostrados na Figura 8.15. Nela, podemos ver que Tom Smith supervisiona Sudip Bagui e Tim Vaney, Rishi Kapoor supervisiona Mala Saha e Korak Gupta, Korak Gupta supervisiona Roop Mukerjee e assim por diante.
FIGURA 8.15 Instâncias de relacionamento recursivo um-para-muitos \(participação parcial em ambos os lados\).   


#### 8.7.1.3 Relacionamento recursivo muitos-para-muitos \(parcial em ambos os lados\)

No exemplo do relacionamento recursivo muitos-para-muitos \(parcial em ambos os lados\), poderíamos dizer que os cursos podem ser pré-requisitos para zero ou mais outros cursos. Essa relação é ilustrada na Figura 8.16. O sentido de pré-requisito aqui não é hierárquico, mas sim como uma situação para a qual existem muitos cursos inter-relacionados.
FIGURA 8.16 Relacionamento recursivo muitos-para-muitos \(participação parcial em ambos os lados\). 




## 8.8 RELACIONAMENTOS MÚLTIPLOS

Até agora, discutimos principalmente duas entidades com um relacionamento. Esta seção discute como duas entidades podem ter mais de um relacionamento binário.

Considere um diagrama com duas entidades: ALUNO e DOCENTE. Suponha que não tenhamos outras entidades no banco de dados. Suponha ainda que a entidade ALUNO tenha os seguintes atributos: nome, número\_do\_aluno, data\_de\_nascimento e escola\_de\_ensino\_médio\_em\_qual\_o\_aluno\_se formou. A entidade DOCENTE poderia ter os seguintes atributos: nome, número\_do\_segmento \(número\_do\_seguro\_social\), departamento, número\_do\_escritório. Ao desenvolver o diagrama, encontramos dois verbos distintos para descrever a conexão entre ALUNO e DOCENTE. ALUNOS são instruídos pelo DOCENTE, e o DOCENTE aconselha ALUNOS. Há dois relacionamentos distintos que precisamos adicionar ao nosso diagrama: instruir e aconselhar. Cada relacionamento distinto recebe seu próprio losango. O diagrama ER para essa situação é mostrado na Figura 8.17A.
FIGURA 8.17A Diagrama ER com duas entidades e dois relacionamentos 
Neste diagrama, todos os relacionamentos são arbitrariamente representados como parciais; ou seja, haverá alguns professores que não orientam os alunos e alguns alunos que não são instruídos pelos professores. Ao construir diagramas ER, é preciso incluir quantos relacionamentos distintos existirem. Seria incorreto tentar fazer com que um relacionamento cumpra "dupla função" e represente duas ideias de relacionamento diferentes.

Neste exemplo, um embelezamento pode incluir dados de interseção para o relacionamento de instrução \(uma nota em um curso, por exemplo\). Os dados de interseção para o relacionamento de aconselhamento podem ser data\_atribuída, última\_reunião e assim por diante, conforme mostrado na Figura 8.17B.
FIGURA 8.17B Diagrama ER com duas entidades, dois relacionamentos e alguns atributos de interseção. 
A colocação de relacionamentos no diagrama ER é abordada em nossa metodologia de design ER na etapa 5, que redefinimos aqui:

A etapa original 5 era:

+  ** *Etapa 5. Conecte entidades com relacionamentos à medida que são obtidos.***  



Podemos acrescentar a esta diretriz que, se houver vários relacionamentos, eles serão adicionados ao diagrama; no entanto, isso provavelmente é redundante, então simplesmente acrescentaremos a frase \(um ou mais\):

+  ** *Etapa 5. Conecte entidades com relacionamentos \(um ou mais\) à medida que os relacionamentos são obtidos.***  



## 8.9 A RELAÇÃO DERIVADA OU REDUNDANTE

Muitos autores descrevem um relacionamento redundante ou derivado que surge em um "loop" de relacionamento, como na Figura 8.18. A noção de loop vem da ideia pictórica de que as retas formam um grafo fechado \(que se assemelha mais a um retângulo, mas vamos chamá-lo de loop\). A ideia de redundância é que, como os alunos fazem cursos e cada curso é ministrado por um instrutor, não é necessário um relacionamento "ensinado\_por", pois é possível obter essa informação sem o relacionamento extra. Se tal relacionamento existir, ele deve ser eliminado, mas há ressalvas.
FIGURA 8.18 Diagrama ER mostrando um banco de dados ALUNO/CURSO/INSTRUTOR com um relacionamento “redundante” 
Primeiro, é preciso ter certeza de que a relação redundante é realmente redundante. Se a relação adicionada fosse advice\_by em vez de teach\_by, então a relação deveria permanecer, pois tem um sentido completamente diferente de teach\_by.

Em segundo lugar, se o laço de relacionamento estiver presente, isso pode significar que apenas um dos dois relacionamentos redundantes deve ser mantido, e a semântica deve apontar para qual deles. Na Figura 8.18, o INSTRUCTOR provavelmente está relacionado a um COURSE \(Curso\) do que a um STUDENT \(Aluno\). Portanto, a melhor escolha para qual relacionamento manter seria o original: teach \(ensinar\). Um designer poderia ter incluído o relacionamento teach\_by primeiro e, posteriormente, incluído o relacionamento teach \(ensinar\). Então, examinando os laços for do diagrama, pode-se deduzir que teach\_by era redundante.

Terceiro, um ou ambos os relacionamentos podem ter um atributo de interseção para sugerir qual relacionamento \(ou ambos\) deve ser mantido. Na Figura 8.19, incluímos o atributo de tempo, que foi adicionado ao relacionamento de ensino, pois um instrutor ministra um curso em um horário específico.
FIGURA 8.19 Diagrama ER mostrando um banco de dados ALUNO/CURSO/INSTRUTOR com um relacionamento “redundante” e um atributo de tempo 
A ideia de relações derivadas ou redundantes nos faz sugerir mais um passo em nossa metodologia:

+  ** *Etapa 6b. Examine o diagrama em busca de laços que possam indicar relações redundantes. Se uma relação for realmente redundante, exclua-a.***  



Ponto de verificação 8.2

1. O que é um relacionamento recursivo? 
2. O que você procuraria se estivesse tentando ver se um relacionamento é recursivo? 
3. Que tipos de restrições estruturais os relacionamentos recursivos podem ter? 
4. Relacionamentos recursivos podem ter participação plena? Por que sim ou por que não? 
5. Como o relacionamento recursivo é denotado diagramáticamente no modelo ER do tipo Chen? 
6. As mesmas duas entidades podem ter mais de um relacionamento? 
7. Como você determinaria se um relacionamento é redundante?



## 8.10 OPCIONAL: UMA NOTAÇÃO ER ALTERNATIVA PARA ESPECIFICAR RESTRIÇÕES ESTRUTURAIS EM RELACIONAMENTOS

Chamamos a Seção 8.10 de "seção opcional" porque adiciona informações ao diagrama ER; no entanto, as informações adicionadas não são necessárias para mapear o diagrama a um banco de dados funcional. Alguns podem achar esta seção descritiva útil; outros podem considerá-la injustificada.

Até agora, discutimos as razões de cardinalidade em termos de seus limites superiores \(a cardinalidade máxima\), representados por M ou N nos diagramas ER \(mostrados neste e nos capítulos anteriores\). Você se lembrará \(do Capítulo 6\) que a cardinalidade é uma medida aproximada do número de instâncias de entidades em um conjunto de entidades que podem ser relacionadas a instâncias em outro conjunto de entidades.

Nesta seção, descrevemos uma notação ER alternativa para especificar restrições estruturais em relacionamentos. Essa notação associará um par de números \(mín., máx.\) a cada restrição estrutural de um relacionamento. Esses valores mínimo e máximo podem fornecer mais informações sobre as entidades e como elas se relacionam.

O mínimo é o número mínimo de instâncias em um conjunto de entidades relacionadas a uma instância de outra entidade. O mínimo pode estar entre zero e o máximo, o máximo. Se o mínimo for zero, implica que todas as instâncias de uma entidade não precisam participar do relacionamento. Se o mínimo for zero, implica participação parcial. Se o mínimo for maior que zero, implica participação total. Apresentamos agora um diagrama ER com \(mín, máx\) no lugar de 1 e M.

Primeiro, vamos começar com o relacionamento recursivo mostrado na Figura 8.20.
FIGURA 8.20 Relacionamento recursivo com proporções \(mín., máx.\). 
O \(mín., máx.\) de \(0, 1\) significa que cada pessoa na entidade PESSOAL pode ou não ser casada \(mostrado pelo zero para o mínimo\) e só pode ser casada com no máximo uma outra pessoa \(mostrado pelo máximo\).

Em seguida, observe a Figura 8.21. A partir desta figura, podemos dizer que um aluno não pode ser orientado por nenhum docente e pode ser orientado por até dois docentes \(representado pelo mínimo de zero e máximo de dois\). Um docente pode orientar entre 0 e 30 alunos e pode instruir entre 0 e 40 alunos. E um aluno deve ser instruído por um docente e pode ser instruído por até dois docentes neste banco de dados. Com a notação mín./máx., é opcional \(embora redundante\) manter a restrição de participação de linha única/dupla. Como a notação de linha única/dupla é tão comum, sugerimos mantê-la.
FIGURA 8.21 Diagrama ER mostrando uma notação ER alternativa para especificar restrições estruturais.  
Ponto de verificação 8.3 \(Opcional\)

1. Qual limite inferior de cardinalidade a participação plena implica? 
2. O que implica uma relação mín./máx. de \(1, 1\) entre duas entidades? 
3. Que tipo de proporção de participação \(participação total ou parcial\) uma proporção mín./máx. de \(0, 1\) implica?



## 8.11 REVISÃO DA METODOLOGIA

Para revisar, nossa metodologia para projetar diagramas ER agora evoluiu para:



### 8.11.1 Metodologia de Projeto ER

+  ** *Etapa 1. Selecione uma entidade primária na descrição dos requisitos do banco de dados e mostre os atributos a serem registrados para essa entidade. Identifique as chaves, se apropriado, e mostre alguns dados de exemplo.***  
+  ** *Etapa 2. Use inglês estruturado para entidades, atributos e chaves para descrever o banco de dados obtido.***  
+  ** *Etapa 3. Examine os atributos nas entidades existentes \(primárias\) \(possivelmente com assistência do usuário\) para descobrir se as informações sobre uma das entidades devem ser registradas.***  

\(Mudamos “primário” para “existente” porque refazemos a etapa 3 conforme adicionamos novas entidades.\)

+  ** *Etapa 3a. Se forem necessárias informações sobre um atributo, torne o atributo uma entidade e, em seguida,***  
+  ** *Etapa 3b. Defina o relacionamento de volta à entidade original.***  
+   ** *Passo 4. Se outra entidade for apropriada, desenhe a segunda entidade com seus atributos. Repita os passos 2 e 3 para ver se essa entidade deve ser dividida em mais entidades.***  
+  ** *Etapa 5. Conecte entidades com relacionamentos \(um ou mais\), se houver relacionamentos.***  
+  ** *Passo 6. Indique a natureza exata das relações em inglês estruturado, de todos os ângulos. Por exemplo, se uma relação é A:B::1:M, então há uma relação de A\(1\) para B\(M\) e de B\(M\) de volta para A\(1\).***  
+  ** *Etapa 6a. Examine a lista de atributos e determine se algum deles precisa ser identificado por duas \(ou mais\) entidades. Em caso afirmativo, coloque o atributo em um relacionamento apropriado que una as duas entidades.***  
+  ** *Etapa 6b. Examine o diagrama em busca de laços que possam indicar relações redundantes. Se uma relação for realmente redundante, exclua-a.***  
+  ** *Etapa 7. Mostre alguns dados de exemplo.***  
+  ** *Etapa 8. Apresente o banco de dados "como projetado" ao usuário, completo com os termos em inglês para entidades, atributos, chaves e relacionamentos. Refine o diagrama conforme necessário.***  

A gramática para descrever nossas entidades, atributos e chaves evoluiu conforme discutido a seguir.



### 8.11.2 A Entidade

Este banco de dados registra dados sobre ENTIDADE. Para cada ENTIDADE no banco de dados, registramos att\(1\), att\(2\), att\(3\), … att\(n\).



#### 8.11.2.1 Os Atributos

+ Para atributos atômicos, att\(j\): 
+ Para cada ENTIDADE, haverá apenas um att\(j\). O valor de att\(j\) não será subdividido. 
+ Para atributos compostos, att\(j\): 
+ Para cada ENTIDADE, registraremos att\(j\), que é composto de x, y, z,. … \(x, y, z\) são as partes componentes de att\(j\). 
+ Para atributos multivalorados, att\(j\): 
+ Para cada ENTIDADE, registraremos att\(j\). Pode haver mais de um att\(j\) registrado para cada ENTIDADE. 
+ Para atributos de relacionamentos, att\(j\): 
+ Para o relacionamento entre ENTIDADE1 e ENTIDADE2, registraremos um\(a\) att\(j\). O att\(j\) depende de ambas as entidades, ENTIDADE1 e ENTIDADE2, para identificação.



#### 8.11.2.2 As Chaves

Para a\(s\) chave\(s\):

1.  
Mais de uma chave candidata \(entidade forte\):

Para cada ENTIDADE, teremos as seguintes chaves candidatas: att\(j\), att\(k\), … \(onde j, k são atributos de chaves candidatas\).

2.  
Uma chave candidata \(entidade forte\):

Para cada ENTIDADE, teremos a seguinte chave primária: att\(j\)

3.  
Nenhuma chave candidata \(talvez uma entidade fraca\):

Para cada ENTIDADE, não assumimos que nenhum atributo será único o suficiente para identificar entidades individuais.

4.  
Nenhuma chave candidata \(talvez uma entidade de interseção\):

Para cada ENTIDADE, não assumimos que nenhum atributo será único o suficiente para identificar entidades individuais.




## 8.12 REGRAS DE MAPEAMENTO PARA RELACIONAMENTOS RECURSIVOS

Relacionamentos recursivos são relacionamentos binários 1:1, 1:N ou M:N. Discutimos as regras de mapeamento para esses tipos de relacionamentos no Capítulo 6. Normalmente, a cardinalidade é 1:N.

No Capítulo 6, a regra de mapeamento foi discutida para duas entidades. Se houver apenas uma entidade \(como em um relacionamento recursivo\), as regras permanecem basicamente as mesmas, mas a entidade única é vista como duas entidades, ENTIDADE\_A e ENTIDADE\_B. A chave primária é regravada na mesma tabela com uma conotação ou função diferente. Dois tipos de regras de mapeamento podem ser desenvolvidos para mapear entidades recursivas.

+ Regra de Mapeamento 12 — Mapeamento de relacionamentos recursivos 1:N. Reinclua a chave primária da tabela com o relacionamento recursivo na mesma tabela, atribuindo a ela um nome de função diferente.

Por exemplo, a Figura 8.11 será mapeada para

+ PESSOAL\(nome, nome, minit, id\_funcionário, super\_id\)

O employee\_id é a chave primária da relação PERSONNEL. O super\_id também é um employee\_id, mas sua função e conotação são diferentes. A Tabela 8.1 fornece alguns dados de exemplo.
TABELA 8.1 Dados de amostra para PESSOAL na Figura 8.11.   **nome de usuário**  **nome**  **minit**  **ID do funcionário**  **super\_id**    
* * *
      `Richard`  `Earp`  `w`  `8945`  `9090`    `Boris`  `Yelsen`   `9090`  `null`    `Helga`  `Hogan`  `H`  `3841`  `9090`    `Sudip`  `Bagui`  `K`  `8767`  `9090`    `Tina`  `Tanner`   `5050`  `8945`      
+ Regra de Mapeamento 13 — Mapeando relacionamentos recursivos M:N. Crie uma tabela separada para o relacionamento \(como na regra de mapeamento 5\).

Suponha que consideremos a recursão curso-pré-requisito, na qual os cursos têm muitos pré-requisitos, e um curso pode ser um pré-requisito para muitos cursos. Nesse caso, a maneira mais simples de fazer é criar uma tabela separada apenas para o relacionamento. A Tabela 8.2 mostra um exemplo de relacionamento recursivo.
TABELA 8.2 Mapeamento do relacionamento recursivo da Figura 8.16.   **Curso**  **Pré-requisito**    
* * *
      `COP2222`  `COP1111`    `COP2223`  `COP1111`    `COP3333`  `COP2222`    `COP1111`  `null`    `COP2222`  `COP1112`    `COP1112`  `COP1111`      
Ponto de verificação 8.4

1. Mapeie o relacionamento recursivo mostrado na Figura 8.14 para um banco de dados relacional e mostre alguns dados de exemplo. 
2. Se a Figura 8.14 fosse um relacionamento M:N, como você mapearia esse relacionamento recursivo para um banco de dados relacional? Mostre o mapeamento com alguns dados de exemplo.





## 8.13 RESUMO DO CAPÍTULO

Este capítulo analisou diferentes aspectos dos relacionamentos binários em diagramas ER e refinou várias etapas da metodologia de projeto ER. O refinamento da metodologia de projeto ER significa uma avaliação e reavaliação contínuas do diagrama ER desenhado após discussão com os usuários. A ideia de que relacionamentos podem ter atributos, como os atributos evoluem para entidades, relacionamentos recursivos e relacionamentos derivados e redundantes foi discutida com exemplos e diagramas. As etapas da metodologia de projeto ER foram refinadas para incluir todas essas informações na nova e evolutiva metodologia. Perto do final do capítulo, uma notação ER alternativa para especificar restrições estruturais em relacionamentos foi apresentada. Ao concluir este capítulo, o leitor ou criador de banco de dados deverá ser capaz de projetar eficientemente um banco de dados com relacionamentos binários. O próximo capítulo trata de relacionamentos ternários e outros de ordem superior.





## CAPÍTULO 8 EXERCÍCIOS

Em cada um dos exercícios a seguir, a advertência para “construir um diagrama ER” implica não apenas o diagrama, mas também a descrição gramatical estruturada do diagrama.



### Exercício 8.1

Defina e declare em termos precisos a cardinalidade e a participação na Figura 8.6, o banco de dados aluno/curso/instrutor/prédio. Discuta as restrições estruturais da Figura 8.6. Quais são as participações? Quais são as cardinalidades? Em que circunstâncias as representadas estariam corretas ou incorretas?



### Exercício 8.2

Considere os seguintes dados: nome do cavalo, corrida, proprietário, probabilidades no posto, posição no posto, data da corrida, ordem de chegada, ganhos acumulados no ano, nome e endereço do proprietário. Construa um diagrama ER e use gramática estruturada para racionalizar suas restrições.



### Exercício 8.3

No capítulo, descrevemos um banco de dados com duas entidades, CURSO e INSTRUTOR \(consulte a Figura 8.10\). Livro foi mantido como um atributo de CURSO. Expanda o banco de dados para incluir LIVRO como uma entidade. Os atributos de LIVRO podem incluir título do livro, autor, preço, edição e editora.



### Exercício 8.4

Consulte a Figura 8.7. Altere a Figura 8.7 para incluir as seguintes informações: Um prédio pode ter no máximo 99 alunos morando nele. Um aluno precisa se matricular em pelo menos uma turma e pode se matricular em no máximo cinco turmas. Uma turma precisa ter no mínimo 5 alunos e pode se matricular no máximo 35 alunos. Um instrutor pode ou não dar uma turma e pode dar até três turmas. Um curso deve ter um instrutor ensinando-o, e apenas um instrutor pode dar um curso específico. Um instrutor pode ou não ter um escritório e pode ter até dois escritórios. Um prédio pode ou não ter um escritório e pode ter até 15 escritórios. Um curso deve ser oferecido em uma sala de aula e só pode ser oferecido em uma sala de aula.



## ESTUDO DE CASO



### West Florida Mall \(continuação\)

Até agora, em nosso estudo de caso, desenvolvemos as principais entidades e relacionamentos e os mapeamos para um banco de dados relacional \(com alguns dados de amostra\). Em seguida, revisamos a etapa 7, que diz:

+  ** *Etapa 7. Apresente o banco de dados "como projetado" ao usuário, completo com os termos em inglês para entidades, atributos, chaves e relacionamentos. Refine o diagrama conforme necessário.***  

Suponha que recebemos alguma entrada adicional do usuário:

+ Um funcionário também pode ser gerente de departamento, e um gerente de departamento pode gerenciar, no máximo, um departamento. Precisamos armazenar informações sobre o gerente de departamento: nome, número do Seguro Social, loja em que trabalha e departamento. Um gerente de departamento supervisiona pelo menos um funcionário e pode gerenciar vários.

Ao revisar essas especificações adicionais, podemos ver que temos um relacionamento recursivo em desenvolvimento, já que um funcionário pode ser um gerente de departamento supervisionando outros funcionários.

Então, usando a regra de mapeamento 12, incluiremos novamente a chave primária da entidade EMPLOYEE nela mesma, nos dando a seguinte relação EMPLOYEE:

+ FUNCIONÁRIO\(nome, essn, dnum, snum, z\)

E, com alguns dados de amostra, conforme mostrado na Tabela 8.3.
TABELA 8.3 Dados de amostra para FUNCIONÁRIO.   **ename**  **essn**  **dnum**  **snum**  **dm\_ssn**    
* * *
      `Kaitlyn`  `987–754–9865`  `501`  `1`  `276–263–9182`    `Fred`  `276–263–9182`  `502`  `1`  `null`    `Katie`  `982–928–2726`  `503`  `1`  `987–754–9865`    `Seema`  `837–937–9373`  `501`  `1`  `276–263–9182`    .       .       .        
Essa relação recursiva também é mostrada na Figura 8.22.
FIGURA 8.22 Diagrama ER do shopping West Florida desenvolvido até agora. 
Então, em resumo, nosso banco de dados relacional agora se desenvolveu para \(sem os dados\)
**SHOPPING CENTER**     *nome*   *endereço*      **LOJA**    *sloc*  *nome*   *snum*   *nome\_do\_shopping*  *então\_ssn*  *sm\_ssn*      **PROPRIETÁRIO**    então\_ssn  *nome\_de\_esse*  *então\_off\_phone*  *então\_endereço*      **GERENTE DE LOJA**     *sm\_ssn*   *sm\_nome*  *salário*       **DEPARTAMENTO**    *nome do domínio*   *dnum*    *snum*       **FUNCIONÁRIO**    *ename*   *essn*   *snum*  *dm\_ssn* dnum   
Continuaremos o desenvolvimento deste estudo de caso no final do próximo capítulo.



## BIBLIOGRAFIA

+ Earp, R. e Bagui, S. \(2000\). Relacionamentos binários em diagramas entidade-relacionamento \(ER\). Data Base Management Journal, 22: 10–43. 
+ Elmasri, R., e Navathe, S.B. \(2016\). Fundamentos de Sistemas de Banco de Dados. Reading, MA: Addison-Wesley. 
+ Sanders, L. \(1995\). Modelagem de Dados. Danvers, MA: Boyd & Fraser. 
+ Teorey, T.J., Nadeau, T. e Lightstone, S.S. \(2005\). Modelagem e Design de Banco de Dados: Design Lógico. São Francisco, CA: Morgan Kaufman.





# 9 Diagramas ER ternários e de ordem superior



DOI: 10.1201/9781003314455-9



## 9.1 INTRODUÇÃO

Todos os relacionamentos com os quais lidamos até agora foram relacionamentos binários. Embora relacionamentos binários pareçam naturais para a maioria de nós, na realidade às vezes é necessário conectar três ou mais entidades. Se um relacionamento conecta três entidades, ele é chamado de relacionamento ternário ou triário. Se um relacionamento conecta mais de três entidades \(n entidades\), ele é chamado de relacionamento n-ário, onde n é igual ao número de entidades participantes do relacionamento. Os relacionamentos n-ários \(n ≥ 3\) também são chamados de relacionamentos de ordem superior.

Neste capítulo, consideramos relacionamentos que conectam três ou mais entidades. Primeiro, examinamos relacionamentos ternários \(tri-ários\) que surgem por três razões principais:

1. Se tivermos atributos de intersecção que exijam três entidades diferentes para identificar um atributo de intersecção 
2. Se temos um relacionamento de um relacionamento 
3. Se fizermos engenharia reversa

Como discutimos engenharia reversa no Capítulo 11, não discutimos o desenvolvimento de relacionamentos ternários a partir da engenharia reversa neste capítulo.

Neste capítulo, discutimos primeiro como os atributos de interseção criam relacionamentos ternários e, em seguida, analisamos as restrições estruturais. Em seguida, discutimos como relacionamentos ternários e outros relacionamentos n-ários não impedem relacionamentos binários com as mesmas entidades e como alguns diagramas ternários podem ser resolvidos em relacionamentos binários. O desenvolvimento de relacionamentos ternários a partir de relacionamentos de relacionamentos também é apresentado. A etapa 6 da metodologia de projeto entidade-relacionamento \(ER\) é redefinida neste capítulo para incluir relacionamentos ternários e outros relacionamentos de ordem superior.



## 9.2 RELACIONAMENTO BINÁRIO OU TERNÁRIO?

Relacionamentos ternários são necessários quando relacionamentos binários não são suficientes para descrever com precisão a semântica de uma associação entre três entidades. Nesta seção, explicamos a diferença entre um relacionamento binário e um ternário com a ajuda de um exemplo e mostramos como um atributo de interseção necessita de um relacionamento ternário.

Quando existem relacionamentos binários entre entidades, esses relacionamentos têm restrições estruturais \(cardinalidade e participação\). Além disso, descobrimos que atributos de relacionamentos também eram possíveis. Em particular, descobrimos que o relacionamento M:N frequentemente gerava um atributo que chamamos de atributo de interseção \(lembre-se do relacionamento M:N ALUNO/CLASSE e do atributo de interseção nota, como mostrado na Figura 8.1\). No caso do relacionamento binário, ressaltamos que um atributo como nota inferiria que um relacionamento binário M:N deve existir.

O caso comum em que surgem relacionamentos n-ários é quando existem dados que devem estar relacionados a mais de duas entidades. Considere este exemplo: você tem um banco de dados para uma empresa contendo as entidades PRODUTO, FORNECEDOR e CLIENTE. Os relacionamentos comuns podem ser PRODUTO/FORNECEDOR; a empresa compra produtos de um fornecedor — um relacionamento binário normal. O atributo de interseção para PRODUTO/FORNECEDOR é preço\_de\_atacado \(como mostrado na Figura 9.1A\). Agora, considere a entidade CLIENTE e o cliente compra produtos. Se todos os clientes compram produtos, independentemente do fornecedor, você tem um relacionamento binário simples entre CLIENTE e PRODUTO. Para o relacionamento CLIENTE/PRODUTO, o atributo de interseção é preço\_de\_varejo \(como mostrado na Figura 9.1B\).
FIGURA 9.1A Relação binária entre PRODUTO e FORNECEDOR e um atributo de interseção, wholesale\_price.   FIGURA 9.1B Relação binária entre PRODUTO e CLIENTE e um atributo de interseção, preço\_de\_varejo. 
Alguns dados de amostra para a Figura 9.1A seriam mostrados na Tabela 9.1.
TABELA 9.1 Dados de amostra para a Figura 9.1A.   **ID do produto**  **ID do fornecedor**  **preço de atacado**    
* * *
      `Beans`  `Acme Bean Co`  `1.4`    `Beans`  `Baker Bean Co`  `1.57`    `Carrots`  `Joe’s Carrots`  `0.89`     
Alguns dados de amostra para a Figura 9.1B seriam mostrados na Tabela 9.2.
TABELA 9.2 Dados de amostra para a Figura 9.1B.   **ID do cliente**  **ID do produto**  **preço de varejo**    
* * *
      `Jones`  `Beans`  `2.67`    `Smith`  `Beans`  `2.67`    `Jones`  `Carrots`  `1.57`     
Agora, considere um cenário diferente. Suponha que o cliente compre produtos, mas o preço dependa não apenas do produto, mas também do fornecedor. Suponha que você precise de um customerID, um productID e um supplierID para identificar um preço. Você tem então um atributo que depende de três entidades; portanto, você tem um relacionamento entre três entidades \(um relacionamento ternário\) com um atributo de interseção, preço. Essa situação é ilustrada na Figura 9.2.
FIGURA 9.2 Diagrama ER \(com apenas chaves primárias\) mostrando um relacionamento triplo. 
A Figura 9.2 representa as entidades PRODUTO, FORNECEDOR e CLIENTE e um relacionamento, comprar, entre todas as três entidades, mostrado por um único losango de relacionamento anexado a todas as três entidades.

Alguns dados de amostra para a Figura 9.2 seriam mostrados na Tabela 9.3.
TABELA 9.3 Dados de amostra para a Figura 9.2.   **ID do cliente**  **ID do produto**  **ID do fornecedor**  **preço**    
* * *
      `Jones`  `Beans`  `Acme`  `2.65`    `Jones`  `Beans`  `Baker`  `2.77`    `Jones`  `Carrots`  `Joe’s`  `1.57`     
Este caso ternário é mais realista, pois os clientes geralmente pagam preços diferentes pelo mesmo produto de diferentes fabricantes ou fornecedores. Para diferentes fornecedores, também se pode presumir preços diferentes para um produto em diferentes momentos. Além disso, para os clientes, pode-se presumir que alguns itens são comprados em promoção, outros não. Outro atributo de interseção \(na Figura 9.2\) poderia ser data, que pode ser a data da venda de um produto a um cliente fornecido por um fornecedor específico.

Em seguida, analisamos as restrições estruturais dos relacionamentos ternários.



## 9.3 RESTRIÇÕES ESTRUTURAIS PARA RELACIONAMENTOS TERNÁRIOS

Relacionamentos ternários podem ter os seguintes tipos de restrições estruturais: x:y:z, onde x, y e/ou z podem ser 1 ou "M". O "M" para cada x, y ou z não precisa ser a mesma letra. Exemplos: 1:1:1, 1:M:N, M1:M2:M3, M:1:N, etc. Cada relacionamento pode ter participação total ou parcial em cada um dos lados. A seguir, um exemplo do relacionamento M1:M2:M3 com participação parcial em todos os lados.



### 9.3.1 Muitos para muitos para muitos \(M1:M2:M3\)

A Figura 9.3 mostra um exemplo de relacionamento M1:M2:M3 usando as três entidades PRODUTO, FORNECEDOR e CLIENTE, todas com participação parcial. Esta figura mostra que muitos clientes podem comprar muitos produtos de muitos fornecedores, a preços diferentes.
FIGURA 9.3 Diagrama ER mostrando um relacionamento ternário de muitos para muitos para muitos \(participação parcial em todos os lados\). 
Exemplos desse relacionamento podem ser ilustrados conforme mostrado na Figura 9.4.
FIGURA 9.4 Instâncias de um relacionamento ternário muitos-para-muitos-para-muitos para CLIENTE:PRODUTO:FORNECEDOR  
Ponto de verificação 9.1

1. O que é uma relação ternária? 
2. O que é um relacionamento n-ário? 
3. O que são relacionamentos de ordem superior? 
4. Usando as três entidades apresentadas \(PRODUTO, FORNECEDOR e CLIENTE\), desenhe um diagrama ER que descreva o seguinte: Um cliente deve comprar um e somente um produto de um fornecedor a um preço específico em uma data específica. 
5. Usando as três entidades apresentadas \(PRODUTO, FORNECEDOR e CLIENTE\), desenhe um diagrama ER representando o seguinte: Um fornecedor deve fornecer muitos produtos para muitos clientes a preços diferentes em datas diferentes. 
6. Pense em mais alguns atributos de intersecção para o exemplo ternário PRODUTO, FORNECEDOR e CLIENTE apresentado na Figura 9.3. 
7. Quais situações podem criar cada uma das seguintes restrições estruturais? PRODUTO:FORNECEDOR:CLIENTE::1:1:1, participação parcial de todos os ladosPRODUTO:FORNECEDOR:CLIENTE::1:M:N, participação parcial de todos os ladosPRODUTO:FORNECEDOR:CLIENTE::1:1:1, participação total de todos os lados



## 9.4 UM EXEMPLO DE UMA RELAÇÃO N-ÁRIA

Um relacionamento n-ário descreve a associação entre n entidades. Para o nosso exemplo ternário, dissemos que o preço era dependente de um PRODUTO, FORNECEDOR e CLIENTE. Se tivermos uma situação em que o preço é dependente de um PRODUTO, FORNECEDOR, CLIENTE, bem como do ESTADO, então o preço é dependente de quatro entidades; portanto, é um relacionamento n-ário \(neste caso, um relacionamento quádruplo\). Em um relacionamento n-ário \(ou, neste caso, quádruplo\), um único losango de relacionamento conecta as n \(4\) entidades, como mostrado na Figura 9.5. O atributo de interseção é preço. \(Mais atributos não intersecionais nas entidades poderiam ocorrer, mas não foram incluídos no diagrama.\)
FIGURA 9.5 Diagrama ER mostrando a relação n-ária   


## 9.5 RELACIONAMENTOS N-ÁRIOS NÃO EXCLUEM RELACIONAMENTOS BINÁRIOS

Só porque existe uma relação ternário não significa que não existam relações binárias entre as entidades. Usando o exemplo de CLIENTES, VENDEDORES e PRODUTOS, suponha que vendedores varejistas e fornecedores de produtos tenham uma relação especial que não envolve clientes, como no atacado, com uma estrutura de preços totalmente diferente. Essa relação binária pode ser mostrada separadamente e em adição à relação ternário. Consulte a Figura 9.6 para uma versão básica deste diagrama ER de relacionamento bidirecional \(binário\) e de relacionamento tridirecional \(ternário\) no mesmo banco de dados.
FIGURA 9.6 Diagrama ER \(com apenas chaves primárias\) mostrando um relacionamento triplo e um relacionamento bidirecional. 
A Figura 9.6 nos mostra que temos um relacionamento binário entre PRODUTO e FORNECEDOR, com todos os PRODUTOS e FORNECEDORES participando. Tanto o FORNECEDOR quanto o CLIENTE compram o PRODUTO, mas no relacionamento binário FORNECEDOR-PRODUTO, a ação é comprar no atacado; portanto, o relacionamento é rotulado como comprar\_atacado e não envolve o cliente. Alteramos o relacionamento ternário para comprar\_varejo para distinguir os dois relacionamentos.



## 9.6 METODOLOGIA E GRAMÁTICA PARA A RELAÇÃO N-ÁRIA

Precisamos revisitar a etapa 6 da metodologia de design ER para abordar a possibilidade da relação n-ária. A versão antiga era:

+   ** *Etapa 6. Indique a natureza exata dos relacionamentos no inglês estruturado de todos os lados. Por exemplo, se um relacionamento é A:B::1:M, então há um relacionamento de A para B, 1 para Muitos e de B de volta para A, Muitos para 1.***  

Adicionamos a seguinte frase ao passo 6:

+  **Para relacionamentos ternários e de ordem superior \(n-ário\), descreva o relacionamento em inglês estruturado, tendo o cuidado de mencionar todas as entidades do relacionamento n-ário. Declare as restrições estruturais conforme elas existem.** 

A gramática para o relacionamento n-ário deve envolver todas as entidades a ele vinculadas. Portanto, uma frase informal adequada seria algo como isto:

+ ENTIDADE1 Relacionamento \(de/para/por\) ENTIDADE2 \(e\) \(de/para/por\) ENTIDADE3. Entende-se que esse atributo exigirá a nomeação de todas as n entidades para identificá-lo.

Aqui, se escolhermos alguma combinação para Entidade1, … Entidaden, esse processo se resolve em

+  
Entidade1: CLIENTE

Relacionamento: comprar

Atributo de relacionamento: preço\_de\_varejo

+ Entidade2: PRODUTO 
+ Entidade3: FORNECEDOR 
+ CLIENTES compram PRODUTOS de FORNECEDORES. Entende-se que o preço de varejo exigirá a referência a todas as três entidades para identificá-lo.

Com um relacionamento binário, precisamos declarar dois relacionamentos. Seria de se esperar que, com relacionamentos ternários, estaríamos obrigados a declarar três. Como o atributo de relacionamento já foi declarado, vejamos as outras possibilidades:

Suponha

+ Entidade1: PRODUTO 
+ Entidade2: CLIENTE 
+ Entidade3: FORNECEDOR 
+ OS PRODUTOS são comprados pelos CLIENTES dos FORNECEDORES.

Na versão informal da declaração do diagrama, pouca informação é obtida pela repetição. Sugere-se que outras combinações sejam tentadas; no entanto, na declaração informal, parece provável que uma declaração, inferida da semântica da situação, seja suficiente para declarar informalmente a natureza do relacionamento.



### 9.6.1 Uma gramática mais exata

Uma gramática mais exata para o relacionamento n-ário seria uma extensão daquela desenvolvida para o relacionamento binário. Diferentemente do caso informal, em uma apresentação gramatical mais formal, seriam necessárias três afirmações para um relacionamento ternário, uma começando com cada entidade. No relacionamento binário, caso de participação plena M:N, utilizamos a descrição do relacionamento apresentada a seguir.



#### 9.6.1.1 Padrão 3 — M:N, Do Lado M, Participação Plena

+ Resumindo: x deve estar relacionado a muitos y.

o que na verdade significa

+ ***Longo****: x, registrado no banco de dados, deve estar relacionado a muitos \(um ou mais\) y. Nenhum x está relacionado a um não-****e*** *\(ou\) Não-x não estão relacionados a um****e*** *. \(O negativo dependerá do sentido da afirmação.\)* 

Poderíamos generalizar os padrões de restrição estrutural para o padrão dado a seguir.



#### 9.6.1.2 Padrão 3—k:M, do lado k, Participação total \(k = 1 ou N\)

+ Curto: O mesmo que na Seção 9.6.1.1. 
+ Longo: O mesmo que na Seção 9.6.1.1.

Para o relacionamento n-ário, estendemos a notação da declaração generalizada usando o operador booleano “e”, conforme mostrado a seguir.



#### 9.6.1.3 Padrão 5 \(n-ário\)—x:y:z::a:b:c, Do lado a, Participação total/parcial

+ Resumindo: x deve/pode estar relacionado a muitos y e muitos z.

O "must" representa participação plena; "may" representa participação parcial. A cardinalidade a não importa. Os verbos b e c nos obrigam a dizer "um" ou "muitos" na declaração. Assim, por exemplo, para x como pleno:

+  
Longo: x, registrado no banco de dados, deve estar relacionado a

b = m \[muitos \(um ou mais\)\] y

b = 1 um e somente um y

e \(ou outra palavra de ligação apropriada \[de, por, para, …\]\)

c = m \[muitos \(um ou mais\)\] z

c = 1 um e somente um z

Nenhum x está relacionado a mais de um z.

Nenhum x está relacionado a mais de um y.


EXEMPLO 9.1

Para CLIENTES:PRODUTOS:FORNECEDORES::M1:M2:M3, participação total em todos os aspectos:

+ Resumindo: OS CLIENTES devem comprar muitos PRODUTOS de muitos FORNECEDORES. 
+ Longo: CLIENTES, registrados no banco de dados, devem comprar muitos \(um ou mais\) PRODUTOS de muitos \(um ou mais\) FORNECEDORES.

Outras expressões gramaticais são derivadas de forma semelhante.

+ Os produtos registrados no banco de dados devem ser comprados por muitos \(um ou mais\) clientes de muitos \(um ou mais\) fornecedores. 
+ Os fornecedores, registrados no banco de dados, devem vender muitos \(um ou mais\) produtos para muitos \(um ou mais\) clientes.

+ Um aspecto negativo poderia ser: Nenhum cliente \(neste banco de dados\) compra produtos de não fornecedores.

Assim como nos casos binários, as declarações negativas seriam opcionais, se fizessem sentido.



### 9.6.2 Gramática em uma Participação Parcial, Relacionamento Ternário com um Relacionamento M1:1:M2

Consideremos a Figura 9.7. Nesta figura, estamos tentando representar um banco de dados sobre uma cerimônia de formatura com a presença de alguns alunos e professores. Grosso modo, estamos tentando dizer que alguns ALUNOS comparecem a uma determinada GRADUAÇÃO com algum CORPO DOCENTE; alguns CORPOS DOCENTES comparecem a uma GRADUAÇÃO com alguns ALUNOS, e todas as GRADUAÇÕES são frequentadas por alguns ALUNOS e algum CORPO DOCENTE. O atributo de interseção é derived\_attendance.
FIGURA 9.7 Diagrama ER \(com apenas chaves primárias\) mostrando um relacionamento triplo com participações parciais e um relacionamento unidirecional 
Aqui, temos participação parcial nos relacionamentos de cardinalidade M e um relacionamento de um com participação total. Usando a gramática apresentada, temos este resultado:

+ ALUNO:FORMAÇÃO:FACULDADE ::M1:1:M2 
+ Resumo: Os alunos podem participar de uma formatura com vários professores.
+   ** *Longo*** *: Os alunos, cadastrados no banco de dados, poderão frequentar \(b = 1\) uma e somente uma formatura* 
+  ** *com***  
+ \(c = m\) \[muitos \(um ou mais\)\] professores. 
+ Nenhum aluno participa de mais de uma formatura \[com muitos professores\].

Colocamos \[com muitos professores\] entre colchetes porque não é realmente necessário para dar sentido ao diagrama.

De forma similar:

+ O corpo docente, registrado no banco de dados, pode comparecer a uma formatura com muitos alunos. Alguns professores não comparecem à formatura \[com muitos alunos\]. As formaturas devem ser frequentadas por alguns alunos e alguns professores. Nenhuma formatura acontece sem alguns alunos e alguns professores.



## 9.7 RELACIONAMENTOS TERNÁRIOS A PARTIR DE SITUAÇÕES DE RELACIONAMENTO-RELACIONAMENTO

Outro cenário em que relacionamentos ternários se tornam necessários é quando se desenvolve um cenário que resulta em um relacionamento de um relacionamento. Diagramas ER do tipo Chen não permitem relacionamentos de relacionamentos; portanto, para representar essa situação corretamente, precisamos desenvolver um relacionamento ternário.

Por exemplo, vamos começar com duas entidades: EDITORA\_DE\_LIVROS e MANUSCRITO. Podemos inicialmente relacionar as duas entidades como mostrado na Figura 9.8A. Uma EDITORA\_DE\_LIVROS pode revisar muitos MANUSCRITOS.
FIGURA 9.8A Um relacionamento binário entre BOOK\_PUBLISHER e MANUSCRIPT. 
Em um estágio posterior, se algum MANUSCRITO resultar em um LIVRO após ser revisado, isso exigirá um relacionamento de relacionamento, como mostrado na Figura 9.8B. Esse relacionamento de relacionamento se torna necessário aqui porque a EDITORA\_DO\_LIVRO, as revisões e o MANUSCRITO, tomados em conjunto, resultam em um LIVRO, como mostrado na Figura 9.8C.
FIGURA 9.8B Um relacionamento de um relacionamento.   FIGURA 9.8C Um relacionamento de um relacionamento com uma classe agregada de nível superior composta por EDITORA DE LIVROS, resenhas e MANUSCRITO. 
Na Figura 9.8C, BOOK\_PUBLISHER, o relacionamento de revisões e MANUSCRIPT, considerados juntos, são como criar uma classe agregada de nível superior composta por BOOK\_PUBLISHER, revisões e MANUSCRIPT.

Essa classe agregada \(das duas entidades e um relacionamento\) precisa então estar relacionada a BOOK, conforme mostrado na Figura 9.8C.

Como não podemos mostrar um relacionamento de um relacionamento para representar essa situação, precisamos criar uma entidade fraca RESENHA e relacioná-la a EDITORA\_LIVRO, MANUSCRITO e LIVRO, como mostrado na Figura 9.8D. O relacionamento BMR conecta EDITORA\_LIVRO, MANUSCRITO e RESENHA. Essa resenha pode resultar em um LIVRO \(como mostrado na Figura 9.8D\).
FIGURA 9.8D Um relacionamento de um relacionamento resolvido em um relacionamento ternário. 
Na Figura 9.8D, priorizamos a entidade fraca REVIEW porque, sem uma resenha, não há livro; tanto o manuscrito quanto a editora devem contribuir para a resenha. Se tentássemos conectar o livro ao manuscrito sem a editora, não representaríamos a situação real.



## 9.8 RELACIONAMENTOS N-ÁRIOS QUE PODEM SER RESOLVIDOS EM RELACIONAMENTOS BINÁRIOS

Só porque três entidades estão relacionadas não implica necessariamente uma relação ternário. Nesta seção, mostramos como algumas relações ternárias podem e não podem ser resolvidas em relações binárias.

Assim como o relacionamento binário M:N pode ser decomposto em dois relacionamentos 1:M, muitos relacionamentos n-ários também podem ser decompostos. Primeiro, observe a decomposição do M:N em dois relacionamentos 1:M na Figura 9.9. A ideia é tornar o relacionamento uma entidade e, assim, formar dois relacionamentos binários mais simples.
FIGURA 9.9 Diagrama ER de um relacionamento M:N substituído por dois relacionamentos 1:M. 
Em seguida, vamos analisar novamente a Figura 9.7. Se decompormos a Figura 9.7 em três relacionamentos binários, temos a Figura 9.10. Na Figura 9.10, a nova entidade FREQUÊNCIA é fraca e depende das três entidades CORPO DOCENTE, ALUNO e GRADUAÇÃO para sua existência. O sentido de FREQUÊNCIA-FINAL seria uma lista de participantes para um evento de cerimônia de GRADUAÇÃO.
FIGURA 9.10 Diagrama ER \(com apenas chaves primárias\) mostrando um relacionamento triplo “decomposto” em três relacionamentos binários.  
Ponto de verificação 9.2

1. Todas as relações ternárias podem ser expressas na forma de relações binárias? Explique. 
2. Pense em alguns atributos e entidades de um relacionamento que você acha que poderia ser um relacionamento ternário. Esse relacionamento pode ser expresso na forma de um relacionamento binário?



## 9.9 MAPEAMENTO DE RELACIONAMENTOS N-ÁRIOS PARA UM BANCO DE DADOS RELACIONAL

Nesta seção, desenvolvemos regras de mapeamento para mapear relacionamentos n-ários para um banco de dados relacional.

+ Regra de Mapeamento 14 — Mapeando relacionamentos n-ários. Para cada relacionamento n-ário, crie uma nova relação. Na nova relação, inclua as chaves das entidades conectadas e quaisquer atributos do relacionamento. Transforme as chaves das entidades conectadas na chave primária concatenada da nova relação.

Por exemplo, veja a Figura 9.2; você tem um relacionamento ternário chamado comprar, que relaciona PRODUTO, FORNECEDOR e CLIENTE. Há um atributo de interseção, preço. As relações mapeadas seriam:

+ COMPRAR\(preço, ID do produto, ID do fornecedor, ID do cliente\) 
+ PRODUTO\(IDdoproduto, …\) 
+ FORNECEDOR\(IDdoFornecedor, …\) 
+ CLIENTE\(IDdocliente, …\)

E alguns dados de amostra seriam mostrados nas Tabelas 9.4–9.7.
TABELA 9.4 Dados de amostra para COMPRA na Figura 9.2.   ** *preço***   ** *ID do produto***   ** *fornecedorlD***   ** *clientelD***     
* * *
      `$87.10`  `TAG1`  `F1`  `PENS`    `$83.98`  `TAG2`  `G25`  `MOB`    `$95.25`  `TAG3`  `G20`  `DEL`    `$99.10`  `TAG4`  `F4`  `GULF`      TABELA 9.7 Dados de amostra para CLIENTE na Figura 9.2.   * **clientelD***  …    
* * *
      `PENS`     `MOB`     `DEL`     `…`       TABELA 9.5 Dados de amostra para PRODUTO na Figura 9.2.   ** *produtolD***  …    
* * *
      `TAG1`     `TAG2`     `TAG3`     `…`        TABELA 9.6 Dados de amostra para FORNECEDOR na Figura 9.2.   ** *fornecedorlD***  …    
* * *
      `F1`     `G25`     `G20`     `…`       
Ponto de verificação 9.3

1. A Figura 9.5 poderia ser descrita na forma de relações binárias? Discuta. 
2. Que regras de mapeamento você seguiria para mapear a Figura 9.5? 
3. Mapeie a Figura 9.5 para um banco de dados relacional e mostre alguns dados de exemplo.



## 9.10 REVISÃO DA METODOLOGIA

Nossa metodologia de design de ER finalmente evoluiu para a seguinte apresentação:



### 9.10.1 Metodologia de Projeto ER

+  ** *Etapa 1. Selecione uma entidade primária da descrição dos requisitos do banco de dados e mostre os atributos a serem registrados para essa entidade. Identifique as chaves, se apropriado, e mostre alguns dados de exemplo.***  
+  ** *Etapa 2. Use inglês estruturado para entidades, atributos e chaves para descrever o banco de dados obtido.***  
+   ** *Etapa 3. Examine os atributos nas entidades existentes \(possivelmente com assistência do usuário\) para descobrir se as informações sobre uma das entidades devem ser registradas.***  

\(Mudamos de primário para existente porque refazemos a etapa 3 conforme adicionamos novas entidades.\)

+  ** *Etapa 3a. Se forem necessárias informações sobre um atributo, torne o atributo uma entidade e, em seguida,***  
+  ** *Etapa 3b. Defina o relacionamento de volta à entidade original.***  
+  ** *Passo 4. Se outra entidade for apropriada, desenhe a segunda entidade com seus atributos. Repita os passos 2 e 3 para ver se essa entidade deve ser dividida em mais entidades.***  
+  ** *Etapa 5. Conecte entidades com relacionamentos \(um ou mais\), se houver relacionamentos.***  
+  **Passo 6. Declare a natureza exata dos relacionamentos em inglês estruturado de todos os lados. Por exemplo, se um relacionamento é A:B::1:M, então há um relacionamento de A\(1\) para B\(M\) e de B\(M\) de volta para A\(1\). Para relacionamentos ternários e de ordem superior \(n-ários\), declare o relacionamento em inglês estruturado, tendo o cuidado de mencionar todas as entidades para o relacionamento n-ário. Declare as restrições estruturais conforme elas existem.** 
+  ** *Etapa 6a. Examine a lista de atributos e determine se algum deles precisa ser identificado por duas \(ou mais\) entidades. Em caso afirmativo, coloque o atributo em um relacionamento apropriado que una as duas entidades.***  
+  ** *Etapa 6b. Examine o diagrama em busca de laços que indiquem relações redundantes. Se uma relação for realmente redundante, exclua-a.***  
+  ** *Etapa 7. Mostre alguns dados de exemplo.***  
+  ** *Etapa 8. Apresente o banco de dados "como projetado" ao usuário, completo com os termos em inglês para entidades, atributos, chaves e relacionamentos. Refine o diagrama conforme necessário.***  





## RESUMO DO CAPÍTULO 9.11

Relacionamentos binários são os mais comuns. Algumas notações de diagramas ER não possuem expressões para relacionamentos ternários ou outros relacionamentos de ordem superior; ou seja, tudo é expresso em termos de um relacionamento binário. Neste capítulo, mostramos como a necessidade de relacionamentos ternários surge de situações únicas. Por exemplo, atributos de interseção surgem precisando de todas as três entidades tomadas em conjunto para sua identificação. Relacionamentos ternários também podem ser desenvolvidos por meio de engenharia reversa, e isso é discutido no Capítulo 11. Além disso, neste capítulo, discutimos as restrições estruturais de relacionamentos ternários e sua gramática em detalhes e mostramos como alguns relacionamentos ternários ou n-ários podem ser resolvidos em relacionamentos binários. A seção final deste capítulo discutiu regras de mapeamento para relacionamentos n-ários.





## CAPÍTULO 9 EXERCÍCIOS



### Exercício 9.1

No Capítulo 8, descrevemos um banco de dados com duas entidades, CURSO e INSTRUTOR. "Livro" foi mantido como um atributo de CURSO. Amplie o banco de dados para incluir livro como entidade. Atributos de livro podem incluir título do livro, autor, preço, edição e editora. Explore os relacionamentos que podem existir aqui: use "em" ou "por", "escrever", "ensinar" e assim por diante. Desenhe um diagrama ER com pelo menos dois relacionamentos, um deles ternário. Quais seriam alguns atributos dos relacionamentos?



### Exercício 9.2

Construa um diagrama ER para uma corretora, um título e um comprador. Inclua no diagrama o preço do título, a comissão paga, o nome e endereço da corretora, o nome e endereço do comprador, a bolsa de valores, o símbolo e o preço do título. Inclua no diagrama o número de ações do título detidas por um comprador \(você pode optar por incluir essa informação por corretora ou não\).



### Exercício 9.3

Usando três entidades — INSTRUTOR, CLASSE e SALA — desenhe um diagrama ER para representar o seguinte: cada CLASSE em uma SALA tem um INSTRUTOR, mas cada INSTRUTOR em uma SALA pode ter várias CLASSES, e cada INSTRUTOR de uma CLASSE ocupa várias SALAS. Inclua as cardinalidades no diagrama.



### Exercício 9.4

Crie um diagrama ER com uma relação ternária. Desenhe o diagrama ER e escreva suas cardinalidades. Este diagrama ER também pode ser desenhado como relações binárias? Por que sim ou por que não?



## BIBLIOGRAFIA

+ Elmasri, R., e Navathe, S.B. \(2016\). Fundamentos de Sistemas de Banco de Dados. Reading, MA: Addison-Wesley. 
+ Teorey, T.J., Nadeau, T. e Lightstone, S.S. \(2005\). Modelagem e Design de Banco de Dados: Design Lógico. São Francisco, CA: Morgan Kaufman. 
+ Teorey, T.J., Yang, D. e Fry, J.P. \(1986\). Uma metodologia de design lógico para bancos de dados relacionais usando o modelo entidade-relacionamento estendido. ACM Computing Surveys, 18\(2\): 197–222.





# 10 O Modelo Entidade-Relacionamento Aprimorado \(EER\)



DOI: 10.1201/9781003314455-10



## 10.1 INTRODUÇÃO

Nos primeiros capítulos deste livro, apresentamos o diagrama entidade-relacionamento \(ER\) como uma ferramenta conceitual para bancos de dados. A abordagem que adotamos no desenvolvimento de um diagrama ER foi modelar a realidade para um usuário. Embora tenhamos trabalhado nos fundamentos do diagrama ER, há situações em que o modelo básico falha em descrever completamente a realidade dos dados a serem armazenados. Com o aumento dos tipos de aplicações de banco de dados, os conceitos básicos da modelagem ER \(como originalmente desenvolvidos por Chen\) não foram suficientes para representar os requisitos de aplicações mais complexas, como generalizações e especializações \(hierarquias de classes\). Um modelo ER que suporta esses conceitos semânticos adicionais é chamado de modelo entidade-relacionamento aprimorado \(EER\) \(Elmasri e Navathe, 2016\). Neste capítulo, discutimos generalizações e especializações no modelo EER e desenvolvemos uma metodologia e gramática para essa extensão. Também discutimos subclasses e categorias compartilhadas ou tipos de união. Apresentamos uma metodologia para mapear o diagrama EER para um banco de dados relacional.



## 10.2 O QUE É UMA GENERALIZAÇÃO OU ESPECIALIZAÇÃO?

O modelo EER inclui todos os conceitos do modelo ER original e conceitos adicionais de generalizações/especializações \(hierarquias de classes\). Generalizações e especializações estão associadas à ideia de superclasses, subclasses e herança de atributos. Como exemplo de hierarquia de classes, suponha que temos esta entidade CLIENTE em um banco de dados de uma loja que vende equipamentos esportivos:

+ CLIENTE\(número\_do\_cliente, nome, endereço\)

Agora, suponha que o banco de dados evolua para uma situação na qual queremos manter informações pertinentes a esportes específicos para alguns clientes:

+ GOLF\(número\_cliente, handicap, marca\_clube\_preferido\) 
+ BASEBALL\(número\_cliente, posição, tamanho\_de\_batata\_preferido\)

As entidades GOLFE e BASEBOL são subclasses \(especializações\) dentro de CLIENTE \(uma generalização\). Este exemplo ilustra uma hierarquia na qual CLIENTE está no topo da hierarquia de classes e os esportes específicos são subclasses.

Em um ambiente orientado a objetos, poderíamos designar as entidades assim:

+ CLIENTE\(número\_do\_cliente, nome, endereço\) 
+ CLIENTE.GOLFE\(handicap,marca\_clube\_preferido\) 
+ CLIENTE.BASEBOL\(posição, tamanho\_de\_batata\_preferido\)

A inferência em programação orientada a objetos é GOLF, que é uma subclasse de CUSTOMER. Embora não seja especificado, CUSTOMER. GOLF herda todos os atributos de CUSTOMER, além de possuir atributos pertinentes a GOLF. O exemplo é de especialização — o processo de pensamento começou com uma classe, CUSTOMER, e depois se especializou para esportes específicos.

A ideia de classes em um banco de dados implica a capacidade de descrever subclasses e superclasses com recursos de herança.

Como exemplo de generalização, suponha que temos uma entidade ALUNO contendo informações sobre alunos. Mas suponha que quiséssemos armazenar informações sobre todas as pessoas em uma instituição — não apenas alunos, mas também funcionários e docentes. Podemos pensar em uma superclasse chamada PESSOA contendo uma subclasse para ALUNO, outra subclasse para FUNCIONÁRIOS e ainda outra subclasse para DOCENTES. Claramente, as informações sobre cada uma dessas subclasses de PESSOA contêm informações pertinentes a essa subclasse. No entanto, a entidade da superclasse PESSOA conteria informações comuns a todas essas subclasses. PESSOA pode conter um nome, endereço e número de telefone. Quando a subclasse FUNCIONÁRIOS foi definida, ela herdaria esses atributos da superclasse e definiria mais atributos pertinentes a FUNCIONÁRIOS. A superclasse em um banco de dados é chamada de generalização, e as subclasses \(ALUNO, FUNCIONÁRIOS e DOCENTES\) são chamadas de especializações.

O conceito de classes inclui o uso de atributos simples, como vimos. Na programação orientada a objetos, o conceito de classe também inclui ações executadas por membros da classe. Assim como na tipagem de dados, os bancos de dados tendem a se concentrar mais em atributos do que em ações procedurais.



## 10.3 VARIANTES

Uma maneira pela qual os programadores, no passado, resolviam o problema das especializações era criar variantes. Variantes são partes de registros que variam de acordo com outras partes do registro. Para ilustrar variantes e seu uso em diagramas ER, considere este problema:

Suponha que temos uma entidade com valores que variam de acordo com "a situação". Por exemplo, suponha que estamos modelando estudantes-atletas e cada atleta pratica algum esporte. Obviamente, registraríamos informações sobre o estudante ou atleta — um nome, um identificador único, como um número de estudante, e talvez alguma outra informação. Mas, por outro lado, gostaríamos de registrar algumas informações sobre o esporte que o estudante-atleta pode praticar. Suponhamos que temos uma tabela ATLETA \(Tabela 10.1\) com esse tipo de dados.
TABELA 10.1 Tabela ATLETA.   **estudante**  **aluno\_nº**  **outro**  **esporte**  **informação**    
* * *
      `Baker`  `123456789`   `tennis`  `220, state rank 14`    `Adams`  `123456788`   `football`  `tackle, neck brace`    `Jones`  `123455676`   `golf`  `handicap 3`     
O atributo info tem valores diferentes para diferentes esportes. Esses valores diferentes são chamados de variantes. Embora a introdução de variantes em registros pareça resolver um problema de representação de dados, ela causa problemas de armazenamento e recuperação em bancos de dados. Em um banco de dados, espera-se que todas as informações em uma coluna de uma tabela sejam consistentes. Os números dos alunos podem conter nove dígitos; portanto, todos os valores na coluna student\_no conteriam um número de nove dígitos. Com variantes, esse não é o caso. A tabela ATHLETE contém informações inconsistentes em colunas na coluna info. Esse problema de variantes em um banco de dados foi resolvido de várias maneiras ao longo dos anos.

Uma solução para o problema de variantes em registros e atributos variáveis em entidades nos diagramas ER é remover a variante e referenciá-la de volta à chave primária da informação "pai". Abordamos o problema desta forma:

Em diagramas ER, reconhecemos que estamos armazenando informações sobre duas coisas diferentes, mas relacionadas: uma generalização chamada ATLETAS, que têm um nome, ID e assim por diante, e especializações, que são ESPORTES \(tênis, futebol americano, golfe etc.\), cada uma com seus próprios atributos. Como estamos armazenando informações sobre duas coisas, por que não criar uma entidade chamada ESPORTES e, em seguida, relacionar o ATLETA à entidade ESPORTES? Uma entidade ESPORTES não funcionaria porque a entidade ESPORTES seria muito genérica; gostaríamos de armazenar informações diferentes sobre esportes diferentes e específicos. Além disso, queremos armazenar informações sobre um esporte no que diz respeito a cada aluno-atleta.

Por que, então, não criaríamos uma série de entidades fracas — uma para cada esporte — dependendo do ATLETA? A resposta é que poderíamos fazer isso, mas existe uma maneira melhor de analisar esse problema, que, como se vê, resultará no mesmo banco de dados que usar uma entidade/relacionamento fraco, mas nos oferece uma maneira alternativa de apresentar as informações de ER com diagramas mais expressivos para incluir o conceito de herança.



## 10.4 EXEMPLOS DE GENERALIZAÇÕES OU ESPECIALIZAÇÕES

Generalizações e especializações são categorizações de entidades para as quais a entidade de especialização pode resultar de generalizações contendo variantes. Essas variantes são mais facilmente tratadas removendo a variante da generalização, tratando-a como uma entidade de subclasse e deixando a "parte fixa" original da entidade como uma superclasse ou tipo pai. Se nos referíssemos à superclasse como classe pai, chamaríamos as partes variantes de subclasses, as classes filhas.

Levando a ideia de superclasse/subclasse pai-filho um pouco mais adiante, podemos imaginar a classe filha herdando as características da classe pai. Herança, neste contexto, significa que a classe filha terá definidos quaisquer atributos definidos na classe pai. Em um banco de dados relacional, a vinculação da classe filha à classe pai \(portanto, juntando as informações da classe pai e da classe filha\) é feita usando operadores de combinação de tabelas chamados junções. Em nosso exemplo ESPORTES, consideraríamos ATLETA como uma classe pai e ESPORTES como uma classe filha, portanto, quando definimos informações sobre um esporte, isso é feito no contexto de manter a possibilidade de herdar informações da classe pai, ATLETA, por meio de uma operação de junção.

Se estivéssemos projetando o banco de dados para estudantes-atletas e percebêssemos que gostaríamos de registrar um nome, um identificador pessoal \(ssno\), endereço e assim por diante, poderíamos começar com a generalização \(ou pai ou superclasse\). Em seguida, decidiríamos registrar um jogador em um esporte e algumas informações sobre o esporte em si. O esporte do jogador é considerado uma especialização da classe ATLETA. Essa abordagem de projeto pode ser caracterizada como de cima para baixo.

Se tivéssemos projetado o banco de dados e começado com esportes, poderíamos ter uma entidade TÊNIS, uma entidade FUTEBOL e assim por diante para cada atleta, apenas para reconhecer que essas entidades podem ser generalizadas em uma entidade ATLETA \(uma superclasse\) com esportes individuais como entidades de subclasse. Essa abordagem de projeto pode ser caracterizada como ascendente. Um relacionamento de generalização especifica vários tipos de entidades com certos atributos comuns que podem ser generalizados em uma classe de entidade de nível superior, uma entidade genérica ou superclasse.

De qualquer forma \(de baixo para cima ou de cima para baixo\), terminamos com uma entidade sendo uma superclasse \(um pai\) e a outra sendo uma subclasse \(um filho\) do pai. A necessidade de se especializar ou generalizar em design depende de onde se reconhece o problema.

Para ilustrar como podemos lidar com essa situação de generalização-especialização, classe pai-filho, suponha que definimos nossa entidade, ATLETA, assim:
> ` Entity: ATHLETE Attributes: *name, ssno, address, gender, weight, height*. ` 
O diagrama ER para esta entidade é simples e direto. Então, durante o projeto do banco de dados, decidimos adicionar informações sobre os esportes praticados pelos atletas. Podemos tentar desenhar um diagrama como a Figura 10.1 com uma bandeira esportiva variante.
FIGURA 10.1 O ATLETA com uma tentativa de adicionar um atributo variante. 
O que há de errado com a Figura 10.1? O problema é que temos atributos com atributos com atributos. A bandeira esportiva não é um atributo composto — ela não possui partes componentes. Portanto, em vez de criar atributos com atributos, criaremos entidades para cada esporte específico e, em seguida, relacionaremos essas entidades ao ATLETA.

Agora, consulte a Figura 10.2. Aqui, criamos entidades fracas para cada esporte, em vez de usar atributos de atributos. Precisamos tornar os esportes entidades fracas porque eles não têm chave primária per se — eles dependem de ATHLETE. Este diagrama ainda não conta toda a história, porque esportes não são apenas entidades fracas, mas sim, em certo sentido, "escolhas". Se os esportes fossem simplesmente entidades fracas, seria de se esperar que todas as entidades da superclasse estivessem relacionadas a cada subclasse. Este não é realmente o caso. Além disso, queremos honrar o conceito de herança.
FIGURA 10.2 O ATLETA mostrado como um atributo variante de relacionamento forte-fraco. 
O processo de especialização é concebido como um processo pelo qual a subclasse herda todas as propriedades da superclasse. Na terminologia EER, a entidade ATLETA é chamada de superclasse, e as entidades ESPORTES são chamadas de subclasses. Atributos como handicap podem ser chamados de atributos específicos, pois são específicos da subclasse em questão.

As entidades esportivas, especializações, são representadas no esquema EER, conforme ilustrado na Figura 10.3. Na Figura 10.3, criamos três entidades esportivas — partes de informação sobre as quais armazenaremos informações.
FIGURA 10.3 ATLETA com relação de sobreposição de superclasse/subclasse. 
Primeiro, na entidade ATHLETE, incluímos um atributo chamado sport. Sport é chamado de predicado definidor, pois define nossa\(s\) especialização\(ões\). Até este ponto, assumimos que os atletas praticam um esporte, e o esporte possui informações variantes. Se um atleta praticasse vários esportes, o predicado definidor deveria ser multivalorado. Referindo-se à Figura 10.3, o predicado definidor pode ser escrito na linha para unir a entidade ATHLETE ao círculo com um o nele. O círculo com um o descreve uma restrição de "sobreposição". Sobreposição significa que as entidades de subclasse unidas à superclasse podem se sobrepor; ou seja, uma entidade de superclasse pode conter mais de uma subclasse ou especialização para um determinado ATHLETE. A sobreposição \(o\) na Figura 10.3 significa que um atleta pode participar de mais de um esporte.

Se houvesse um "d" no círculo \(no lugar do "o"\) na Figura 10.3, as entidades não se sobreporiam — elas seriam disjuntas. Um "d" indicaria que os atletas participariam de apenas um esporte; ou seja, os atletas jogariam apenas golfe, apenas tênis ou apenas futebol \(mas não qualquer um dos dois juntos\). Se esse fosse o caso, o "o" minúsculo seria substituído por um "d", e "Sport", o predicado definidor, teria valor único. Como observação final sobre este diagrama, a participação da superclasse nas subclasses é opcional. Há uma única linha unindo a designação "o"/"d", significando que um atleta pode participar de um esporte — alguns atletas \(ou atletas em potencial\) não participam de um ou mais esportes.

Um exemplo de restrição disjunta é mostrado na Figura 10.4. De acordo com a Figura 10.4, todos os móveis no banco de dados são uma cadeira, uma escrivaninha ou uma mesa. Nesse caso, não há sentido de sobreposição de subclasses. Há uma designação de participação total da entidade FURNITURE para o círculo o/d. Cada peça de mobiliário deve participar de uma subclasse. Compare isso com a participação parcial no exemplo ATHLETE. A restrição disjunta especifica que, se as subclasses de uma generalização são disjuntas, então uma entidade pode ser membro de apenas uma das subclasses ou especializações. Além disso, o predicado definidor para subclasses disjuntas terá valor único.
FIGURA 10.4 Um banco de dados do Office com entidades de especialização, participação plena e relacionamento disjunto. 
Na Figura 10.4, o nome da especialização é o nome da própria entidade. Caso contrário, o predicado definidor pode ser repetido no diagrama para maior clareza.

A Figura 10.3 mostra um símbolo de subclasse \(⊂\) entre as entidades definidas pelo predicado e o círculo de restrição disjunta/sobreposta \(o/d\). "Tênis", "Golfe" e "Futebol" pertencem ao predicado definidor "Esporte". As entidades TÊNIS, GOLFE e FUTEBOL são subclasses de ATLETA. O símbolo de subclasse em cada linha que conecta uma subclasse ao círculo indica a direção da superclasse/subclasse ou do relacionamento de herança pai-filho. Na Figura 10.3, a subclasse TÊNIS, GOLFE ou FUTEBOL \(as especializações\) herdaria da entidade pai, ATLETA.

Ponto de verificação 10.1

1. O que é uma especialização? Dê um exemplo de especialização. 
2. O que é uma generalização? Dê um exemplo de generalização. 
3. O que é uma restrição disjunta? Qual símbolo representa a restrição disjunta em diagramas EER? 
4. O que é uma restrição de sobreposição? Qual símbolo representa a restrição de sobreposição em diagramas EER? 
5. O que significa o símbolo da subclasse? 
6. Por que você criaria um relacionamento de generalização/especialização em vez de criar uma “entidade fraca”? 
7. Como a “herança” se encaixa na relação superclasse/subclasse? Discuta. 
8. Qual é a diferença entre uma entidade de generalização e uma entidade regular, conforme descrito nos capítulos anteriores?



## 10.5 METODOLOGIA E GRAMÁTICA PARA RELAÇÕES DE GENERALIZAÇÃO/ESPECIALIZAÇÃO

Precisamos revisitar a etapa 6 na metodologia de design de ER para incluir relações de generalização/especialização. A versão anterior da etapa 6 era:

+   ** *Etapa 6. Indique a natureza exata dos relacionamentos no inglês estruturado de todos os lados; por exemplo, se um relacionamento é A:B::1:M, então há um relacionamento de A para B, 1 para Muitos, e de B de volta para A, Muitos para 1.***  
+  **Para relacionamentos ternários e de ordem superior \(n-ário\), descreva o relacionamento em inglês estruturado, tendo o cuidado de mencionar todas as entidades do relacionamento n-ário. Declare as restrições estruturais conforme elas existem.** 

Adicionamos a seguinte frase ao passo 6:

+  ** *Para relacionamentos de especialização/generalização, descreva o relacionamento em inglês estruturado, tendo o cuidado de mencionar todas as entidades \(subclasses ou especializações\). Declare as restrições estruturais conforme elas existem.***  

A gramática que propomos para relacionamentos de especialização/generalização é semelhante à que usamos em relacionamentos fracos. Adicionamos elementos à gramática para incluir as restrições de participação e sobreposição/disjunção \(o/d\):

A descrição gramatical para entidades fracas foi:

+ Para cada entidade fraca, não assumimos que nenhum atributo será único o suficiente para identificar entidades individuais. Como a entidade fraca não possui uma chave candidata, cada entidade fraca será identificada pela\(s\) chave\(s\) pertencente\(s\) à entidade forte.

No caso das subclasses de ATLETA, uma primeira tentativa de descrever a subclasse identificada por uma superclasse torna-se:

+ Para cada esporte, não presumimos que nenhum atributo esportivo seja único o suficiente para identificar entidades esportivas individuais. Como o esporte não possui uma chave candidata, cada esporte será identificado pela herança de chaves pertencentes a ATHLETE.

Portanto, um padrão gramatical de diagrama EER mais completo diria:

+ Para cada especialização, não assumimos que qualquer atributo será único o suficiente para identificar entidades individuais. Como a especialização não possui uma chave candidata, cada especialização será identificada pela\(s\) chave\(s\) herdada\(s\) da generalização. Além disso, as especializações se sobrepõem \[ou são disjuntas\]. \[Explique a situação de sobreposição/disjunção.\] A especialização individual é identificada por um predicado definidor, o nome do atributo, que estará contido na generalização. Se as especializações se sobrepuserem, o predicado definidor será multivalorado.

Para a Figura 10.3, o padrão se torna:

+ Para cada esporte, não presumimos que nenhum atributo seja único o suficiente para identificar entidades individuais. Como o esporte não possui uma chave candidata, cada esporte será identificado pela\(s\) chave\(s\) herdada\(s\) de ATHLETE. Além disso, os esportes se sobrepõem. Os atletas podem praticar mais de um esporte. O esporte individual é identificado por um atributo predicado definidor, sport, que estará contido em ATHLETE. Como uma pessoa pode praticar mais de um esporte, o predicado definidor é um atributo multivalorado. Os esportes que registraremos são GOLFE, TÊNIS e FUTEBOL.



## 10.6 REGRAS DE MAPEAMENTO PARA GENERALIZAÇÕES E ESPECIALIZAÇÕES

Nesta seção, apresentamos regras de mapeamento para mapear generalizações e especializações para bancos de dados relacionais. Generalizações e especializações podem ser mapeadas de diversas maneiras, e as regras para mapear generalizações e especializações para um banco de dados relacional dependem de vários fatores \(Elmasri e Navathe, 2016\):

1. As restrições totais/parciais das relações de generalização/especialização 
2. As restrições sobrepostas/disjuntas das relações de generalização/especialização 
3. O número de atributos nas especializações 
4. Se as especializações são definidas por predicado 
5. Quantas especializações existem

A Tabela 10.2 fornece um resumo das regras de mapeamento para generalizações e especializações e as situações em que funcionam melhor. As regras de mapeamento 15 e 16 criam relações múltiplas, e as regras de mapeamento 17 e 18 criam relações únicas. Em cada caso, há compensações entre bancos de dados relacionais em relação ao resultado.
TABELA 10.2 Onde cada regra de mapeamento funciona melhor.   **Regra de Mapeamento**  **Relações Criadas**  **Funciona melhor com**    
* * *
      Regra de mapeamento 15 Múltiplos • Participação total ou parcial    • Relações disjuntas ou sobrepostas  Regra de mapeamento 16 Múltiplos • Relações disjuntas    • Participação total  Regra de mapeamento 17 Solteiro • Apenas relações disjuntas    • Pode ser participação total ou parcial    • Poucos atributos na especialização    • Atributo de tipo único  Regra de mapeamento 18 Solteiro • Melhor para relacionamentos sobrepostos, mas pode ser usado para relacionamentos disjuntos        • Muitos campos de tipo — um para cada subclasse   
Nas próximas seções, explicaremos cada uma das regras de mapeamento e as compensações resultantes.



### 10.6.1 Regra de Mapeamento 15

Conforme a Tabela 10.2, a regra de mapeamento 15 funciona bem para cenários disjuntos ou sobrepostos. Essa regra também funcionaria bem se as especializações tivessem muitos atributos.

+ Regra de Mapeamento 15 — Mapeamento de generalizações e especializações com subclasses disjuntas ou sobrepostas e com restrições de participação total ou parcial \(com poucos ou muitos atributos nas especializações\). Para cada situação de entidade de generalização/especialização, crie uma relação \(tabela\) para a entidade de generalização \(se ainda não o tiver feito conforme as etapas anteriores\) e crie uma relação \(tabela\) para cada especialização. Adicione os atributos de cada entidade às suas respectivas relações. Inclua a chave primária da entidade de generalização nas relações de especialização. A chave primária das relações de especialização será a mesma que a chave primária da relação de generalização.

Assim, usando a regra de mapeamento 15, criamos uma tabela separada para a generalização \(superclasse\), bem como para cada uma das especializações \(subclasses\). Consulte a Figura 10.3. A relação generalização/especialização entre ATLETA e TÊNIS, GOLFE e FUTEBOL seria mapeada da seguinte forma:

+ ATLETA\(ssno, peso, nome, sexo, altura, \{esporte\}\) 
+ TÊNIS\(ssno, classificação\_estadual\) 
+ GOLFE\(ssno, handicap\) 
+ FUTEBOL\(ssno, posição\)

Como ATLETA na Figura 10.3 contém um atributo multivalorado, ATLETA agora se torna

+ ATLETA1\(ssno, peso, nome, sexo, altura\)

e

+ ATLETA-ESPORTE \(ssno, esporte\)

A chave da entidade de generalização ssno é adicionada às entidades de especialização TÊNIS, GOLFE e FUTEBOL como chave primária. E, como ATLETA na Figura 10.3 contém um atributo multivalorado, ATLETA-ESPORTO mapeia o atributo multivalorado.

Mostrando alguns dados de amostra, a tabela ficaria parecida com a Tabela 10.3, que se resolveria nas Tabelas 10.4–10.8.
TABELA 10.3 Dados de amostra para ATLETA na Figura 10.3.   **ssno**  **peso**  **nome**  **gênero**  **altura**  **esporte**    
* * *
      `239-92-0983`  `140`  `Kumar`  `M`  `5.95`  `golf`    `398-08-0928`  `200`  `Kelvin`  `M`  `6.02`  `football`    `322-00-1234`  `135`  `Sarah`  `F`  `5.6`  `tennis`    `873-97-9877`  `165`  `Arjun`  `M`  `6.01`  `golf`    `876-09-9873`  `145`  `Deesha`  `F`  `5.5`  `tennis, golf`      TABELA 10.4 Dados de amostra para ATH LETE1 na Figura 10.3.   **ssno**  **peso**  **nome**  **gênero**  **altura**    
* * *
      `239-92-0983`  `140`  `Kumar`  `M`  `5.95`    `398-08-0928`  `200`  `Kelvin`  `M`  `6.02`    `322-00-1234`  `135`  `Sarah`  `F`  `5.6`    `873-97-9877`  `165`  `Arjun`  `M`  `6.01`    `876-09-9873`  `145`  `Deesha`  `F`  `5.5`      TABELA 10.5 Dados de amostra para ATLETA-ESPORTE na Figura 10.3.   **ssno**  **esporte**    
* * *
      `239-92-0983`  `golf`    `398-08-0928`  `football`    `322-00-1234`  `tennis`    `873-97-9877`  `golf`    `876-09-9873`  `tennis`    `876-09-9873`  `golf`      TABELA 10.6 Dados de amostra para TÊNIS na Figura 10.3.   **ssno**  **classificação\_estadual**    
* * *
      `322-00-1234`  `23`    `876-09-9873`  `47`      TABELA 10.7 Dados de amostra para GOLF na Figura 10.3.   **ssno**  **deficiência**    
* * *
      `239-92-0983`  `3`    `873-97-9877`  `1`      TABELA 10.8 Dados de amostra para FUTEBOL na Figura 10.3.   **ssno**  **posição**    
* * *
      `398-08-0928`  `tackle`    `239-92-0983`  `quarterback`    `398-08-0928`  `full back`     
A única dificuldade com esse mapeamento é que ele gera tabelas um tanto atípicas em um banco de dados relacional. Em um banco de dados relacional comum, espera-se uma tabela com um atributo de junção. Aqui, o atributo de junção é um nome de tabela em vez de um valor de atributo. Se a restrição o/d fosse d \(disjunto\), o predicado definidor de esporte teria um valor único, a tabela ATLETA original teria apenas um valor para esporte e a decomposição de ATLETA em ATLETA1 e ATLETA-ESPORTE seria desnecessária.



### 10.6.2 Regra de mapeamento 16

A regra de mapeamento 16 funciona melhor com subclasses disjuntas e quando o relacionamento é total entre a generalização e as especializações.

+ Regra de Mapeamento 16 — Mapeamento de generalizações e especializações com restrições de relacionamento disjunto e participação total entre generalizações e especializações. Crie uma relação \(de subclasse\) separada para cada entidade de especialização. Inclua os atributos de cada entidade de especialização em suas respectivas relações de subclasse. Inclua também a chave primária e outros atributos da entidade de generalização em todas as relações de subclasse. A chave primária das relações de subclasse será a chave primária da entidade de generalização.

Para ilustrar essa regra, mapeamos a Figura 10.4 da seguinte forma:

+ TABELA\(id\_mobiliário, nº\_escritório, número\_funcionário, tipo\_mobiliário, tamanho\) 
+ MESA\(id\_mobiliário, nº\_escritório, número\_funcionário, tipo\_mobiliário, gavetas\) 
+ CADEIRA\(id\_mobiliário, nº\_escritório, número\_funcionário, tipo\_mobiliário, cor, tipo\_cadeira\)

Usando esta regra de mapeamento 16, criamos relações separadas para cada subclasse, mas não temos uma relação separada para a entidade da superclasse. Esta regra funciona melhor com o cenário de relacionamentos disjuntos, no qual o número de subclasses é muito pequeno e fixo. Se esta regra fosse usada no cenário de relacionamentos de sobreposição, criaria redundância no banco de dados, já que todos os atributos da entidade de generalização seriam regravados diversas vezes. Nas tabelas apresentadas, incluímos o atributo furniture\_type, que é redundante em relação ao nome da própria tabela. Isso foi feito para espelhar o diagrama e deve ser removido para produzir o seguinte:

+ TABELA\(id\_mobiliário, nº\_escritório, número\_funcionário, tamanho\) 
+ MESA\(id\_mobiliário, nº\_escritório, número\_funcionário, gavetas\) 
+ CADEIRA\(id\_mobiliário, nº\_escritório, número\_funcionário, cor, tipo\_cadeira\)

Além disso, esta é uma boa regra a ser usada se as subclasses tiverem muitos atributos.



### 10.6.3 Regra de mapeamento 17

Embora a regra de mapeamento 17 funcione tanto para participação total quanto parcial, ela funcionará apenas para relacionamentos disjuntos e,

1. Se as especializações não tiverem muitos atributos 
2. Se as especializações forem definidas por predicado

Usando essa regra de mapeamento, se as especializações tiverem muitos atributos, esse mapeamento criará muitos valores nulos. E, se a regra de mapeamento 17 fosse usada com relacionamentos sobrepostos, seria criada redundância no banco de dados.

+ Regra de Mapeamento 17 — Mapeando generalizações e especializações com relacionamentos disjuntos, restrições de participação total ou parcial e predicado definido com atributos de tipo único. Crie uma única relação para incluir os atributos da generalização \(superclasse\), bem como os atributos das especializações \(subclasses\) em uma única relação. A chave primária da relação será a chave primária da generalização \(superclasse\).

Na Figura 10.4, se assumirmos que furniture\_type é o predicado definidor, por exemplo, uma condição de pertencimento é especificada em furniture\_type da seguinte forma: furniture\_type = “Table”, então este é um predicado definidor desta especialização. No diagrama EER, a subclasse definida pelo predicado é mostrada escrevendo a condição do predicado ao lado do arco que conecta a subclasse ao círculo da restrição de relacionamento. Além disso, o nome do predicado definidor é colocado no arco da superclasse ao círculo da restrição de relacionamento. Portanto, mapeamos a Figura 10.4 de acordo com a regra de mapeamento 17 da seguinte forma:

+ MOBÍLIA\(id\_mobiliária, nº\_escritório, número\_funcionário, tipo\_mobiliária, tamanho, gavetas, cor, tipo\_cadeira\)

Esta regra de mapeamento gerará valores nulos para os atributos não participantes. Por exemplo, cadeiras não têm gavetas; portanto, se o tipo de mobília for "cadeira", haverá um valor nulo para o atributo gavetas. Valores nulos são geralmente indesejáveis. Há uma compensação aqui no banco de dados relacional, pois, por um lado, valores nulos podem ser tolerados para reduzir o número de tabelas, mas a abordagem purista determinaria que cada tipo de mobília tivesse sua própria tabela, de acordo com a regra de mapeamento 15 ou 16. Além disso, embora essa configuração de tabela pareça plausível, ela não está na terceira forma normal \(3FN\) e, portanto, representa outra compensação no banco de dados.



### 10.6.4 Regra de mapeamento 18

A regra de mapeamento 18 funcionará para relacionamentos sobrepostos, mas também pode ser usada para relacionamentos disjuntos. Esta regra de mapeamento novamente usa o predicado ou sinalizador para cada especialização e assume que tais predicados ou sinalizadores são exclusivos da especialização. Esta regra seria usada se houvesse inúmeras sobreposições dentro de cada generalização.

+ Regra de Mapeamento 18 — Mapeamento de relacionamentos sobrepostos e generalizações/especializações com mais de um sinalizador. Crie uma única relação para incluir os atributos da generalização \(superclasse\), os atributos das especializações \(subclasses\) e o sinalizador da subclasse. A chave primária da relação é a chave primária da superclasse.

Com relacionamentos disjuntos, a regra de mapeamento 18 criaria muitos valores nulos quando a entidade não fosse membro de uma especialização específica \(subclasse\). Portanto, essa regra funciona melhor se houver muitas sobreposições. Essa regra também não é recomendada se as subclasses tiverem muitos atributos, pois isso também resultaria em muitos valores nulos quando essas subclasses não fossem utilizadas.

Portanto, mapeando a Figura 10.3 conforme a regra de mapeamento 18 e usando predicados de sinalizadores, teríamos:

+ ATLETA\(ssno, peso, nome, gênero, altura, esporte, tflag, classificação\_estadual, gflag, handicap, fflag, posição\)

Novamente, o problema com esse arranjo é que a tabela resultante não está na 3FN. Há dependências funcionais claramente transitivas na tabela com tflag → state\_ranking e gflag → handicap e assim por diante. Uma normalização dessa tabela também geraria o resultado conforme a regra de mapeamento 15.

Ponto de verificação 10.2

1. Como as regras de mapeamento para generalizações/especializações são diferentes das regras de mapeamento para entidades fracas? 
2. Seria sensato mapear a Figura 10.3 usando a regra de mapeamento 17? Por quê? Ou por que não? 
3. Quais regras de mapeamento são boas para usar se houver muitos atributos nas subclasses? 
4. Qual regra ou regras de mapeamento não funcionarão bem para subclasses sobrepostas? 
5. Quando você criaria um relacionamento sobreposto? 
6. Quando você criaria um relacionamento disjunto? 
7. A regra de mapeamento 15 cria relações na 3FN? Discuta. 
8. A regra de mapeamento 16 cria relações na 3FN? Discuta.



## 10.7 SUBCLASSES DE SUBCLASSES

Até agora neste capítulo, apresentamos cenários de uma classe de generalização — apenas uma superclasse. Essa superclasse teve uma ou mais subclasses. As subclasses podem ter um ou mais atributos. É possível que subclasses tenham subclasses e que haja mais de um conjunto de subclasses. Aqui, damos exemplos de uma hierarquia de especialização, uma estrutura de especialização e pais de subclasses compartilhados.

Subclasses de subclasses são mostradas na Figura 10.5. Na Figura 10.5, as subclasses HOBBY e PROFESSIONAL são "parte de" ou "subclasses" de FOOTBALL. HOBBY e PROFESSIONAL herdariam atributos de FOOTBALL, que herdaria atributos de ATHLETE. \(Para simplificar o diagrama EER, os atributos das subclasses na árvore de futebol são omitidos.\) Assim, dos atletas, alguns atletas jogam futebol, e daqueles que jogam futebol, alguns jogam futebol como hobby, e alguns são profissionais. Cada instância de HOBBY herdará da subclasse FOOTBALL; da mesma forma, cada instância de PROFESSIONAL também herdará de FOOTBALL. Neste caso, cada subclasse está herdando de apenas uma outra subclasse. Quando uma subclasse herda de apenas uma subclasse, isto é, se uma subclasse tem apenas uma subclasse como pai, é chamada de hierarquia de especialização. A Figura 10.5 mostra uma hierarquia de especialização com FUTEBOL como exemplo.
FIGURA 10.5 Hierarquia de especialização. 
Outro diagrama EER possível poderia ter mais de um conjunto de especializações. Suponha que temos um atleta que pratica vários esportes, mas também é visto como tendo especializações profissionais ou amadoras. Suponha também que ambos os conjuntos de subclasses se sobreponham. Se uma subclasse tem mais de uma subclasse como sua matriz, ela é chamada de estrutura de especialização. A Figura 10.6 ilustra essa estrutura de especialização. Na Figura 10.6, temos a subclasse JOGADOR DE FUTEBOL PROFISSIONAL herdando informações tanto da subclasse FUTEBOL quanto da subclasse PROFISSIONAL.
FIGURA 10.6 Rede de especialização, subclasse compartilhada. 
Uma subclasse compartilhada é uma subclasse com mais de uma subclasse para seus pais. JOGADOR DE FUTEBOL PROFISSIONAL é uma subclasse de FUTEBOL e também de PROFISSIONAL e, portanto, herda de várias subclasses. Cada instância de uma subclasse compartilhada herda todos os atributos de todas as suas superclasses.



### 10.7.1 Regra de mapeamento 19

Apresentamos a regra de mapeamento 19 para mapear subclasses compartilhadas.

+ Regra de Mapeamento 19 — Mapeamento de subclasses compartilhadas. Em geral, os mesmos critérios usados para determinar qual regra seria melhor para mapear generalizações e especializações podem ser aplicados ao mapeamento de subclasses compartilhadas. No entanto, a regra que gera o melhor banco de dados geralmente é a regra de mapeamento 15.

Como exemplo de aplicação da regra de mapeamento 15, considere o mapeamento da Figura 10.6:

+ ATLETA\(ssno, peso, nome, gênero, altura, \{esporte\},\{prof/hobby flag\}\) 
+ TÊNIS\(ssno, classificação\_estadual\) 
+ GOLFE\(ssno, handicap\) 
+ FUTEBOL\(ssno, posição\) 
+ PROFISSIONAL\(ssno, agente, …\) 
+ HOBBY\(ssno, título, orçamento, …\) 
+ JOGADOR\_DE\_FUTEBOL\_PROFISSIONAL \(ssno, time, …\)

Aqui, usamos a regra de mapeamento 15 para mapear a Figura 10.6. Em outros casos, pode ser apropriado usar uma das outras regras de mapeamento, 16 a 18. Um ponto importante a ser observado é que, como uma subclasse compartilhada possui, em última análise, apenas uma superclasse, as subclasses mantêm o mesmo atributo-chave. Além disso, nesse mapeamento, há atributos multivalorados, o que requer normalização para um banco de dados relacional. Para normalizar essas tabelas, seriam necessárias mais duas tabelas para lidar com os predicados multivalorados:

+ ATLETA\(ssno, peso, nome, gênero, altura, \{esporte\},\{prof/hobby flag\}\)

Torna-se:

+ ATLETA1\(ssno, peso, nome, sexo, altura\) 
+ ESPORTE DE ATLETA \(ssno, esporte\) 
+ ATLETA PROAM \(ssno, bandeira prof/hobby\)



## 10.8 CATEGORIAS OU TIPOS DE SINDICATOS

Até agora neste capítulo, apresentamos exemplos com uma superclasse e várias subclasses. Suponha que o projeto do banco de dados resulte em várias superclasses e uma subclasse herde das superclasses. Cada superclasse é uma entidade em si mesma. Quando uma subclasse possui mais de uma superclasse da qual pode herdar, ela é chamada de categoria ou tipo união. Isso é diferente da seção anterior porque aqui estamos discutindo a herança de mais de uma superclasse, em oposição a mais de uma subclasse.

Enquanto uma subclasse compartilhada sempre possui apenas uma superclasse em sua hierarquia, uma categoria ou tipo de união pode ter mais de uma superclasse. Uma categoria ou tipo de união herdará informações de qualquer uma das superclasses; portanto, o termo união é usado para descrever a combinação de informações de quaisquer superclasses que sejam os pais. Simbolicamente, mostramos o tipo de união com um u no círculo que conecta as subclasses às suas superclasses, como mostrado na Figura 10.7A. Normalmente, as superclasses terão chaves diferentes, pois são entidades diferentes, mas também pode haver cenários para os quais uma categoria ou tipo de união possa herdar de duas superclasses com a mesma chave de tipo. Por exemplo, se tivermos uma superclasse chamada ALUNO, outra superclasse chamada FACULTY e uma subclasse \(categoria ou tipo de união\) PLAYER, como mostrado na Figura 10.7A, a categoria PLAYER pode ser um subconjunto da união das superclasses ALUNO e FACULTY, e herdar a mesma chave, ssn.
FIGURA 10.7A Uma categoria ou tipo de união com as mesmas chaves primárias \(participação parcial\) 
A Figura 10.7A diz:
> Um jogador pode ser um estudante ou membro do corpo docente. 
Um tipo de categoria ou união herda todos os atributos da classe ou classes às quais pertence. Portanto, se um jogador pertence à classe ALUNO \(superclasse\), ele herda todos os atributos do tipo entidade ALUNO. Se pertence à classe FACULTY \(superclasse\), ele herda todos os atributos do tipo entidade FACULTY.

Como outro exemplo de união em um diagrama ER, considere a Figura 10.8A. Aqui, temos um pagador de contas, mas este pode vir de várias superclasses. PAGADOR pode herdar dados de PACIENTE, SEGURO\_PRINCIPAL ou OUTRA\_PARTE\_RESPONSÁVEL.
FIGURA 10.8A Um tipo de categoria ou união com chaves primárias diferentes \(com participação parcial\).  


### 10.8.1 Taxas de participação em categorias ou tipos de sindicatos

Categorias ou tipos de união também podem ter restrições de participação. Reconsidere a Figura 10.7A. A categoria ou tipo de união PLAYER tem participação parcial \(linhas simples\) do círculo com o u até a subclasse PLAYER. Essa participação parcial implicaria que PLAYER pode ou não incluir alunos ou docentes. Haveria docentes e alunos que não são jogadores.

Se uma categoria como JOGADOR tiver participação total, como mostrado na Figura 10.7B, isso implicaria que a categoria \(ou tipo de união ou subclasse\) JOGADOR possui pelo menos uma entidade da união de suas superclasses DOCENTE e ALUNO. A Figura 10.7B implica que JOGADOR inclui pelo menos um DOCENTE ou ALUNO. Este diagrama representa uma escola específica. Além disso, este banco de dados provavelmente é usado para rastrear jogadores e não para rastrear todos na escola. O diagrama simplesmente diz que temos um banco de dados de jogadores, todos pertencentes à entidade DOCENTE ou ALUNO.
FIGURA 10.7B Uma categoria ou tipo de união com as mesmas chaves primárias \(participação total ou total\). 
Se houvesse linhas duplas indo do CORPO DOCENTE até o círculo contendo o u, como mostrado na Figura 10.7C, a entidade jogador incluiria todos os membros do corpo docente, mas não todos os alunos.
FIGURA 10.7C Participação total entre o corpo docente e o JOGADOR. 
Na Figura 10.8B, há participação total entre PAYOR e as superclasses PATIENT, PRIMARY\_INSURANCE e OTHER\_RESPONSIBLE\_PARTY. Todos os pagadores são identificados como pais de uma das superclasses. PAYOR conteria informações apropriadas em PATIENT, PRIMARY\_INSURANCE e OTHER\_RESPONSIBLE\_PARTY por herança.
FIGURA 10.8B Um tipo de categoria ou união com diferentes chaves primárias \(com participação total ou total\).   


### 10.8.2 Mapeando categorias ou tipos de união quando superclasses têm as mesmas chaves primárias

Quando subclasses herdam de superclasses com a mesma chave primária, como mostrado na Figura 10.7B, o mapeamento se torna simples, pois essa chave primária está incluída na relação de subclasse. Apresentamos a regra de mapeamento 20 para mapear categorias ou tipos de união quando superclasses têm a mesma chave primária.

+ Regra de Mapeamento 20 — Mapeando categorias ou tipos de união quando superclasses têm as mesmas chaves primárias. Crie uma nova relação para a subclasse \(ou tipo de união\) e inclua a chave primária da superclasse \(ou superclasses\) na subclasse \(ou tipo de união\) como chave primária. Inclua os outros atributos da subclasse nesta relação. Crie relações separadas para cada uma das outras superclasses e mapeie-as como faria com entidades comuns.

A Figura 10.7a seria mapeada para:

+ ALUNO\(ssn, nome, endereço\) 
+ FACULDADE\(ssn, nome, endereço, departamento\) 
+ JOGADOR\(ssn, nome, esporte\)



### 10.8.3 Mapeando categorias ou tipos de união quando superclasses têm chaves primárias diferentes

Como as superclasses geralmente são tipos de entidade diferentes, elas geralmente possuem chaves primárias diferentes. Por exemplo, veja as Figuras 10.8A e 10.8B. Se as superclasses tiverem chaves primárias diferentes, precisaríamos criar uma chave comum entre elas. Essa chave comum é chamada de chave substituta.

Apresentamos a regra de mapeamento 21 para mapear categorias ou tipos de união quando as superclasses têm chaves primárias diferentes.

+ Regra de Mapeamento 21 — Mapeando categorias ou tipos de união quando as superclasses têm chaves primárias diferentes. Crie uma nova relação para a subclasse \(ou tipo de união\) e crie uma chave substituta para essa relação. A chave substituta será a chave primária para essa relação. Inclua quaisquer outros atributos dessa subclasse nessa relação. Crie relações separadas para cada uma das superclasses e mapeie-as como faria com entidades comuns. Adicione a chave substituta às relações da superclasse como uma chave estrangeira.

A Figura 10.8A seria mapeada para

+ SEGURO PRINCIPAL\(piname, endereço, payor\_id\) 
+ PACIENTE\(CPF, nome, ID do pagador\) 
+ OUTRA\_PARTE\_RESPONSÁVEL\(nome\_rp, endereço, id\_pagador\) 
+ PAGADOR\(id\_pagador, valor\_pago, data\)

Neste mapeamento, payor\_id é a chave substituta.

Ponto de verificação 10.3

1. A Figura 10.7A diz: "Um jogador pode ser um aluno ou um docente". Mostramos isso como uma união. Poderíamos ter mostrado isso como uma relação disjunta? Discuta. 
2. Qual é a diferença entre um relacionamento disjunto e uma união? 
3. Como você mapearia uma categoria ou tipo de união com as mesmas chaves nas superclasses? 
4. Como você mapearia uma categoria ou tipo de união com chaves diferentes nas superclasses? 
5. Quando você criaria um relacionamento de generalização/especialização e quando criaria uma categoria ou tipo de união? Explique com exemplos. 
6. Uma subclasse compartilhada herda atributos de \_\_\_\_? 
7. Uma categoria ou tipo de união herda atributos de \_\_\_\_? 
8. Qual é a diferença entre uma subclasse compartilhada e uma categoria ou tipo de união?



## 10.9 METODOLOGIA DE PROJETO FINAL DE ER

Nossa metodologia final de design de ER finalmente evoluiu para a apresentação discutida a seguir.



### 10.9.1 Metodologia de Projeto ER

+  ** *Etapa 1. Selecione uma entidade primária na descrição dos requisitos do banco de dados e mostre os atributos a serem registrados para essa entidade. Identifique as chaves, se apropriado, e mostre alguns dados de exemplo.***  
+  ** *Etapa 2. Use inglês estruturado para entidades, atributos e chaves para descrever o banco de dados obtido.***  
+  ** *Etapa 3. Examine os atributos nas entidades existentes \(possivelmente com assistência do usuário\) para descobrir se as informações sobre uma das entidades devem ser registradas.***  

\(Mudamos de primário para existente porque refazemos a etapa 3 conforme adicionamos novas entidades.\)

+  ** *Etapa 3a. Se forem necessárias informações sobre um atributo, torne o atributo uma entidade e, em seguida,***  
+  ** *Etapa 3b. Defina o relacionamento de volta à entidade original.***  
+  ** *Passo 4. Se outra entidade for apropriada, desenhe a segunda entidade com seus atributos. Repita os passos 2 e 3 para ver se essa entidade deve ser dividida em mais entidades.***  
+  ** *Etapa 5. Conecte entidades com relacionamentos \(um ou mais\), se houver relacionamentos.***  
+  ** *Passo 6. Declare a natureza exata dos relacionamentos em inglês estruturado de todos os lados; por exemplo, se um relacionamento é A:B::1:M, então há um relacionamento de A\(1\) para B\(M\) e de B\(M\) de volta para A\(1\). Para relacionamentos ternários e de ordem superior \(n-ários\), declare o relacionamento em inglês estruturado, tendo o cuidado de mencionar todas as entidades para o relacionamento n-ário. Declare as restrições estruturais como elas existem. Para relacionamentos de especialização/generalização, declare o relacionamento em inglês estruturado, tendo o cuidado de mencionar todas as entidades \(subclasses ou especializações\). Declare as restrições estruturais como elas existem. Passo 6a. Examine a lista de atributos e determine se algum deles precisa ser identificado por duas \(ou mais\) entidades. Em caso afirmativo, coloque o atributo em um relacionamento apropriado que una as duas entidades. Passo 6b. Examine o diagrama em busca de laços que possam indicar relacionamentos redundantes. Se um relacionamento for realmente redundante, exclua o relacionamento redundante.***  
+  ** *Etapa 7. Mostre alguns dados de exemplo.***  
+   ** *Etapa 8. Apresente o banco de dados "como projetado" ao usuário, completo com os termos em inglês para entidades, atributos, chaves e relacionamentos. Refine o diagrama conforme necessário.***  





## 10.10 RESUMO DO CAPÍTULO

Neste capítulo, descrevemos os conceitos de generalizações e especializações, relacionamentos sobrepostos e disjuntos, subclasses e categorias compartilhadas ou tipos de união. Este capítulo abordou os diagramas EER discutidos por Elmasri e Navathe \(2016\) e Connolly, Begg e Strachan \(1998\). Alguns autores \(por exemplo, Sanders, 1995\) utilizam uma variação próxima deste modelo e chamam a relação especialização/generalização de relação "IsA".

Este capítulo também concluiu o desenvolvimento da metodologia de projeto do EER e o mapeamento dos diagramas do EER em um banco de dados relacional.





## CAPÍTULO 10 EXERCÍCIOS



### Exercício 10.1

Desenhe um diagrama ER para uma biblioteca, para uma entidade chamada acervo bibliotecário. Inclua como atributos o número de chamada, o nome do livro, o\(s\) autor\(es\) e a localização na biblioteca. Adicione um predicado definidor do tipo de acervo e desenhe as especializações disjuntas e parciais de periódicos e livros de referência, com periódicos tendo o atributo data de renovação e livros de referência, as restrições de retirada de dados. Mapeie isso para um banco de dados relacional e mostre alguns dados de exemplo.



### Exercício 10.2

Desenhe um diagrama ER para os computadores de uma escola. Cada computador é identificado por um número de identificação, marca, modelo, data de aquisição e local. Cada computador é categorizado como um computador de aluno ou de funcionário. Se for um computador de aluno, um atributo é o horário disponível. Se for um computador de funcionário, um atributo é a parte responsável \(proprietário, por assim dizer\). Mapeie isso para um banco de dados relacional e mostre alguns dados de exemplo.



### Exercício 10.3

Apresente um diagrama EER que tenha um tipo de união, um relacionamento disjunto e um relacionamento de sobreposição. Inclua também subclasses compartilhadas com chaves diferentes. Inclua chaves primárias e um conjunto mínimo de atributos e, por fim, mapeie tudo isso para um banco de dados relacional. Escreva o inglês estruturado para explicar seu diagrama.



## ESTUDO DE CASO



### West Florida Mall \(continuação\)

Até agora, em nosso estudo de caso, desenvolvemos as principais entidades e relacionamentos e os mapeamos para um banco de dados relacional \(com alguns dados de amostra\). Em seguida, revisamos a etapa 7, que diz:

+  ** *Etapa 7. Apresente o banco de dados "como projetado" ao usuário, completo com os termos em inglês para entidades, atributos, chaves e relacionamentos. Refine o diagrama conforme necessário.***  

Suponhamos que obtivemos alguma entrada adicional do usuário:

+ Uma PESSOA pode ser um proprietário, funcionário ou gerente. Para cada PESSOA, registraremos o nome, número do Seguro Social, endereço e número de telefone.

Ao revisar essas especificações adicionais, criamos uma nova entidade, PERSON.

Agora, repetindo o passo 2 para PESSOA, obtemos as informações conforme descrito a seguir.



### A Entidade

Este banco de dados registra dados sobre uma PESSOA.

+ Para cada PESSOA no banco de dados, registramos o nome da pessoa \(pname\), o número do Seguro Social da pessoa \(pssn\), o telefone da pessoa \(pphone\) e o endereço da pessoa \(padd\).



### Os atributos para PESSOA

+ Para cada PESSOA, haverá apenas um pname \(nome da pessoa\). O valor de pname não será subdividido. 
+ Para cada PESSOA, haverá apenas um PSSN \(número de Seguro Social\). O valor do PSSN não será subdividido. 
+ Para cada PESSOA, haverá apenas um pphone \(telefone da pessoa\). O valor de pphone não será subdividido. 
+ Para cada PESSOA, haverá apenas um padd \(endereço da pessoa\). O valor do padd não será subdividido.



### As Chaves

Para cada PESSOA, assumiremos que o pssn será único.

Essas entidades foram adicionadas ao diagrama na Figura 10.9.
FIGURA 10.9 Diagrama final do ER do West Florida Mall. 
Usando a etapa 6 para determinar as restrições estruturais dos relacionamentos, obtemos o seguinte:

+ Conforme mostrado na Figura 10.9, há um relacionamento disjunto entre PESSOA e GERENTE\_DA\_LOJA, PROPRIETÁRIO e FUNCIONÁRIO.

Isso significa que uma pessoa pode ser um proprietário, gerente de loja ou um funcionário \(um relacionamento de generalização/especialização disjunto\).

Para mapear essa relação, normalmente teríamos:
SHOPPING CENTER   * nome*   *endereço*     LOJA   *sloc*  *nome*  * snum*   *nome\_do\_shopping*  *então\_ssn*  *sm\_ssn*     PROPRIETÁRIO   * então\_ssn*   *então\_off\_phone*  *pssn*     DEPARTAMENTO   *nome do domínio*  * dnum*   ** *snum***      FUNCIONÁRIO   * essn*   *dnum*  *snum*  *dm\_ssn*  *pssn*     PESSOA   * pssn*   *pname*  *almofada*  *telefone*     GERENTE DE LOJA   * sm\_ssn*   *pssn* ...    
Como PERSON possui os campos número do Seguro Social \(pssn\), nome \(pname\), endereço \(padd\) e número de telefone \(pphone\) e pode ser um relacionamento de generalização/especialização de proprietário, gerente de loja ou funcionário \(um relacionamento disjunto\), removemos alguns atributos das entidades originais. Por exemplo, na entidade EMPLOYEE, não precisamos mais manter o campo ename, pois ele pode ser obtido de PERSON, desde que tenhamos o ssno do funcionário. Além disso, como pssn é, na verdade, o mesmo campo que essn em EMPLOYEE, so\_ssn em OWNER e sm\_ssn em STORE\_MANAGER, não precisamos incluir pssn em EMPLOYEE, OWNER ou STORE\_MANAGER novamente.

Então, em resumo, nosso banco de dados relacional finalmente se desenvolveria para \(sem os dados\):
SHOPPING CENTER   * nome*   *endereço*     LOJA   *sloc*  *nome*  * snum*   *nome\_do\_shopping*  *então\_ssn*  *sm\_ssn*     PROPRIETÁRIO   * então\_ssn*   *então\_off\_phone*     DEPARTAMENTO   *nome do domínio*  * dnum*   *snum*     FUNCIONÁRIO   * essn*   *dnum*  *snum*  *dm\_ssn*     PESSOA   * pssn*   *pname*  *almofada*  *telefone*     GERENTE DE LOJA   * sm\_ssn*  ...    
Aqui encerramos nosso estudo de caso.



## BIBLIOGRAFIA

+ Connolly, T., Begg, C. e Strachan, A. \(1998\). Sistemas de Banco de Dados: Uma Abordagem Prática para Design, Implementação e Gestão. Harlow, Reino Unido: Addison-Wesley. 
+ Elmasri, R., e Navathe, S.B. \(2016\). Fundamentos de Sistemas de Banco de Dados. Reading, MA: Addison-Wesley. 
+ Sanders, L. \(1995\). Modelagem de Dados. Danvers, MA: Boyd e Fraser. 
+ Teorey, T.J., Nadeau, T. e Lightstone, S.S. \(2005\). Modelagem e Design de Banco de Dados: Design Lógico. São Francisco, CA: Morgan Kaufman.





# 11 Mapeamento Relacional e Engenharia Reversa de Diagramas ER/EER



DOI: 10.1201/9781003314455-11



## 11.1 INTRODUÇÃO

Ao longo deste livro, desenvolvemos regras para mapear diagramas de entidade-relacionamento \(ER\) e de entidade-relacionamento aprimorada \(EER\) para um banco de dados relacional. Neste capítulo, apresentamos um resumo das regras de mapeamento e, em seguida, discutimos a engenharia reversa — começando com o banco de dados e retrocedendo para um diagrama ER/EER. Frequentemente, encontramos bancos de dados sem um diagrama ER/EER para acompanhá-los. O diagrama ER/EER é documentação — assim como programas de computador exigem documentação, o mesmo ocorre com bancos de dados. Portanto, incluímos um capítulo sobre engenharia reversa. Como fizemos anteriormente, para a engenharia reversa, apresentamos uma série de etapas para desenvolver um diagrama ER/EER a partir de tabelas e dados.



## 11.2 ETAPAS USADAS PARA MAPEAR DIAGRAMAS ER/EER PARA BANCOS DE DADOS RELACIONAIS

Nesta seção, apresentamos um resumo das etapas que desenvolvemos para mapear um diagrama ER/EER para um banco de dados relacional. Seguindo essas etapas, as tabelas relacionais resultantes devem estar próximas da terceira forma normal \(3NF\). Essas regras não impedem o exercício usual de verificar o banco de dados resultante para ter certeza absoluta de que ele está normalizado. Se os bancos de dados não estiverem normalizados, provavelmente haverá redundância. Na medida do possível, as etapas devem ser seguidas na ordem apresentada para promover o mapeamento correto e resultar em tabelas o mais próximas possível da 3NF. Aqui estão as etapas:
> Etapa 1: mapeie todas as entidades fortes no diagrama ER. 
Começamos com a regra de mapeamento 1 para mapear entidades fortes:

+ Regra de Mapeamento 1 — Mapeando entidades fortes. Desenvolva uma nova tabela \(relação\) para cada entidade forte e torne a chave indicada da entidade forte a chave primária da tabela. Se mais de uma chave candidata for indicada no diagrama ER, escolha uma para a chave primária.

Em seguida, precisamos verificar o mapeamento dos atributos na entidade forte. Como as regras de mapeamento são diferentes para atributos atômicos, compostos e multivalorados, apresentamos cada uma das regras de mapeamento separadamente. A primeira é a regra para mapeamento de atributos atômicos:

+ Regra de Mapeamento 2 — Mapeando atributos atômicos. Para entidades com atributos atômicos, mapeie as entidades para uma tabela e forme colunas para cada atributo atômico.

Em um banco de dados relacional, todas as colunas precisam ser atômicas. Se houver atributos não atômicos em nosso diagrama, precisamos torná-los atômicos para mapeamento com o banco de dados relacional.

Para atributos compostos, alcançamos a atomicidade registrando apenas as partes componentes do atributo. Nossa próxima regra de mapeamento diz respeito a atributos compostos.

+ Regra de Mapeamento 3 — Mapeando atributos compostos. Para entidades com atributos compostos, mapeie as entidades para uma tabela e forme colunas de cada parte elementar \(atômica\) do atributo composto.

A regra de mapeamento para atributos multivalorados é:

+ Regra de Mapeamento 4 — Mapeando atributos multivalorados. Crie uma tabela separada para o atributo multivalorado. Registre uma linha para cada valor do atributo multivalorado, juntamente com a chave da tabela original. A chave da nova tabela será a concatenação do atributo multivalorado mais a chave da entidade proprietária. Remova o atributo multivalorado da tabela original.

No final desta etapa, todas as entidades fortes devem ser mapeadas.

+  ** *Etapa 2. Mapeie todas as entidades fracas no diagrama ER.***  

Para entidades fracas, usamos a regra de mapeamento 11.

+  
Regra de Mapeamento 11 — Mapeando entidades fracas. Desenvolva uma nova tabela \(relação\) para cada entidade fraca. Como no caso da entidade forte, inclua quaisquer atributos atômicos da entidade fraca na tabela. Se houver um atributo composto, inclua apenas as partes atômicas do atributo composto e certifique-se de qualificar as partes atômicas para não perder informações. Para relacionar a entidade fraca ao seu proprietário, inclua a chave primária da entidade proprietária na tabela da entidade fraca. A chave primária da tabela da entidade fraca será a chave parcial da entidade fraca concatenada à chave primária da entidade proprietária.

Se a entidade fraca possuir outras entidades fracas, a entidade fraca conectada à entidade forte deverá ser mapeada primeiro. A chave da entidade proprietária fraca deverá ser definida antes que a entidade "mais fraca" \(a mais distante da entidade forte\) possa ser mapeada.


Depois que as entidades fortes forem mapeadas \(conforme etapa 1\), é importante que as entidades fracas sejam mapeadas em seguida, pois a chave da entidade fraca é a chave da entidade forte \(proprietária\) mais a chave parcial da entidade fraca.

Depois que todas as entidades fortes e fracas tiverem sido mapeadas, o próximo passo é mapear os relacionamentos.

+  ** *Etapa 3. Mapeie os relacionamentos.***  

Os relacionamentos podem ser mapeados em qualquer ordem. É mais conveniente começar mapeando relacionamentos binários M:N. Neste ponto, devemos ter tabelas para todas as entidades fortes e fracas. A próxima seção envolve adicionar atributos a essas tabelas ou criar novas tabelas para abrigar relacionamentos.

+ Regra de Mapeamento 5 — Mapeando relacionamentos M:N. Para cada relacionamento M:N, crie uma nova tabela \(relação\) com as chaves primárias de cada uma das duas entidades \(entidades proprietárias\) que estão sendo relacionadas no relacionamento M:N. A chave primária dessa nova tabela será a concatenação das chaves das entidades proprietárias. Inclua quaisquer atributos que o relacionamento M:N possa ter nessa nova tabela.

A seguir, mapearemos os relacionamentos binários 1:1. O mapeamento de relacionamentos 1:M ou 1:1 depende das restrições de participação. A maioria das regras a seguir envolve:

1. Adicionar um atributo \(uma chave estrangeira\) a uma tabela criada por uma regra de mapeamento anterior 
2. Adicionar uma nova tabela em um processo semelhante ao mapeamento de relacionamentos M:N

+ Regra de Mapeamento 6 — Mapeamento de relacionamentos binários 1:1 quando um lado do relacionamento tem participação total e o outro tem participação parcial. Quando um dos lados do relacionamento tem participação total e o outro tem participação parcial, armazene a chave primária do lado com a restrição de participação parcial no lado com a restrição de participação total; este atributo é uma chave estrangeira \(não está sublinhado\). Inclua quaisquer atributos do relacionamento na mesma tabela à qual a chave foi adicionada.
+  ** *Regra de mapeamento 7 — Mapeamento de relacionamentos binários 1:1 quando ambos os lados têm restrições de participação parcial.***  

Quando ambos os lados têm restrições de participação parcial em relacionamentos binários 1:1, os relacionamentos podem ser mapeados de duas maneiras:

+  **Opção 1:** 
+ Regra de mapeamento 7A. Selecione uma das tabelas para armazenar a chave da outra como uma chave estrangeira.

Essa escolha depende da semântica. Talvez uma opção mais segura para mapear esse tipo de relacionamento seja a regra 7B:

+  **Opção 2:** 
+ Regra de Mapeamento 7B. Dependendo da semântica, você pode criar uma nova tabela para abrigar o relacionamento que conteria a chave das duas entidades relacionadas. 
+ Regra de Mapeamento 8 — Mapeamento de relacionamentos binários 1:1 quando ambos os lados têm restrições de participação total. Use a semântica do relacionamento para selecionar qual das tabelas deve conter a chave da outra. Se essa escolha não estiver clara, use a regra de mapeamento 7B: crie uma tabela separada para abrigar o relacionamento.

Agora que os relacionamentos M:N e os relacionamentos binários 1:1 foram mapeados, o próximo passo será mapear os relacionamentos binários 1:N comuns.

+ Regra de Mapeamento 9 — Mapeamento de relacionamentos binários 1:N quando o lado N tem participação total. Inclua a chave da entidade no lado 1 do relacionamento como uma chave estrangeira no lado N. 
+ Regra de Mapeamento 10 — Mapeamento de relacionamentos binários 1:N quando o lado N tem participação parcial. Essa situação seria tratada como um relacionamento binário M:N, com uma tabela separada para o relacionamento. A chave da nova tabela consistiria em uma concatenação das chaves das entidades relacionadas. Inclua quaisquer atributos do relacionamento nesta nova tabela.

A participação parcial é um problema porque leva a valores nulos. Se colocarmos a chave do lado 1 na tabela do lado N e a participação for parcial \(nem todas as linhas do lado N têm um relacionamento com o lado 1\), haverá valores nulos no banco de dados quando ele for preenchido. Portanto, é melhor criar uma tabela separada para o relacionamento 1:N e evitar valores nulos.

Por fim, sobre o assunto de relacionamentos 1:N, devemos observar a Figura 8.2, onde um relacionamento M:N foi convertido em dois relacionamentos 1:N. O resultado da conversão do M:N em dois relacionamentos 1:N resultará no mesmo conjunto de tabelas de mapeamentos 1:N.

Nosso próximo passo seria mapear relacionamentos recursivos.

+ Regra de Mapeamento 12 — Mapeamento de relacionamentos recursivos 1:N. Reinclua a chave primária da tabela com o relacionamento recursivo na mesma tabela, atribuindo a ela um nome de função diferente. 
+ Regra de Mapeamento 13 — Mapeando relacionamentos recursivos M:N. Crie uma tabela separada para o relacionamento \(como na regra de mapeamento 5\).

Usaremos a regra de mapeamento 14 para mapear relacionamentos n-ários.

+ Regra de Mapeamento 14 — Mapeando relacionamentos n-ários. Para cada relacionamento n-ário, crie uma nova tabela. Na nova tabela, inclua as chaves das entidades conectadas e quaisquer atributos do relacionamento. Transforme as chaves das entidades conectadas na chave primária concatenada da nova tabela.

Em seguida, mapeamos o diagrama EER.

+  ** *Etapa 4. Mapeando generalizações/especializações.***  
+ Regra de Mapeamento 15 — Mapeamento de generalizações e especializações com subclasses disjuntas ou sobrepostas e com restrições de participação total ou parcial \(com poucos ou muitos atributos nas especializações\). Para cada situação de entidade de generalização/especialização, crie uma tabela para a entidade de generalização \(se ainda não o tiver feito conforme as etapas anteriores\) e crie uma tabela para cada especialização. Adicione os atributos de cada especialização às suas respectivas tabelas \(relações\). Inclua a chave primária da entidade de generalização nas tabelas de especialização. A chave primária das tabelas de especialização será a mesma chave primária da tabela de generalização. 
+ Regra de Mapeamento 16 — Mapeamento de generalizações e especializações com restrições de relacionamento disjunto e participação total entre generalizações e especializações. Crie uma tabela \(subclasse\) separada para cada entidade de especialização. Inclua os atributos de cada entidade de especialização em suas respectivas tabelas de subclasse. Inclua também a chave primária e outros atributos da entidade de generalização em todas as tabelas de subclasse. A chave primária das tabelas de subclasse será a chave primária da entidade de generalização. 
+ Regra de Mapeamento 17 — Mapeando generalizações e especializações com relacionamentos disjuntos, restrições de participação total ou parcial e predicado definido com atributos de tipo único. Crie uma única tabela que inclua os atributos da generalização \(superclasse\), bem como os atributos das especializações \(subclasses\). A chave primária da tabela será a chave primária da generalização \(superclasse\). 
+ Regra de Mapeamento 18 — Mapeando relacionamentos sobrepostos e generalizações/especializações com mais de um sinalizador. Crie uma única tabela que inclua os atributos da generalização \(superclasse\) e os atributos das especializações ou subclasses \(incluindo os sinalizadores de subclasse\). A chave primária da tabela é a chave primária da superclasse. 
+ Regra de Mapeamento 19 — Mapeamento de subclasses compartilhadas. Os mesmos critérios usados para determinar qual regra seria melhor para mapear generalizações e especializações podem ser aplicados ao mapeamento de subclasses compartilhadas. Ou seja, qualquer uma das regras de mapeamento 15 a 18 pode ser usada para mapear uma subclasse compartilhada. 
+ Regra de Mapeamento 20 — Mapeando categorias ou tipos de união quando superclasses têm as mesmas chaves primárias. Crie uma nova tabela para a subclasse \(ou tipo de união\) e inclua a chave primária da superclasse \(ou superclasses\) na subclasse \(ou tipo de união\) como chave primária. Inclua os outros atributos \(se houver\) da subclasse nesta tabela. Crie tabelas separadas para cada uma das outras superclasses e mapeie-as como faria com entidades comuns. 
+ Regra de Mapeamento 21 — Mapeando categorias ou tipos de união quando as superclasses têm chaves primárias diferentes. Crie uma nova tabela para a subclasse \(ou tipo de união\). Crie uma chave substituta para esta tabela. Esta será a chave primária desta tabela. Inclua quaisquer outros atributos \(se houver\) desta subclasse nesta tabela. Crie tabelas separadas para cada uma das superclasses e mapeie-as como mapearia entidades comuns. Inclua a chave substituta nas tabelas da superclasse como uma chave estrangeira.

Ponto de verificação 11.1

1. Qual é a primeira regra de mapeamento? 
2. Por que é bom mapear primeiro as entidades fortes e depois mapear as entidades fracas? 
3. O que você mapearia depois de mapear as entidades fracas? 
4. Como você mapearia entidades fracas de entidades fracas? 
5. Ao mapear um relacionamento binário 1:N quando o lado N tem participação total, por que incluímos a chave do lado 1 da tabela no lado N da tabela? O que estaria errado se incluíssemos a chave do lado N da tabela no lado 1 da tabela? 
6. Por que seria razoável mapear um relacionamento binário 1:N com participação parcial no lado N como um relacionamento M:N?

Se as regras forem seguidas, o banco de dados relacional resultante deverá estar na 3NF ou próximo a ela. A próxima fase do mapeamento é "verificar seu trabalho", revisando a tabela para garantir que você esteja pelo menos na 3NF \(consulte o Capítulo 3\). Em resumo, a verificação da 3NF consiste nas seguintes etapas:

1. 1NF — Verifique se não há atributos não atômicos em nenhuma tabela. Atributos não atômicos foram tratados na regra de mapeamento 3 para atributos compostos e na regra de mapeamento 4 para atributos multivalorados. 
2. 2NF — Verifique se todos os atributos em todas as tabelas dependem da chave primária completa. Pergunte a si mesmo: "Sempre obterei o mesmo valor para o atributo Y quando tiver o valor X e X for a chave primária?" X, neste caso, poderia ser uma chave concatenada, e você estaria procurando por dependências parciais. 
3. 3NF — Verifique situações em que um atributo está em uma tabela, mas esse atributo é melhor definido por algum atributo que não seja a chave primária. Lembre-se de que, se a chave primária em uma tabela for X e X → YZW, então se Z → W for mais claro que X → W, você provavelmente tem uma dependência transitiva e precisaria normalizar.



## 11.3 ENGENHARIA REVERSA

Tendo desenvolvido uma metodologia para desenvolver diagramas ER/EER e mapeá-los para um banco de dados relacional, voltamos agora nossa atenção para o problema da engenharia reversa — a questão de pegar um banco de dados relacional e criar um diagrama ER/EER. Muitas vezes, em situações reais, nos deparamos com um banco de dados e não temos um diagrama para mostrar como ele foi desenvolvido. Há vários motivos pelos quais um paradigma de diagrama de engenharia reversa \(RED\) é útil.

O diagrama de engenharia reversa nos fornece uma descrição gramatical e diagramática do banco de dados. Muitas vezes, as pessoas usam bancos de dados, mas não os entendem porque não há uma "visão geral". Ao fazer a engenharia reversa dos dados e tabelas para o diagrama, podemos expressar mais facilmente o significado do banco de dados em palavras. Ao ter o diagrama ER/EER do banco de dados relacional e a expressão gramatical do diagrama, podemos embelezar o banco de dados e manter o significado. O diagrama ER também pode auxiliar muito no desenvolvimento de consultas no banco de dados.

Embora a expressão "engenharia reversa" possa implicar a inversão das etapas para criar um diagrama, descobrimos que é mais fácil repetir as etapas de cima para baixo \(mais ou menos\) para descobrir qual diagrama poderia ter sido usado para criar o banco de dados relacional. O processo de engenharia reversa é mais facilmente abordado encontrando entidades fortes e, em seguida, preenchendo as outras partes do banco de dados. Há uma ressalva aqui: as etapas apresentadas pressupõem que o banco de dados esteja na 3FN. Se não estiver na 3FN, a engenharia reversa pode ajudar a descobrir por que existe redundância no banco de dados e, portanto, sugerir algumas alterações.

Com os diagramas ER e o processo de elucidação, propusemos desenhar o diagrama, adicionar descrições em inglês e apresentar o resultado ao usuário. Aqui, após a conclusão desse processo de engenharia reversa, espera-se que o diagrama resultante seja acompanhado por uma versão em inglês e também apresentado aos usuários. O sentido desse processo de engenharia reversa é muito semelhante ao da elucidação original, no sentido de que se procede e se verifica com os usuários para garantir que os analistas o tenham corretamente. As regras são fornecidas como um guia para passar da ausência de diagrama ER para um banco de dados mais completo e documentado. As regras a seguir não devem ser consideradas rígidas, mas sim um ponto de partida para a "negociação" de um banco de dados documentado. É provável que o diagrama ER evolua, o banco de dados possa mudar e os usuários controlem o produto final. Por exemplo, superclasses e subclasses podem ser mapeadas de diversas maneiras. Pode-se descobrir que outro mapeamento pode ter sido melhor do que o existente. Sem um diagrama ER original, muitos cenários são possíveis quando o panorama geral é apresentado.

Sugerimos as seguintes regras para afetar a engenharia reversa \(Figura 11.1\).
FIGURA 11.1 Engenharia reversa de entidades fortes.  


### 11.3.1 Regra 1 da Engenharia Reversa. Desenvolver Entidades Fortes

Para tabelas com uma chave de atributo único, desenhe uma entidade forte R para essa tabela e inclua todos os atributos dessa tabela na entidade R no diagrama ER.

Por exemplo, se você tiver uma tabela R\(a, b, c, d, e\), a é a chave. Crie uma entidade forte chamada R e mostre a, b, c, d e e como atributos, com a como chave.
R   um  *b*  *c*  *d*  *e*      


### 11.3.2 Regra 2 da Engenharia Reversa. Procure por relacionamentos 1:1 e 1:N \(1:x\)

À medida que a segunda, terceira e outras entidades fortes forem descobertas, procure chaves estrangeiras nas tabelas. Extraia as chaves estrangeiras do diagrama de entidades anterior e crie um relacionamento entre as entidades. Encontrar chaves estrangeiras em uma entidade forte provavelmente indica um relacionamento 1:x \(e x provavelmente é N\).

Por exemplo, suponha que você tenha duas tabelas que são entidades fortes. Suponha que você tenha R, como na seção anterior, e outra tabela, S, S\(d, f, g\). d é a chave de S. Agora, você observa que a chave de S, atributo d, também está na tabela R. d é uma chave estrangeira em R. Para criar um diagrama ER, remova d do diagrama de R e conecte R e S por uma relação 1:N ou 1:1. O lado com a chave estrangeira será o lado N de uma relação 1:N \(veja a Figura 11.2A\).
FIGURA 11.2A Engenharia Reversa de Relacionamentos 1:N. 
Aqui está outro exemplo desta situação:

+ Um banco de dados tem uma lista de itens pedidos por algum cliente: 
+ ITEM\(item\_nº, descrição, preço, pedido\_nº\). 
+ E você tem outra tabela para pedidos como esta: 
+ PEDIDO\(nº\_do\_pedido, data, nº\_do\_cliente\). 
+ O order\_no na tabela ITEM é uma chave estrangeira, pois é a chave da tabela ORDER. Neste exemplo, assumimos que item\_no é um identificador único para a tabela ITEM. O diagrama ER para este banco de dados é ilustrado na Figura 11.2B.FIGURA 11.2B Outro Exemplo de Engenharia Reversa de Relacionamentos 1:N.

Em todos os casos de relacionamentos, devemos determinar a cardinalidade e as restrições de participação a partir da semântica do banco de dados, bem como dos próprios dados. Às vezes, a forma como as tabelas são formadas dá uma pista. Por exemplo, revertendo para as tabelas R e S, se as tabelas R e S forem como o caso sugere, então é provável que o relacionamento seja N:1, com o lado N sendo R, já que R continha d, uma chave estrangeira. Os dados podem ser examinados para determinar o número de entradas filhas ocorrendo com entradas pai que indicariam participação parcial ou total. Procurar por nulos nos dados é outra pista para indicar as restrições de cardinalidade e participação. Devemos usar a palavra indicar porque somente a semântica verdadeira \(embora desconhecida\) e os próprios dados "provariam" a participação total/parcial.



### 11.3.3 Regra 2a da Engenharia Reversa. Verificação dos Atributos do Relacionamento 1:x

No diagrama ER, se uma chave estrangeira for removida de uma entidade R por ser a chave de S, você precisa verificar se algum dos atributos restantes em R deve permanecer com a entidade R. Ou eles devem ser colocados em um relacionamento RS ou com S? Como a etapa 2 é o mapeamento reverso de um relacionamento 1:x, pode ser que um atributo do próprio relacionamento 1:x tenha sido colocado com a chave estrangeira quando o diagrama ER original foi mapeado, ou que um atributo estivesse no próprio relacionamento.

Você precisa avaliar onde um atributo restante tem maior probabilidade de pertencer. Se for provável que o atributo tenha sido definido pela chave de uma entidade, coloque o atributo com a entidade que contém a chave. Se o atributo exigir ambas as chaves para sua identidade, o atributo deve ser colocado no relacionamento RS.

EXEMPLO 11.2

No caso discutido, removemos d de R no diagrama ER porque d era a chave de S. Suponha que, após criarmos S, determinamos que e só faz sentido se o definirmos em termos de a e d, as chaves de R e S. Isso implicaria que e era um atributo de interseção no relacionamento entre R e S e, portanto, seria representado como tal, conforme mostrado na Figura 11.3A.
FIGURA 11.3A Engenharia reversa de um atributo de relacionamento. 
Reconsidere o exemplo do banco de dados ORDER. Se, em nosso banco de dados ORDER, os itens\_ordenados fossem identificados exclusivamente por item\_no, mas a situação fosse de itens pedidos repetidamente, o atributo de data teria que ser identificado tanto por item\_no quanto por order\_no. Nesse caso, a Figura 11.2B se tornaria a Figura 11.3B.
FIGURA 11.3B Engenharia Reversa 1:N Relacionamentos com Atributos de Relacionamento.  
Isso conclui o mapeamento reverso de tabelas obviamente fortes. Agora, procuramos tabelas fracas e atributos multivalorados.



### 11.3.4 Regra 3 da Engenharia Reversa. Procure por Entidades Fracas e Atributos Multivalorados

Examine as tabelas em busca de chaves concatenadas para verificar se elas contêm alguma das chaves das entidades fortes. Se contiverem, isso pode indicar uma entidade fraca, um atributo multivalorado ou uma tabela resultante de um relacionamento M:N ou de ordem superior. A identificação de qual delas pode depender de atributos não-chave.



### 11.3.5 Regra 3a da Engenharia Reversa. Verificação de Entidades Fracas

Se houver uma tabela na qual haja atributos diferentes da chave concatenada \(que consiste em uma chave estrangeira de uma entidade forte e outro atributo — a chave parcial\), então você provavelmente tem uma entidade fraca.

Por exemplo, se você tiver uma tabela:

+ HABILIDADE\(nº\_funcionário, tipo\_habilidade, data\_certificação\)

A chave concatenada é emp\_no e skill\_type. Aqui, emp\_no é uma chave estrangeira, e skill\_type não é; portanto, skill\_type provavelmente seria uma chave parcial de uma entidade fraca. Por que uma entidade fraca? Isso ocorre porque há outro atributo, date\_certified, que significa que estamos armazenando informações sobre as habilidades daquele funcionário. Aqui, skill\_type não é um identificador exclusivo para as informações apresentadas.

Coloque a entidade fraca no diagrama ER juntamente com um relacionamento com sua entidade proprietária \(Figura 11.4\). O relacionamento provavelmente será 1:N::forte \(proprietário\):fraco\(dependente\)::parcial:completo. Examine os atributos na entidade fraca para determinar se eles teriam vindo da entidade fraca ou do relacionamento entre a entidade fraca e seu proprietário. Aqui, HABILIDADE é a entidade fraca, tipo\_habilidade é a chave parcial e data\_certificada é um atributo da entidade fraca HABILIDADE.
FIGURA 11.4 Engenharia reversa de entidades fracas.   


### 11.3.6 Regra 3b da Engenharia Reversa. Verificação de Atributos Multivalorados

Se

1. Não há outros atributos além de uma chave concatenada em uma tabela. 
2. Parte da chave é uma chave estrangeira de uma entidade forte. 
3. O outro atributo não é uma chave estrangeira.

então é provável que esta seja uma situação de atributo multivalorado. O atributo multivalorado teria sido conectado à entidade forte referenciada pela chave estrangeira. Coloque o atributo multivalorado na entidade à qual ele pertence como um atributo multivalorado \(Figura 11.5\).
FIGURA 11.5 Engenharia reversa de atributos multivalorados. 
Por exemplo, se tivermos a tabela:
> INSTRUTOR \(ssno, grau\) 
Aqui, temos uma chave concatenada e nenhum outro atributo. Como ssno é provavelmente a chave de outra entidade, \(digamos\) PERSON, e como degree não é uma chave provável, então degree deve ser um atributo multivalorado. Por que não uma entidade fraca? Se fosse uma entidade fraca, provavelmente haveria mais atributos — por exemplo, estaríamos registrando informações sobre os diplomas dessa pessoa, mas não estamos fazendo isso neste caso.



### 11.3.7 Regra 4 da Engenharia Reversa. Verifique os relacionamentos M:N e n-ário

Examine as tabelas do banco de dados com chaves concatenadas para múltiplas ocorrências de chaves primárias.



### 11.3.8 Regra 4a da Engenharia Reversa. Verifique o Caso Binário

Se houver duas chaves estrangeiras na chave concatenada de uma tabela, é provável que essa tabela tenha surgido devido a um relacionamento M:N. No caso do atributo multivalor apresentado, apenas um dos atributos da chave concatenada foi considerado uma chave estrangeira. Se as duas chaves estrangeiras ocorrerem junto com outros atributos em uma tabela, é ainda mais provável que exista um relacionamento M:N. Coloque um relacionamento M:N entre as duas entidades proprietárias com chaves estrangeiras e inclua outros atributos como atributos de relacionamento \(Figura 11.6\).
FIGURA 11.6 Relação M:N de engenharia reversa. 
Por exemplo, suponha que você descubra uma tabela chamada COMPRA que se parece com esta:
> COMPRA \(vendor\_no, part\_no, preço\) 
Suponha que vendor\_no seja a chave primária de uma entidade chamada VENDOR e part\_no seja a chave de uma entidade chamada PART. PARTS são compradas de VENDORS. Essas duas chaves estrangeiras \(chaves primárias de outras entidades\) são uma mensagem clara de que esta é uma tabela formada por um relacionamento M:N. É possível que a cardinalidade seja 1:x, mas o relacionamento M:N é mais provável; o relacionamento pode ser deduzido dos dados. Se, por exemplo, houver várias ocorrências de parts para vendors e vários vendors para parts, este é um relacionamento M:N. Se para cada part houver vários vendors, mas cada vendor fornecer apenas uma part, então isso seria VENDOR:PART∷N:1.



### 11.3.9 Regra 4b da Engenharia Reversa. Verifique o Caso n-ário

Se houver mais de duas chaves estrangeiras em uma tabela participando como chave primária concatenada da tabela, é provável que a tabela esteja sendo construída devido a um relacionamento n-ário. Pode haver outros atributos na tabela com três ou mais chaves estrangeiras. Coloque um relacionamento n-ário \(n = número de chaves estrangeiras\) entre as n entidades com chaves estrangeiras e inclua outros atributos como atributos de relacionamento.

Por exemplo, se você tiver a tabela:
> COMPRA \(número\_fornecedor, número\_peça, número\_cliente, preço\) 
As três chaves estrangeiras vendor\_no, part\_no e cust\_no implicam um relacionamento ternário. O atributo price é provavelmente um atributo de interseção no relacionamento. Nesse caso, diríamos que todas as três chaves seriam necessárias para identificar um preço, como mostrado na Figura 11.7.
FIGURA 11.7 Engenharia reversa do caso n-ário.   


### 11.3.10 Regra 5 da Engenharia Reversa. Verifique se há relações de generalização/especialização

Existem várias situações que indicam uma relação de generalização/especialização. Do Capítulo 10, lembramos que há diversas maneiras pelas quais um determinado diagrama EER com características de generalização/especialização pode ser mapeado para um banco de dados relacional.



### 11.3.11 Regra 5a da Engenharia Reversa. Verificar se há relacionamentos de generalização/especialização com relacionamentos disjuntos ou sobrepostos com restrições de participação total ou parcial.

Se a chave primária de uma tabela maior com uma chave primária de um atributo aparecer em outras tabelas \(provavelmente menores\) como uma chave primária de um atributo, provavelmente há um relacionamento de generalização/especialização. No entanto, isso também pode ser um relacionamento do tipo categoria ou união — consulte a regra 7 de engenharia reversa para fazer a engenharia reversa dos relacionamentos do tipo categoria ou união. A tabela maior provavelmente é uma superclasse, portanto, torne-a uma entidade/superclasse forte \(com a chave primária\). As tabelas menores são as subclasses. As entidades da subclasse não terão uma chave primária no diagrama EER, mas serão mostradas como subclasses sobrepostas ou disjuntas.

Por exemplo, se tivéssemos o seguinte conjunto de tabelas em um banco de dados:

+ M \(m, a, b, c, f\) 
+ N \(m, d, n\) 
+ O \(m, o\) 
+ P \(m, p, e\)

Podemos ver que m é a chave primária em todas as tabelas. Como M é a tabela maior, provavelmente é a superclasse e N, O e P são subclasses herdadas de M. Este conjunto de tabelas seria mapeado para a Figura 11.8.
FIGURA 11.8 Engenharia reversa de uma relação generalização/especialização. 
Em seguida, devemos tentar determinar se as subclasses são disjuntas ou sobrepostas. Fazemos isso observando os dados. Se a chave primária aparecer em uma tabela de subclasse por vez, ou seja, se um registro ou objeto parece estar em apenas uma tabela por vez, então provavelmente se trata de um relacionamento disjunto. Portanto, colocaríamos um d no círculo que une a entidade da superclasse às entidades da subclasse. Se a chave primária aparecer em mais de uma tabela de subclasse por vez; ou seja, se um registro ou objeto parece estar em mais de uma tabela de subclasse simultaneamente, então provavelmente se trata de uma situação de sobreposição de subclasse. Portanto, colocaríamos um o no círculo que une a entidade da superclasse às entidades da subclasse. Se as subclasses se sobrepuserem, um atributo multivalorado será necessário na entidade da superclasse.

Para tentar determinar se o relacionamento é total ou parcial, precisamos examinar alguns dados. Se cada chave primária \(ou objeto ou registro\) na tabela da superclasse aparecer em pelo menos uma das tabelas da subclasse, provavelmente se trata de um relacionamento de participação total entre subclasse e superclasse. Mas, se cada chave primária \(ou objeto ou registro\) na tabela da superclasse não aparecer em pelo menos uma das tabelas da subclasse, provavelmente se trata de um relacionamento de participação parcial.



### 11.3.12 Regra 5b da Engenharia Reversa. Verifique se há relacionamentos de generalização/especialização disjuntos com atributos definidos por um único predicado.

Se houver uma única tabela grande que pareça ter atributos e valores definidos por predicado ou nulos correspondentes aos atributos definidos por predicado, provavelmente se trata de um relacionamento de generalização/especialização disjunto com um atributo definido por predicado na superclasse. A entidade da superclasse terá a chave primária e os atributos não são definidos por predicado. As subclasses conterão os atributos correspondentes aos atributos definidos por predicado.



### 11.3.13 Regra 5c de Engenharia Reversa. Verifique se há sobreposição entre a relação de generalização/especialização e mais de um sinalizador.

No caso de um relacionamento de sobreposição de generalização/especialização com mais de um sinalizador, os sinalizadores são predicados definidores. Se houver uma única tabela grande que pareça ter mais de um sinalizador e vários valores correspondentes a eles, provavelmente se trata de um relacionamento de sobreposição de generalização/especialização. A entidade da superclasse será a tabela grande com a chave primária e os atributos não correspondem aos sinalizadores. As entidades da subclasse serão compostas pelos atributos correspondentes aos respectivos sinalizadores.



### 11.3.14 Regra 6 da Engenharia Reversa. Verificar Subclasses Compartilhadas

Para determinar se há entidades de subclasse compartilhadas, precisamos seguir as regras de engenharia reversa 5a-5c e precisamos de dados que nos ajudem a determinar se as subclasses são realmente compartilhadas. Se, a partir dos dados, observarmos que os atributos foram herdados de mais de uma subclasse, isso sugeriria que se trata de uma entidade de subclasse compartilhada. A entidade de subclasse compartilhada teria uma chave primária herdada de suas subclasses.



### 11.3.15 Regra 7 de Engenharia Reversa. Verifique se há categorias ou tipos de união

Se a chave primária de uma tabela aparecer em outras tabelas como chave primária, pode haver um relacionamento do tipo categoria ou união em que as entidades da superclasse têm a mesma chave primária \(mas isso também pode ser um relacionamento de generalização/especialização; consulte a regra 5a da engenharia reversa\). Nesse caso, pode ser difícil decifrar quais são as superclasses nos tipos categoria ou união. Podemos precisar dos dados para nos ajudar a ver quais tabelas estão herdando de quais tabelas; isso nos ajudará a determinar quais são as superclasses e quais são as subclasses.

Se a chave primária de uma tabela aparecer em outras tabelas como uma chave estrangeira, pode haver um relacionamento do tipo categoria ou união em que as superclasses têm chaves primárias diferentes; portanto, uma chave substituta foi criada, a qual foi incluída nas outras tabelas da superclasse como chave estrangeira. Nesse caso, as superclasses seriam as tabelas que contêm a chave substituta como chave estrangeira — essas superclasses teriam suas próprias chaves primárias. A tabela que contém a chave substituta como chave primária seria do tipo categoria ou união.

Ponto de verificação 11.2

1. Que dicas você procuraria para determinar se um relacionamento é ternário? 
2. Que dicas você procuraria ao tentar determinar se tabelas têm entidades fracas e atributos multivalorados incluídos nelas? 
3. Que dicas você procuraria para determinar se há uma relação de generalização/especialização? 
4. Que dicas ajudariam você a determinar se existe uma subclasse compartilhada? 
5. Que dicas ajudariam você a determinar se existe um tipo de relacionamento de categoria ou união? 
6. Por que a engenharia reversa é importante?





## 11.4 RESUMO DO CAPÍTULO

Neste capítulo, apresentamos um resumo das regras de mapeamento \(regras usadas para mapear diagramas ER e EER para bancos de dados relacionais\) que desenvolvemos ao longo do livro e, em seguida, discutimos e desenvolvemos um conjunto de regras para engenharia reversa para diagramas ER e EER de um banco de dados relacional.





## CAPÍTULO 11 EXERCÍCIOS



### Exercício 11.1

Crie um diagrama ER para o seguinte banco de dados relacional:

R \(a, b, c, d, w\)

S \(ré, mi, fá\)

T \(c, g, h\)

U \(c, d, j\)

V\(d, k\)

W \(a, m, o, p\)

X \(a, d, c, r\)

Y \(a, o, s, t\)



### Exercício 11.2

Crie um diagrama ER para o seguinte banco de dados relacional:

Um \(a, d\)

B \(si, mi, fá, sol\)

C \(c, i, j, a, b\)

CL \(c, l\)

AB \(a, b, h\)

M \(b, m, o, n\)

P \(b, m, p, r, q\)

ABC \(a, b, c, t\)



### Exercício 11.3

Crie um diagrama EER para o seguinte banco de dados relacional:

A \(a, b, o, s, t\)

C\(a, c\)

Pai\)

E \(a, e\)



### Exercício 11.4

Crie um diagrama EER para o seguinte banco de dados:

A \(a, ré, mi, f, n\)

B \(b, g, h, n\)

C \(c, i, j, n\)

D \(n\)



## BIBLIOGRAFIA

+ Elmasri, R., e Navathe, S.B. \(2016\). Fundamentos de Sistemas de Banco de Dados. Redwood City, CA: Benjamin Cummings.





# 12 Uma breve visão geral do modelo Barker/Oracle-Like



DOI: 10.1201/9781003314455-12



## 12.1 INTRODUÇÃO

Existem muitas variações de diagramas ER de entidade-relacionamento. Um desses modelos foi introduzido por Richard Barker \(1990\). O modelo Barker foi adotado e ligeiramente modificado pela Oracle Corporation. Neste capítulo, apresentamos as convenções utilizadas no modelo semelhante ao Barker/Oracle, conforme se aplicam à nossa Metodologia de Design ER. Descrevemos os principais conceitos dos diagramas ER de Barker e Oracle. Nosso modelo combinado semelhante ao Barker/Oracle não pretende ser uma introdução ao "modelo puro" de nenhuma das partes, mas a transição para o diagrama ER de Barker ou Oracle será mínima.

Ao ler este capítulo, entenda que nossa tentativa de discutir o modelo Barker, Oracle ou algum outro modelo não é defender o "modelo deles" em comparação com o apresentado neste livro. O objetivo de modelos como esses é identificar como os usuários visualizam seus dados e, em seguida, mapear qualquer modelo usado para um banco de dados relacional. Um analista pode querer apresentar vários modelos para deixar claro o que o usuário deseja e precisa. Portanto, este capítulo analisa o mesmo problema de uma perspectiva ligeiramente diferente para esclarecer o que é necessário.

Por que nos interessamos pelo modelo Barker/Oracle? E por que apresentá-lo aqui? O modelo Barker/Oracle é comum; é usado com frequência na literatura Oracle. O problema pedante com o modelo Barker/Oracle é que é preciso entender completamente a teoria de bancos de dados relacionais para entender por que o modelo Barker/Oracle é feito dessa maneira. Apresentamos o modelo Barker/Oracle aqui porque sua forma de desenvolvimento é um pouco diferente da do modelo Chen. O modelo Chen se concentra na modelagem de dados, enquanto o modelo Barker/Oracle adapta os dados ao banco de dados relacional simultaneamente ao projeto.

Portanto, a metodologia de projeto de ER para o modelo do tipo Barker/Oracle se desenvolverá de forma diferente do modelo do tipo Chen. Além disso, o modelo do tipo Barker/Oracle não terá algumas das convenções utilizadas no modelo do tipo Chen. Por exemplo, o modelo do tipo Barker/Oracle não utiliza diretamente o conceito de atributos compostos, atributos multivalorados ou entidades fracas, mas trata esses conceitos imediatamente à luz do modelo relacional. Como o modelo do tipo Barker/Oracle é tão próximo do modelo relacional no início, as regras de mapeamento são triviais — o mapeamento ocorre no próprio diagrama.



## 12.2 UM PRIMEIRO DIAGRAMA ER “SOMENTE ENTIDADE”: UMA ENTIDADE COM ATRIBUTOS

Começamos desenvolvendo um primeiro diagrama ER "somente entidade" no modelo do tipo Barker/Oracle. Para recapitular nosso exemplo usado anteriormente no livro, escolhemos uma entidade "primária" de um banco de dados de informações de alunos: ALUNO. Um aluno é algo sobre o qual queremos armazenar informações \(a definição de uma entidade\). Por enquanto, não nos preocupamos com nenhuma outra entidade.

Quais são alguns atributos iniciais que usamos na entidade ALUNO? Um aluno possui nome, endereço, instituição de ensino, número de telefone e curso. Selecionamos cinco atributos para a entidade ALUNO e escolhemos um rótulo genérico para cada um: nome, endereço, instituição de ensino, telefone e curso.
FIGURA 12.1A Notação do tipo Barker/Oracle do diagrama ER com uma entidade e cinco atributos. 
Começamos nossa aventura no modelo do tipo Barker/Oracle com a Figura 12.1A. Um modelo do tipo Barker/Oracle usa caixas de seleção para entidades \(com o nome da entidade em letras maiúsculas\) e há uma linha separando o nome da entidade dos atributos \(e os nomes dos atributos estão em letras minúsculas\). Um modelo do tipo Barker/Oracle não coloca os atributos em ovais \(como o modelo do tipo Chen\), mas lista os atributos abaixo do nome da entidade, como mostrado na Figura 12.1A.

A Figura 12.1B mostra um diagrama ER com uma entidade, ALUNO, e os atributos nome, endereço, escola, telefone e curso. Na versão Oracle do diagrama ER Barker/Oracle, o tipo de dado também é listado \(Figura 12.1B\).
FIGURA 12.1B Notação do tipo Barker/Oracle do diagrama ER com uma entidade e cinco atributos com tipos de dados adicionados.   


## 12.3 ATRIBUTOS NO MODELO BARKER/ORACLE-LIKE

Todos os atributos em um modelo do tipo Barker/Oracle são considerados simples ou atômicos, como em bancos de dados relacionais. O modelo do tipo Barker/Oracle não possui o conceito de atributos compostos. Portanto, nossa adaptação do tipo Barker/Oracle mostrará partes dos atributos compostos usando uma notação de ponto \(.\), como mostrado na Figura 12.2.
FIGURA 12.2 Notação semelhante a Barker/Oracle de um diagrama ER com um atributo composto: nome.  


### 12.3.1 Atributos opcionais versus obrigatórios

Ao projetar um banco de dados, é necessário saber se uma entidade pode conter um valor desconhecido para um atributo. Por exemplo, na entidade ALUNO \(mostrada na Figura 12.1\), suponha que o endereço fosse opcional. Em outras palavras, se os dados de um aluno fossem registrados em um formulário de entrada de dados em papel, poderíamos exigir que a pessoa preenchesse o nome e o número do aluno, mas permitir que ela deixasse o endereço em branco \(ou seja, desconhecido\). Diríamos que o nome e o número do aluno eram "obrigatórios" e o endereço era "opcional".

Um valor ausente é chamado de nulo. Portanto, o atributo obrigatório é considerado não nulo. Não nulo significa que, em nenhuma circunstância, haveria uma instância da entidade existente sem o conhecimento do valor desse atributo obrigatório. No modelo ER do tipo Barker/Oracle, mostraremos o atributo opcional sem a descrição não nulo e o atributo obrigatório adicionando a frase não nulo à descrição \(como mostrado na Figura 12.3\). Um atributo obrigatório pode ser uma chave, mas não é necessariamente uma chave. Atributos obrigatórios e opcionais geralmente não são indicados explicitamente no modelo do tipo Chen.
FIGURA 12.3 Notação semelhante a Barker/Oracle de um diagrama ER com um atributo de chave primária ou identificador exclusivo e atributos opcionais e obrigatórios. 
Em nosso modelo Barker, a chave primária tem um \# antes do nome do atributo \(como mostrado na Figura 12.3\). Uma chave primária precisa ser um atributo obrigatório em um banco de dados relacional, mas, novamente, todos os atributos obrigatórios aqui não são necessariamente identificadores únicos.

Ponto de verificação 12.1

1. O que os atributos obrigatórios \(no modelo do tipo Barker/Oracle\) representam no modelo do tipo Chen? Discuta com exemplos. 
2. O que os atributos opcionais \(no modelo do tipo Barker/Oracle\) representam no modelo do tipo Chen? Discuta com exemplos. 
3. Como as chaves primárias são mostradas diagramáticamente no modelo do tipo Barker/Oracle?



## 12.4 RELACIONAMENTOS NO MODELO BARKER/ORACLE-LIKE

No modelo do tipo Barker/Oracle, um relacionamento é representado por uma linha que une duas entidades. Neste modelo, não há um losango que denote o relacionamento, como vimos no modelo do tipo Chen. A frase de relacionamento para cada extremidade de um relacionamento é colocada próxima à extremidade da entidade apropriada em letras minúsculas, como mostrado na Figura 12.4. Neste modelo, da entidade ALUNO para a entidade ESCOLA, declararíamos informalmente o relacionamento como:

+ Os ALUNOS frequentam ESCOLAS.
FIGURA 12.4 Notação do tipo Barker/Oracle da entidade ALUNO com um relacionamento com a entidade ESCOLA. 
E, na outra direção, da entidade ESCOLA para a entidade ALUNO, diríamos:

+ ESCOLAS são frequentadas por ALUNOS.



## 12.5 RESTRIÇÕES ESTRUTURAIS NO MODELO BARKER/ORACLE-LIKE

Na notação semelhante à de Barker/Oracle, a cardinalidade de 1 é representada por uma única linha que leva à entidade. Na Figura 12.5, uma única linha une as duas entidades, portanto, trata-se de uma relação 1:1 entre o ALUNO e o AUTOMÓVEL. Isso significa que um aluno pode estar relacionado a um e apenas um automóvel, e um automóvel pode estar relacionado a um e apenas um aluno.
FIGURA 12.5 Uma relação 1:1 na notação do tipo Barker/Oracle. 
A linha tracejada que leva a uma entidade indica a participação opcional \(parcial\) de uma entidade em um relacionamento. Na Figura 12.5, a entidade ALUNO participa opcionalmente do relacionamento, mas a entidade AUTOMÓVEL não participa opcionalmente \(este último relacionamento é obrigatório\).

Uma gramática aprimorada da entidade ALUNO para a entidade AUTOMÓVEL seria:

+ Um ESTUDANTE pode dirigir apenas um AUTOMÓVEL.

E, da entidade AUTOMÓVEL para a entidade ESTUDANTE seria:

+ Um AUTOMÓVEL deve ser conduzido por um e somente um ALUNO.

Uma linha contínua \(sólida\) proveniente da entidade AUTOMÓVEL \(como mostrado na Figura 12.5\) indica a participação obrigatória \(total\) dessa entidade em um relacionamento. Uma linha tracejada proveniente da entidade ESTUDANTE \(como mostrado na Figura 12.5\) indica a participação opcional \(parcial\).

Como outro exemplo, consulte a Figura 12.6.
FIGURA 12.6 Uma relação 1:M na notação do tipo Barker/Oracle  
+ Os ALUNOS devem ocupar DORMITÓRIOS, mas um DORMITÓRIO pode ser ocupado por muitos ALUNOS.

Uma cardinalidade de M \(muitos\) é representada por uma estrutura em "pé de galinha" que leva à respectiva entidade. A Figura 12.6 é um exemplo de um relacionamento 1:M entre DORM e STUDENT. A gramática exata para a Figura 12.6 seria:

+ Um DORMITÓRIO pode ser ocupado por zero ou mais ALUNOS.

e

+ Um ESTUDANTE deve ocupar um e somente um DORMITÓRIO.



Ponto de verificação 12.2

1. Como o relacionamento opcional é mostrado diagramáticamente no modelo do tipo Barker/Oracle? 
2. Como o relacionamento de muitos é mostrado diagramáticamente no modelo do tipo Barker/Oracle? 
3. Mostre o seguinte usando a notação do tipo Barker/Oracle: Um cinema deve exibir muitos filmes, e os filmes devem ser exibidos em um cinema. Um cinema pode exibir muitos filmes, e os filmes podem ser exibidos em um cinema.



## 12.6 LIDANDO COM O CONCEITO DE ENTIDADE FRACA NO MODELO BARKER/ORACLE-LIKE

Os modelos Barker ou similares a Oracle não possuem o conceito de "entidade fraca", e a notação de entidade fraca também não é utilizada na literatura Oracle. Estendemos o conceito de identificador único em um relacionamento para incluir a entidade fraca. No modelo Barker/similar a Oracle, o identificador único em um relacionamento pode ser representado diagramáticamente por uma barra que atravessa o relacionamento contribuinte, conforme mostrado na Figura 12.7. Na Figura 12.7, para identificar exclusivamente um dependente, é necessário o número do Seguro Social do funcionário. Isso significa que a entidade DEPENDENTE não pode se sustentar independentemente e, portanto, é uma entidade fraca. No entanto, aqui, a entidade fraca seria mapeada de acordo com as regras de mapeamento discutidas no Capítulo 7.
FIGURA 12.7 Identificador Único \(para Incluir um Relacionamento de Entidade Fraco\) Mostrado Colocando uma Barra Cruzada na\(s\) Linha\(s\) de Relacionamento Contribuinte\(s\).   


## 12.7 LIDANDO COM O CONCEITO DE ATRIBUTOS MULTIVALUDOS NO MODELO BARKER/ORACLE-LIKE

Os modelos Barker ou Oracle não possuem o conceito de atributo "multivalorado". Atributos multivalorados podem ser mostrados como na Figura 12.8, que mostra que um aluno pode ter frequentado várias escolas.
FIGURA 12.8 O atributo multivalor e a chave estrangeira. 
No modelo do tipo Barker/Oracle, a chave estrangeira é mostrada na entidade apropriada, enquanto no modelo do tipo Chen, as chaves estrangeiras podem não ser "descobertas" até que o banco de dados seja mapeado e normalizado. Neste modelo, uma chave estrangeira é identificada com um asterisco \(\*\) antes do atributo \(veja a Figura 12.8\). Uma instância deste banco de dados mostrada na Figura 12.8 é apresentada nas Tabelas 12.1 e 12.2.
TABELA 12.1 Dados de amostra para ALUNO na Figura 12.8.   **nome**  **endereço**    
* * *
      `Sumona Gupta`  `111 Mirabelle Circle, Pensacola, FL`    `Tom Smith`  `198 Palace Drive, Mobile, AL`    `Tony Jones`  `329 Becker Place, Montgomery, AL`    `Sita Pal`  `987 Twin Lane, North Canton, OH`    `Neetu Singh`  `109 Bombay Blvd, Calicut, CA`      TABELA 12.2 Dados de amostra para ESCOLA na Figura 12.8.   **nome**  **escola**    
* * *
      `Sumona Gupta`  `Ferry Pass Elementary`    `Sumona Gupta`  `PCA`    `Sumona Gupta`  `Pensacola High`    `Tom Smith`  `Mobile Middle School`    `Tom Smith`  `St. Johns`    `Tony Jones`  `Montgomery Elementary`    `Tony Jones`  `Montgomery Middle`    `Tony Jones`  `Montgomery High`    `Sita Pal`  `Tagore Primary School`    `Sita Pal`  `Nehru Secondary School`      
Ponto de verificação 12.3

1. O modelo do tipo Barker ou o modelo do tipo Oracle possuem o conceito de entidade fraca? Discuta. 
2. Mostre o seguinte usando a notação do tipo Barker/Oracle: Para um aluno, estamos tentando armazenar o nome, endereço, telefone e livros do aluno \(ou seja, livros que o aluno pega emprestado na biblioteca\). Mapeie isso para um banco de dados relacional e mostre alguns dados de exemplo. 
3. A notação do tipo Barker/Oracle inclui o conceito de atributo multivalorado? Discuta.



### 12.8 TRATAMENTO DE CHAVES ESTRANGEIRAS

No modelo Barker original, as chaves estrangeiras não eram marcadas, mas agora um asterisco é usado para identificá-las. No modelo Oracle, as chaves estrangeiras são incluídas nas respectivas relações. Por exemplo, a Figura 12.9 diz:

+ Um ESTUDANTE pode dirigir apenas um AUTOMÓVEL.

E,

+ Um AUTOMÓVEL deve ser conduzido por um e somente um ALUNO.
FIGURA 12.9 Notação tipo Barker/Oracle mostrando chave estrangeira. 
A chave primária da relação ALUNO \(lado 1\), número do aluno, está incluída na relação AUTOMÓVEL \(lado N\). Em nosso modelo do tipo Barker/Oracle, colocamos um asterisco antes da chave estrangeira \(como mostrado na Figura 12.9\).



## 12.9 RELACIONAMENTOS RECURSIVOS NO MODELO BARKER/ORACLE-LIKE

Relacionamentos recursivos no modelo do tipo Barker/Oracle são desenhados como mostrado na Figura 12.10. Novamente, a linha pontilhada no relacionamento mostra um relacionamento opcional; a linha contínua mostra um relacionamento obrigatório; um "pé de galinha" mostra um relacionamento de muitos. Os relacionamentos são nomeados como mostrado.
FIGURA 12.10 Notação tipo Barker/Oracle - Relação recursiva. 
A Figura 12.10 mostra que um FUNCIONÁRIO pode supervisionar outros FUNCIONÁRIOS, e um FUNCIONÁRIO pode ser supervisionado por um e apenas um FUNCIONÁRIO supervisor. Observe a chave estrangeira super\_ssn na relação FUNCIONÁRIO.



## 12.10 MAPEANDO RELACIONAMENTOS M:N

Por fim, discutimos um aspecto importante tratado de forma diferente no modelo do tipo Barker/Oracle: o relacionamento M:N. No modelo do tipo Barker/Oracle, todos os relacionamentos M:N são resolvidos em dois relacionamentos 1:M com uma entidade de interseção no meio. No modelo do tipo Chen, o M:N pode ser apresentado como dois relacionamentos 1:M.

A Figura 12.11 é um exemplo de um relacionamento M:N no formato Chen-like. No modelo Barker/Oracle, isso seria mostrado como na Figura 12.12.
FIGURA 12.11 Um diagrama ER de um relacionamento M:N no modelo do tipo Chen.   FIGURA 12.12 Notação do tipo Barker/Oracle de um relacionamento M:N dividido em dois relacionamentos 1:M. 


Ponto de verificação 12.4

1. Como os relacionamentos recursivos são mostrados no modelo do tipo Barker/Oracle? 
2. Por que é difícil mostrar relacionamentos M:N no modelo do tipo Barker/Oracle? 
3. Como as chaves estrangeiras são tratadas no modelo do tipo Barker/Oracle?





## RESUMO DO CAPÍTULO 12.11

Este capítulo discutiu brevemente algumas das principais características do modelo Barker/Oracle-like. O diagrama de uma entidade com atributos foi apresentado. A ideia de atributos opcionais versus obrigatórios foi discutida. Relacionamentos e restrições estruturais foram brevemente discutidos no contexto do modelo Barker/Oracle-like. Embora a notação Barker/Oracle-like não utilize o conceito de entidade fraca e atributos multivalorados, mostramos como esses conceitos podem ser representados diagramaticamente na notação Barker/Oracle-like. Um exemplo da representação do relacionamento recursivo no modelo Barker/Oracle-like é ilustrado. Por fim, o capítulo mostrou como mapear um relacionamento M:N em dois relacionamentos 1:M. Regras de mapeamento também foram discutidas no contexto da notação Barker/Oracle-like.





## CAPÍTULO 12 EXERCÍCIOS



### Exercício 12.1

Redesenhe a Figura 8.17a usando a notação Barker/Oracle. Mapeie-a para um banco de dados relacional e mostre alguns dados de exemplo.



### Exercício 12.1

Redesenhe a Figura 8.7 usando a notação Barker/Oracle. Mapeie-a para um banco de dados relacional e mostre alguns dados de exemplo.



## BIBLIOGRAFIA

+ Barker, R. \(1990\). Método de Caso, Modelagem Entidade-Relacionamento. Reading, MA: Addison Wesley. 
+ Hay, D.C. \(1996\). Padrões de Modelos de Dados. Nova Iorque: Dorset House. 
+ Rodgers, Ulka. \(1991\). ORACLE: Um Guia para Desenvolvedores de Banco de Dados. Englewood Cliffs, NJ: Prentice-Hall. 
+ Siau, K. \(2004\). Tópicos Avançados em Pesquisa em Banco de Dados. Hershey, PA: Idea Group.





# Glossário




**Atributo:** Dados referentes a uma entidade. Por exemplo, se uma entidade for FUNCIONÁRIO, os atributos da entidade podem ser nome, endereço e telefone.   **Relação binária:** Um relacionamento entre duas entidades.   **Chave do candidato:** Um atributo ou conjunto de atributos que identifica exclusivamente ocorrências individuais de um tipo de entidade \(identifica exclusivamente uma linha em uma tabela relacional\).   **Razão de cardinalidade:** Descreve o número de uma entidade que está relacionada a outra. Exemplo: Um dormitório pode ter muitos ocupantes; a cardinalidade de DORMITÓRIO para OCUPANTE é de um para muitos \(1:M\).   **Categoria:** Uma subclasse de uma superclasse da qual a subclasse pode herdar atributos da superclasse; também chamada de tipo de união de superclasse para subclasse.   **Atributo composto:** Um atributo composto por múltiplos componentes, cada um com existência independente. Exemplo: o nome do atributo composto geralmente é armazenado como nome.primeiro, nome.sobrenome, nome.MI. O nome. é chamado de "qualificador".   **Banco de dados:** Uma coleção compartilhada de dados logicamente associados ou relacionados.   **Grau de relacionamento:** O número de entidades participantes em um relacionamento.   **Atributo derivado:** Um atributo em que um valor é calculado ou derivado de outros dados. Exemplo: a idade é derivada do aniversário.   **Entidade:** "Algo" no mundo real que é importante para um usuário e que precisa ser representado em um banco de dados para que as informações sobre a entidade possam ser registradas. Uma entidade pode ter existência física \(como um aluno ou um prédio\) ou conceitual \(como um curso\).   **Conjunto de entidades:** Uma coleção de todas as entidades de um tipo específico de entidade.   **Tipo de entidade:** Um conjunto de entidades do mesmo tipo.   **Primeira forma normal \(1NF\):** Um arranjo de tabela em que o domínio de todos os atributos na tabela deve incluir apenas valores atômicos \(simples, indivisíveis\).   **Chave estrangeira:** Um atributo que se refere a uma chave primária de outra tabela. Uma chave estrangeira é como os relacionamentos são implementados em bancos de dados relacionais.   **Participação plena:** Todas as entidades de um conjunto participam de um relacionamento.   **Dependência funcional:** Um relacionamento entre dois atributos em uma relação. O atributo Y é funcionalmente dependente do atributo X se o atributo X identifica o atributo Y. Para cada valor único de X, o mesmo valor de Y sempre será encontrado.   **Generalização:** O processo de minimizar as diferenças entre entidades identificando suas características comuns e removendo as características comuns em uma entidade de superclasse.   **Modelo hierárquico:** Todos os dados são organizados de cima para baixo. Todos os relacionamentos têm cardinalidade de um para muitos \(1:M\).   **Identificação do proprietário:** A entidade forte \(o proprietário\) da qual uma entidade fraca depende.   **Identificando o relacionamento:** Um relacionamento de uma entidade forte/fraca onde a entidade fraca é identificada pela entidade proprietária.   **Chave:** Um atributo que identifica exclusivamente uma linha de uma tabela.   **Relação obrigatória:** Todas as entidades de um conjunto devem participar de um relacionamento. Também conhecido como participação total.   **Muitos para muitos:** Muitas linhas em uma tabela estão relacionadas a muitas linhas em outra tabela. Exemplo: Muitos CLIENTES compram muitos PRODUTOS. Esse relacionamento geralmente tem dados de intersecção, como preço ou data de venda.   **Muitos para um:** Muitas linhas de uma tabela podem estar relacionadas a apenas uma linha de outra tabela. Exemplo: Muitos PACIENTES são examinados por um MÉDICO ou muitos ALUNOS frequentam uma ESCOLA.   **Mapeamento:** O processo de pegar um modelo conceitual acordado \(o diagrama ER\) e criar tabelas em um banco de dados com base no diagrama ER.   **Atributo multivalorado:** Um atributo que pode ter vários valores para uma única entidade.   **Um para muitos:** Um relacionamento em que uma linha de uma tabela pode estar relacionada a mais de uma linha em outra tabela. Exemplo: um FUNCIONÁRIO pode ter muitos DEPENDENTES.   **Um para um:** Um relacionamento em que uma linha de uma tabela pode estar relacionada a apenas uma linha de outra tabela. Exemplo: Um FUNCIONÁRIO possui um CARTÃO\_DE\_ID.   **Participação opcional:** Pode existir uma restrição estrutural de relacionamento que especifique uma relação. Exemplo: UMA PESSOA pode ser fã de um TIME de beisebol.   **Restrição de participação \(também conhecida como opcionalidade\):** Determina se toda ou parte da ocorrência de uma entidade está relacionada a outra entidade. Exemplo: um CLIENTE em um restaurante pode comprar VINHO.   **Chave primária:** Um identificador exclusivo para uma linha em uma tabela em um banco de dados relacional; uma chave candidata selecionada de uma entidade.   **Relação recursiva:** Um relacionamento entre entidades da mesma classe. Exemplo: Um FUNCIONÁRIO é supervisionado por outro FUNCIONÁRIO.   **Relação:** Uma tabela preenchida contendo entradas de valor único e sem linhas duplicadas. O significado das colunas é o mesmo em todas as linhas, e a ordem das linhas e colunas é irrelevante, mas, uma vez corrigida, nunca muda.   **Relação:** Uma associação entre entidades.   **Engenharia reversa:** O processo de transição de tabelas relacionais para um modelo lógico \(ou diagrama ER\). Um processo de mapeamento reverso usado para documentar um banco de dados existente.   **Segunda forma normal:** Uma relação que está na primeira forma normal e na qual cada atributo não-chave é totalmente dependente funcionalmente da chave primária.   **Subclasse compartilhada:** Uma subclasse de uma superclasse onde todas as subclasses compartilhadas herdam os mesmos atributos da superclasse e os atributos definidos localmente também são compartilhados.   **Atributo simples:** Atributo que sempre será composto por um único valor.   **Especialização:** O processo de maximizar as diferenças entre membros de uma entidade superclasse identificando suas características distintivas.   **Hierarquia de especialização:** Uma subclasse que herda apenas de uma superclasse.   **Rede de especialização:** Uma subclasse que tem mais de uma subclasse como sua mãe.   **Entidade forte:** Uma entidade que não depende de outra entidade para sua existência.   **Restrições estruturais:** As restrições indicam quantas entidades de uma entidade estão relacionadas a outra \(como uma ou mais\) e se as entidades podem ou devem ter um relacionamento. A proporção de cardinalidade e as restrições de participação, consideradas em conjunto, são chamadas de "restrições estruturais".   **Subclasse:** Um tipo de entidade que tem uma função distinta e também é membro de uma superclasse.   **Superclasse:** Um tipo de entidade que inclui subclasses distintas que devem ser representadas em um modelo de dados.   **Mesa:** O mesmo que “relação”, exceto que uma relação é uma tabela preenchida; uma tabela é uma exibição tabular de dados que pode ser usada para conter uma ou mais colunas de dados; uma implementação de uma entidade.   **Terceira forma normal:** Uma relação que está na segunda forma normal e na qual nenhum atributo não-chave é funcionalmente dependente de outro atributo não-chave \(ou seja, não há dependências transitivas na relação\).   **Tipo de união:** Uma subclasse que tem mais de uma superclasse da qual pode herdar; também chamada de categoria.   **Identificador único:** Qualquer combinação de atributos ou relacionamentos que serve para identificar exclusivamente uma ocorrência de uma entidade \(uma linha em uma tabela\).   **Modelo em cascata:** Uma série de etapas no desenvolvimento de software em que cada etapa do processo não é repetida uma vez acordada. O processo flui em uma direção.   **Entidade fraca:** Uma entidade que depende de alguma outra entidade para sua existência.  




# Índice




**
+  UM** 
+  abstração, descrevendo bancos de dados,72 
+  atributo de endereço,81 
+  agregar,81 
+  analista,4 
+ anomalias, na manutenção da mesa, 48–49, 55 
+ atributos atômicos \(simples\) sobre, 79–80, 87 em modelo tipo Barker/Oracle, 327 em classes, 267 definido, 34 mapeamento em banco de dados relacional, 94–97, 300 
+ atributosendereço, 81atômico, veja atributos atômicos \(simples\)no modelo tipo Barker/Oracle, 326–328data de nascimento, 80mudando para ser uma entidade, 108colunas como, 35, 94composto, veja atributo compostochave concatenada, 41, 49, 67definido, 73, 74, 75derivado, 82, 88elementar, 81grupo \(composto\), 80herança de, 265–266, 270, 286–288interseção, 202, 226, 240, 242junção, 280obrigatório e opcional, no modelo tipo Barker/Oracle, 327–328multivalorado, veja atributo multivaloradonão atômico, 34, 96, 306chave primária, veja chave primáriapropriedades de, 79na teoria de banco de dados relacional, 35de relacionamentos, 201–204, 213conjuntos, 60simples \(atômico\), veja atributos atômicos \(simples\)atributos específicos, 271que evoluem para entidades, 209–213, 214–216como identificador único, 79 
+ regra de aumento, 60, 64
**
+  B** 
+  Barker, Ricardo,325 
+  Modelo tipo Barker/Oracle,325–341
	+  atributos,326–328
	+  cardinalidade em,329–331
	+  exercícios,340
	+  primeiro diagrama ER “somente entidade”,326–327
	+  chaves estrangeiras,336
	+  mapeando relacionamentos M:N,336–340
	+  atributos multivalorados, conceito de,333–335
	+  nulo e não nulo,327–328
	+  atributos opcionais vs. obrigatórios,327–328
	+  participação, obrigatória e opcional,329–331
	+  relacionamentos recursivos,336
	+  relacionamentos,329
	+  restrições estruturais,329–332
	+  resumo,340
	+  entidade fraca, conceito de,332–333

+  BCNF \(forma normal de Boyce–Codd\),65–67 
+ mapeamento de relacionamentos binários para banco de dados relacional, 159–168, 302–303, veja também mapeamento de relacionamentos binários para banco de dados relacional nova entidade, 109 padrões de, veja padrões de relacionamentos binários em engenharia reversa, 308–311, 316 segunda entidade, 114 restrições estruturais, 172 e relacionamentos ternários, 240, 246–247, 254–258
+  atributo de data de nascimento,80 
+  abordagem de design de baixo para cima,269 
+  Forma normal de Boyce–Codd \(BCNF\),65–67 
**
+  C** 
+ chave candidata, como identificador único, 84, 98 
+ cardinalidade no modelo Barker/Oracle, 329, 331 máximo, 228 relacionamento um-para-muitos, 26–27 proporção de relacionamento, 129–134 em engenharia reversa, 308 restrições estruturais, 26–27 em entidades fracas e fortes, 184
+  razão de cardinalidade,129–134 
+ estudo de caso extensões de design para diagramas ER com relacionamentos binários, 235–237 design de diagrama ER, 100–104 design de diagrama ER, além da primeira entidade, 120–128 modelo de relacionamento de entidade aprimorado \(EER\), 295–298 relacionamentos/restrições estruturais, 172–178 entidades fracas, 194–199
+  categorias ou tipos de união,286–292
	+  definido,286–287
	+  herança de atributos,286–288
	+ mapeamento quando as superclasses têm chaves primárias diferentes, 291–292, 305
	+ mapeamento quando as superclasses têm as mesmas chaves primárias, 291, 305
	+  taxas de participação,288–290
	+  na engenharia reversa,321–322

+ Chen, P. P., 73, 76 
+ Modelo semelhante a Chen, cardinalidade do relacionamento, 133, 135, 137, comparado com o modelo semelhante a Barker/Oracle, 325–326, diagrama ER, 76–79, 84, veja também diagramas ER, atributo multivalorado, 84, relacionamento para nova entidade, 109, 114, relacionamentos de relacionamentos, 252, identificadores exclusivos, 84, entidades fracas, 182 
+ classe infantil, em relação hierárquica pai-filho, 20–25, 268–269
+  hierarquias de classes,265–267 
+  COBOL,16–17 
+ colunas, 35, 94
+  atributos compostos,80–81
	+  no modelo do tipo Barker/Oracle,327
	+  no modelo do tipo Chen,84
	+  definição de,80–81
	+  gramática para,88
	+ mapeamento para banco de dados relacional, 96, 300

+ chave concatenada, 41, 49, 67 
+ concatenação, 41, 206
+  modelo conceitual,72 
+  anéis de coral,26 
**
+  D** 
+ definido por dados, 1inconsistente, 34relacionado, 7armazenamento e recuperação, 11–12
+  dados e modelos de dados,11–32
	+  arquivo do cliente,12
	+  registros de clientes,12–13
	+ modelos de banco de dados, 19–28, veja também modelos de banco de dados
	+  sistemas de banco de dados,17–18
	+  campos de dados,12–13
	+  design de arquivo,12–13
	+  arquivos, registros e itens de dados,11–14
	+  chave estrangeira,21
	+  história, passando de cartões 3 × 5 para computadores,14–19
	+  chave,13
	+ modelo de rede, 18, 28–30
	+  modelo relacional,31
	+  arquivos sequenciais,16–17
	+  pacotes de software,16
	+  resumo,32

+ banco de dados definido, 1definições, 73–75
+  banco de dados, construção de, com processo de engenharia de software,1–10
	+  analista,4
	+  construindo um banco de dados,2
	+ descrição do processo de engenharia de software, 3–7, veja também processo de engenharia de software
	+ design de banco de dados, 5, 9
	+ elucidação, 4, 5
	+  diagramas de relacionamento de entidades e ciclo de vida de engenharia de software,7–9
	+  exercícios,10
	+ requisitos para banco de dados, 5, 8, 75
	+ especificação do banco de dados, 5, 8–9
	+  resumo,9
	+  sistemas,17–18
	+ usuário, 4, 7–8, 74
	+  modelo em cascata,3–4

+ modelos de banco de dados, 19–28, veja também modeloscardinalidade, 26–27modelo hierárquico, 18, 20–28, veja também modelos hierárquicosmodelos lógicos, 18, 31modelo de rede, 18, 28–30modelo relacional, 31, veja também bancos de dados relacionaisterminologia de relacionamento, 26–27
+  sistemas de banco de dados,17–18 
+  esquema de modelagem de dados,71–72 
+ decomposição, 40, 50, 65, 254–258
+  regra de decomposição,60–61 
+ predicado definidor, 272–274, 320–321
+  grau de relacionamento,111 
+  apagar anomalia,49 
+ atributo derivado, 82, 88
+  relação derivada,224–228 
+  abordagens de design, de cima para baixo e de baixo para cima,269 
+ etapas da metodologia de projeto; modelo EER, 274–275, 292–294; diagrama ER, 75, 88, 92–94; diagrama ER, além da primeira entidade, 111, 118–119; diagrama ER com relacionamentos binários, extensões no projeto, 202, 207, 223, 226, 230–232, 235; relacionamentos/restrições estruturais, extensão, 146–147, 154–158, 172, 176; diagramas ER ternários e de ordem superior, 248, 260–261; entidades fracas, 189–190, 195
+  restrição disjunta,272–274
	+ no mapeamento de generalizações ou especializações, 277, 280–282, 304
	+  na engenharia reversa,319–321

+  regra de aumento duplo,64 
**
+  E** 
+  Modelo EER, *ver*modelo de relacionamento de entidade aprimorado \(EER\) 
+  atributo elementar,81 
+ elucidação, 4, 5
+  descrições em inglês, *ver*descrições gramaticais 
+  modelo aprimorado de entidade-relacionamento \(EER\),265–298
	+  estudo de caso,295–298
	+ categorias ou tipos de união, 286–292, ver também categorias ou tipos de união
	+  definido,265
	+  abordagens de design: de cima para baixo e de baixo para cima,269
	+ Metodologia de projeto de ER, 274–275, 292–294
	+  exercícios,294–295
	+  generalizações ou especializações, *ver*generalizações ou especializações
	+  gramática para,275–276
	+  subclasses de subclasses,283–286
	+  resumo,294

+ entidade\(s\) adicionando mais de duas, 206–209 definidas, no banco de dados, 73–75 conjuntos de entidades, 73–74 generalizações \(entidades amplas\), 74 instância, 74 restrição de integridade, 49 proprietário \(identificador\), 180, 182, 184–186 primário, 74–75 regular \(forte\), 84, 179 relacionamento entre entidades, 73, 74 relacionamentos se desenvolvendo em, 204–206 especializações \(entidades estreitas\), 74 forte, veja entidades fortes que evoluem de atributos, 209–213, 214–216 fraco, veja entidades fracas 
+ restrição de integridade da entidade, 49, 54 
+ Diagramas ER “somente entidade” com atributos, 76–79, 326–327
+  diagrama entidade-relacionamento \(ER\),71–105
	+  atributos no primeiro diagrama “somente entidade”,76–79
	+  tipos de atributos e propriedades,79–86
	+  estudo de caso,100–104
	+ Modelo tipo Chen, 76–79, 84
	+  definições de banco de dados,73–75
	+  esquema de modelagem de dados,71–72
	+  descrição de,72
	+ Metodologia de projeto de ER, 75, 88, 92–94
	+  exercícios,99–100
	+  gramática para,87–94
	+  mapeamento para banco de dados relacional,94–98
	+ ciclo de vida da engenharia de software e, 3, 7–9
	+  resumo,99

+  diagrama entidade-relacionamento \(ER\), além da primeira entidade,107–128
	+  atributo ou relacionamento?,117–119
	+ relacionamento binário, 111, 114
	+  estudo de caso,120–128
	+  alterando atributo para uma entidade,108
	+  definindo um relacionamento para uma nova entidade,109–111
	+  definição de segunda entidade,112–116
	+ Metodologia de projeto de ER, 111, 118–119
	+  exercícios,119–120
	+  existência de relacionamento,117
	+ gramática para, 112, 115
	+  mapeamento para banco de dados relacional,124–128
	+  resumo,119

+  diagramas de entidade-relacionamento \(ER\) com relacionamentos binários, extensões em design,201–238
	+  notação ER alternativa para especificar restrições estruturais em relacionamentos,228–230
	+ atributos que evoluem para entidades, adicionando mais, 209–213, 214–216
	+  estudo de caso,235–237
	+  relação derivada ou redundante,224–228
	+ Metodologia de projeto de ER, 202, 207, 223, 226, 230–232, 235
	+  exercícios,234–235
	+ gramática para, 203–204, 206, 231–232
	+  regras de mapeamento para relacionamentos recursivos,232–233
	+  mais de duas entidades,206–209
	+ relacionamentos múltiplos, 206–208, 222–224
	+ relacionamentos recursivos, 216–222, veja também relacionamentos recursivos
	+ atributos de relacionamento, 201–204, 213
	+  relacionamentos se desenvolvendo em entidades,204–206
	+  resumo,234

+  operação de equijoin,57–59 
+ Diagramas ER básicos, veja diagrama entidade-relacionamento \(ER\) além da primeira entidade, veja diagrama entidade-relacionamento \(ER\), além da primeira entidade com relacionamentos binários, veja diagramas entidade-relacionamento \(ER\) com relacionamentos binários, extensões em design modelo ER aprimorado, veja modelo entidade-relacionamento \(EER\) aprimorado engenharia reversa, veja engenharia reversa do banco de dados relacional para o diagrama ER/EER ternário e de ordem superior, veja diagramas ER ternários e de ordem superior 
+ exercíciosModelo Barker/Oracle-like, 340–341Dados, bancos de dados e processo de engenharia de software, 10Extensões de design para diagramas ER com relacionamentos binários, 234–235Design de diagrama ER, 99–100Design de diagrama ER, além da primeira entidade, 119–120Modelo ER aprimorado, 294–295Modelo relacional e dependências funcionais, 68–69Relacionamentos/restrições estruturais, 168–172Engenharia reversa e mapeamento relacional, 322–324Diagramas ER ternários e de ordem superior, 262–263Entidades fracas, 194
**
+   F** 
+  FD, *ver*dependência funcional 
+ campos de dados, 12, 72 
+ arquivos, 12, 72 sequenciais, 16–17
+  sistemas de arquivamento nos primeiros dias da computação,17 
+ primeira forma normal \(1NF\), 35, 40–43, 306 
+ chave estrangeira no modelo Barker/Oracle, 334, 336 definido, 21, 41 na entidade de interseção, 206 na engenharia reversa, 308, 314, 316–317 
+ plena opcionalidade/participação, 26, 135
+  participação plena, *veja também*restrições de participação
	+ restrições, 135, 137, 153
	+  regras de mapeamento, *ver*mapeando relacionamentos binários para banco de dados relacional
	+ padrão de gramática para, 139, 140, 150–151, 152
	+  em relacionamentos ternários,249–250

+  dependências funcionais \(DF\), *veja também*modelo relacional e dependências funcionais
	+  definição de,38–39
	+  e formas normais,31
	+  dependência parcial,49
	+  reflexivo,45
	+  dependência transitiva,55

+  regras de dependência funcional,59–65
	+ regra de aumento, 60, 64
	+  regra de decomposição,60–61
	+  regra de aumento duplo,64
	+  regra reflexiva,60
	+  regra de subconjunto,61
	+  regra transitiva,61
	+  regra sindical,61

**
+  G** 
+  generalizações, *veja também*superclasses
	+ definição de, 74, 265–267
	+  superclasses,265–267

+  generalizações ou especializações,265–283
	+ definição de, 74, 265–267
	+ Metodologia de projeto de ER, 274–275, 292–294
	+ exemplos de, 266, 268–274
	+  gramática para relacionamentos,275–276
	+  juntar operações,268–269
	+ regras de mapeamento, 276–282, 304
	+  na engenharia reversa,318–321
	+  variantes,267–268

+  glossário,343–347 
+ descrições gramaticais para o modelo EER, 275–276 para entidades e relacionamentos, 112, 115 para entidade, 87–94 para extensões no design de diagramas ER, 203–204, 206, 231–232 para relacionamentos n-ários \(ternários e de ordem superior\), 247–252 para relacionamentos e cardinalidade, 135–147 para entidades fracas, 190–191 
+ atributo de grupo, 80, veja também atributos compostos
**
+  H** 
+  hierarquia, especialização,283 
+ modelos hierárquicos, 18, 20–28desvantagens de, 27–28com listas encadeadas, 24–26ponteiro para múltiplos filhos, 22–23relacionamentos um-para-muitos, 26, 27relacionamento pai-filho, 20–24ponteiro pai, 23restrições estruturais, 26
+  hierarquias, classe,265–267 
+ hierarquias em relacionamentos recursivos, 219, 220 
+ relacionamentos de ordem superior, 239, veja também diagramas ER ternários e de ordem superior
**
+  EU** 
+ entidade de identificação/entidade proprietária, 180, 182, 184–186 
+ herança de atributos, 265–266, 270, 286–288
+  inserir anomalia,49 
+  instância de uma entidade,74 
+ atributo de intersecção, 202, 226, 240, 242
**
+  J** 
+  atributo de junção,280 
+  juntar operações,268–269 
**
+  K** 
+ chaves, 13, 82–86candidata, 84, 98concatenada, 41, 49, 67estrangeira, veja gramática de chaves estrangeiras para, 88mínima, 59, 64–65parcial, 182, 191primária, veja chaves primáriassubstituta, 291como identificador único, 74
**
+  eu** 
+  rede, especialização,284 
+  lado esquerdo \(LHS\),46 
+ ciclo de vida da engenharia de software, 3–7, 7–9 
+ listas encadeadas, 24–26, 28, 30
**
+  M** 
+ mídia magnética para armazenamento de dados, 15, 17 
+ participação obrigatória, 26, 135, 329–330 
+ relacionamentos muitos-para-muitos no modelo Barker/Oracle, 336–340 cardinalidade em relacionamentos, 130, 131, 151–153 definido, 26, 28 mapeamento para banco de dados relacional, 160, 301–302 em relacionamentos recursivos, 220
+  relacionamento muitos-para-muitos-para-muitos,243–245 
+ relacionamento muitos-para-um, 28, 130, 131, 150–151 
+ mapeamento, 72, veja também regras de engenharia reversa no modelo do tipo Barker/Oracle, 336–340 etapas para mapear diagramas ER/EER para bancos de dados relacionais, 299–306
+  mapeando relacionamentos binários para banco de dados relacional,159–168
	+ regra 5, relacionamentos binários M:N, 160, 301–302
	+ regra 6, 1:1, um lado tem participação total, o outro lado tem participação parcial, 161, 302
	+ regra 7, 1:1, ambos os lados têm participação parcial, 163, 302
	+ regra 7A, guarde a chave, 163, 302
	+ regra 7B, crie uma nova tabela para a chave, 164, 302
	+ regra 8, 1:1, ambos os lados têm participação total, 166, 303
	+ regra 9, 1:N, lado N tem participação total, 167, 303
	+ regra 10, 1:N, lado N tem participação parcial, 168, 303

+ diagrama de entidade de mapeamento para banco de dados relacional, 94–98, 102–103regra 1, entidades fortes, 94–95, 300regra 2, atributos atômicos, 95–96, 300regra 3, atributos compostos, 96–97, 300regra 4, atributos multivalorados, 97–98, 102–103, 300
+  mapeando generalizações e especializações para banco de dados relacional,276–282
	+ regra 15, 277–280, 304
	+ regra 16, 280–281, 304
	+ regra 17, 281–282, 304
	+ regra 18, 282, 304

+ mapeamento de relacionamentos n-ários para banco de dados relacional regra 14, 259–260, 303–304 
+ mapeando relacionamentos recursivos para banco de dados relacional regra 12, 1:N, 232, 303 regra 13, M:N, 233, 303 
+ mapeamento de subclasses compartilhadas para banco de dados relacional regra 19, 285–286, 305 
+ mapeamento de superclasses, categorias ou tipos de união regra 20, mesmas chaves primárias, 291, 305 regra 21, chaves primárias diferentes, 291–292, 305 
+ mapeamento de entidades fracas para banco de dados relacional regra 11, 191–192, 301 
+ MCP \(ponteiro de múltiplos filhos\), 22–23, 28 
+ chave mínima, 59, 64–65
+  notação min/max,228–230 
+ modelosBarker/Oracle-like, veja modelo Barker/Oracle-like, veja modelo Chen-like, veja modelo Chen-like, veja modelo Chen-like, veja modelos de banco de dados ER, veja diagramas ER-relacional, veja modelo relacional e dependências funcionais-cascata, 3–4 
+ ponteiro de múltiplos filhos \(MCP\), 22–23, 28 
+ atributos multivaloradosModelo tipo Chen, 84conceito de, em modelo tipo Barker/Oracle, 333–335diagrama entidade-relacionamento, 81–82, 84gramática para, 88mapeamento para banco de dados relacional, 97–98, 102–103, 300–301em engenharia reversa, 311–314
**
+  N** 
+ relações n-árias, 239, veja também diagramas ER ternários e de ordem superior 
+ afirmações negativas, em gramática, 139, 140, 141, 250 
+ modelo de rede, 18, 28–30relacionamento muitos-para-muitos, 28grupo de repetição, 29 
+ atributos não atômicos, 34, 96, 306
+  formas normais,31
	+ primeiro \(1NF\), 35, 40–43, 306
	+ segunda forma normal \(2NF\), 44–52, 306
	+ terceira forma normal \(3NF\), 52–56, 282, 299–300, 305–306

+  normalização de tabelas,286 
+  bancos de dados normalizados,299 
+ atributos nulos, 282 campos, 13 muitos nulos, 118 e não nulos, no modelo tipo Barker/Oracle, 327–328
**
+  O** 
+  programação orientada a objetos,266–267 
+ relacionamento um-para-muitos no modelo Barker/Oracle, 331 cardinalidade em relacionamentos, 130, 132, 147–150 definido, 26, 27 mapeamento para banco de dados relacional, 167–168, 303 em relacionamentos recursivos, 219–220 em engenharia reversa, 308–311 
+ cardinalidade em relacionamentos um-para-um, 130, 131, 133, mapeamento para banco de dados relacional, 161–166, 302–303, em relacionamentos recursivos, 219, em engenharia reversa, 308 
+ restrições de opcionalidade, parciais ou totais, 26, 135 
+ participação opcional, 135, 149, 329–330
+  Corporação Oracle,325 
+ relacionamentos sobrepostos, restrição definida, regra de mapeamento 272, 282, 304 em engenharia reversa, 319–320, 321 
+ entidade proprietária/entidade identificadora, 180, 182, 184–186
**
+  P** 
+ relação pai-filho no modelo hierárquico, 20–25, 268–269
+  dependência parcial,49 
+ chaves parciais, 182, 191 
+ opcionalidade/participação parcial, 26, 135
+  participação parcial,135
	+  regras de mapeamento, *ver*mapeando relacionamentos binários para banco de dados relacional
	+  e valores nulos,303
	+ padrão de gramática para, 139, 140, 148, 152–153
	+  em relacionamentos recursivos,219
	+ em relações ternárias, 243, 251–252

+ restrições de participação, 129, 134–135 no modelo Barker/Oracle, 329–330 para categorias ou tipos de união, 288–290 total, 135, veja também participação total parcial, 135, veja também participação parcial em engenharia reversa, 308, 319–320 para entidades fracas, 182
+  padrões de relacionamentos binários,138–147
	+ padrão 1, 139, 141–142, 150–151, 158–159, 207
	+ padrão 2, 139–140, 142–143, 149–150
	+ padrão 3, 140, 143–144, 151, 152, 159, 249
	+ padrão 4, 140–141, 144–146, 148–149, 152–153, 207
	+ padrão 5, 250

+ ponteiros, 27, 30 
+ predicado definido, 272–274, 320–321
+  entidade primária,74–75 
+ chave primária no modelo Barker/Oracle, 328 chave candidata como, 84 em categorias ou tipos de união, 291–292 definindo em R, 40 chave estrangeira, 21 em dependência funcional, 38, 46 regra de mapeamento, 94–95 de entidades fracas, 179, 186, 190, 191 
+ cartões perfurados, 15, 16
**
+  R** 
+ registros, 12, 73 
+ relacionamentos recursivos, 111, 216–222 no modelo Barker/Oracle, 336 hierarquia, 219, 220 muitos para muitos, 220 regras de mapeamento, 232–233, 303 um para muitos, 220 um para um, 219 participação parcial de, 219 restrições estruturais e, 219
+  VERMELHO \(diagrama de engenharia reversa\),306 
+ redundância, 18, 53
+  relacionamento redundante,224–228 
+  dependências funcionais reflexivas,45 
+  regra reflexiva,60 
+ entidades regulares \(fortes\), 84, 179
+  dados relacionados,7 
+  cálculo relacional,57 
+ bancos de dados relacionais, 2, 11, 33–36, veja também mapeamento, mapeamento de generalizações ou especializações, 276–282, mapeamento de relacionamentos n-ários para, 259–260, mapeamento de diagrama de entidade para, 94–98, 102–103, mapeamento de relacionamentos recursivos, 232–233, mapeamento de relacionamentos para, 159–168, mapeamento de entidades fracas para, 191–193 e conjuntos, 36–38, etapas usadas para mapear diagramas ER/EER para, 299–306 
+ mapeamento relacional, 299–306, veja também exercícios de mapeamento, 323–324 resumo, 322 
+ modelo relacional e dependências funcionais, 31, 33–69 forma normal de Boyce–Codd, 65–67 operação de junção equidistante, 57–59 exemplos, 61–64 exercícios, 68–69 primeira forma normal, 40–43 dependência funcional, 59–65, veja também dependências funcionais \(DF\) fundamentos de banco de dados relacional, 33–36 segunda forma normal, 44–52 conjuntos de atributos, 60 resumo, 68 terceira forma normal, 52–56 tabelas bidimensionais, 33–34, 42
+  relações,37 
+ atributos de relacionamento, 201–204, 213 
+ relacionamentos no modelo Barker/Oracle, 329 binário, 111, 114, veja também relacionamento binário proporção de cardinalidade, 129–134 definição de, 73, 74 grau de, 111 derivado \(redundante\), 224–228 desenvolvido em entidades, 204–206 gramática para, 112 ordem superior, 239 múltiplo, com duas entidades, 222–224 opcionalidade, 26 recursivo, veja relacionamento recursivo de relacionamentos \(ternário\), 252–254 não está claro se possivelmente é atributo, 117–119 situações pouco claras, 117
+  relacionamentos, razão de cardinalidade de,26
	+  muitos para muitos, *ver*relacionamentos muitos-para-muitos
	+ muitos para um, 28, 130, 131, 150–151
	+  um para muitos, *ver*relacionamento um-para-muitos
	+  um para um, *ver*relacionamento um-para-um

+  relacionamentos/restrições estruturais, estendendo,129–178
	+  razão de cardinalidade do relacionamento,129–134
	+  estudo de caso,172–178
	+ Metodologia de projeto de ER, 146–147, 154–158, 172, 176
	+  exemplos de outros relacionamentos,147–153
	+  exercícios,168–172
	+  exemplo final,153–159
	+  gramática para,135–147
	+ mapeamento de relacionamentos para banco de dados relacional, 159–168, veja também mapeamento de relacionamentos binários para banco de dados relacional
	+  restrições de participação \(total/parcial\),134–135
	+ padrões de relacionamentos binários, 138–146, veja também padrões de relacionamentos binários
	+  resumo,168

+ grupo de repetição, 29, 35, 40
+  diagrama de engenharia reversa \(RED\),306 
+  engenharia reversa de banco de dados relacional para diagrama ER/EER,306–322
	+  exercícios,323–324
	+  para modelar um banco de dados,72
	+  passos, *ver*regras de engenharia reversa
	+  resumo,322

+  regras de engenharia reversa,306–322
	+  regra 1: entidades fortes,307
	+  regra 2: relacionamentos 1:1 e 1:N \(1:x\),308–311
	+  regra 2a: atributos do relacionamento 1:x,311
	+  regra 3: entidades fracas e atributos multivalorados,311–314
	+  regra 3a: entidades fracas,314
	+  regra 3b: atributos multivalorados,314–316
	+  regra 4: relacionamentos M:N e n-ários,316
	+  regra 4a: caso binário,316
	+  regra 4b: caso n-ário,316–318
	+  regra 5: relações de generalização/especialização,318–319
	+  regra 5a: relacionamentos com relacionamentos disjuntos ou sobrepostos,319–320
	+  regra 5b: relacionamentos disjuntos com atributos definidos por predicado único,320–321
	+  regra 5c: sobrepor relacionamentos com mais de uma bandeira,321
	+  regra 6: subclasses compartilhadas,321
	+  regra 7: categorias ou tipos de união,321–322

+ linhas, 37–38, 94
**
+  S** 
+  esquema,72 
+  SE, *ver*processo de engenharia de software 
+  segunda forma normal \(2NF\),44–52
	+  anomalias,48–49
	+  diagramas de mapeamento para banco de dados,306
	+  não-2NF para 2NF,49–52

+ modelos semânticos, 71, 72 
+ conjuntos de atributos, 60 de arquivos \(conjuntos de entidades\), 73–74 e bancos de dados relacionais, 36–38 
+ subclasses compartilhadas definidas, 284mapeamento de generalizações e especializações, 285, 305em engenharia reversa, 321superclasse em hierarquia, 286
+  atributos simples, *ver*atributos atômicos \(simples\) 
+ Número de Seguro Social \(SSN\), 38, 80, 84
+  ciclo de vida da engenharia de software em diagramas entidade-relacionamento,7–9 
+  processo de engenharia de software,3–7
	+ design de banco de dados, 5, 9
	+  desenvolvimento,6
	+  implementação e testes de usuário,6
	+  manutenção,6
	+ requisitos \(esclarecimento\), 5, 8, 75
	+  aposentadoria de software,6–7
	+ especificação \(com feedback\), 4, 5, 8–9, 75

+  pacotes de software,16 
+  hierarquia de especialização,283 
+  rede de especialização,284 
+ especializações, veja também generalizações ou especializações; Subclasses definição de, 74, 265–267 exemplos de, 266, 268–274 regras de mapeamento, 276–282 subclasses, 265–267 variantes, 267–268
+  atributos específicos,271 
+  SQL \(Linguagem de Consulta Estruturada\),57 
+ SSN \(Número do Seguro Social\), 38, 80, 84
+  entidades fortes,84–85
	+ mapeamento em banco de dados relacional, 94–95, 300
	+  na engenharia reversa,307
	+  entidades fracas e,179–184

+  restrições estruturais, *veja também*relacionamentos/restrições estruturais, estendendo
	+  notação alternativa para especificar, em relacionamentos,228–230
	+  no modelo do tipo Barker/Oracle,329–332
	+  relações binárias,240
	+  cardinalidade e opcionalidade,26–27
	+  cardinalidade e participação,129
	+  definido,129
	+  relacionamentos recursivos e,219
	+  para relacionamentos ternários,243–245
	+  e entidades fracas,184

+  Linguagem de Consulta Estruturada \(SQL\),57 
+ subclasses definidas como especializações, 265–267 exemplo em design de banco de dados, 268–270 herança de atributos, 266, 270 em engenharia reversa, 319–320 compartilhados, veja subclasses compartilhadas
+  subclasses de subclasses,283–286
	+  regra de mapeamento,285–286
	+  subclasse compartilhada,284
	+  hierarquia de especialização,283
	+  rede de especialização,284

+  regra de subconjunto,61 
+ superclasses, categoria ou tipo de união e, 286–287, definidas como generalizações, 265, 267, exemplo em design de banco de dados, 268–270, herança de atributos, 266, regras de mapeamento, 291–292, 305, em engenharia reversa, 321–322
+  chave substituta,291 
**
+  T** 
+ tabelas descrição, 33–35 junções, operações de combinação, 268–269 normalização de, 286 bidimensional, 33–34, 42
+  diagramas ER ternários e de ordem superior,239–263
	+  relação binária ou ternária?,240–243
	+ Metodologia de projeto de ER, 248, 260–261
	+  exercícios,262–263
	+  gramática para relacionamentos n-ários,247–252
	+ mapeamento de relacionamentos n-ários para banco de dados relacional, 259–260, 303–304
	+  relação n-ária,239
	+  relação n-ária, exemplo de,245
	+  relacionamentos n-ários e relacionamentos binários,246–247
	+  relacionamentos n-ários resolvendo-se em relacionamentos binários,254–258
	+  na engenharia reversa,316–318
	+  restrições estruturais,243–245
	+  resumo,261–262
	+  relações ternárias de situações de relacionamento-relacionamento,252–254

+ terceira forma normal \(3NF\), 52–56, 282, 299–300, 305–306 
+ Relações 3-árias, 239, veja também diagramas ER ternários e de ordem superior
+  abordagem de design de cima para baixo,269 
+  dependência transitiva,55 
+  regra transitiva,61 
+  tuplas,94 
+ tabelas bidimensionais, 33–34, 42, 94
**
+  Você** 
+ relações unárias, 216, veja também relações recursivas
+  regra sindical,61 
+  tipo de união, *ver*categorias ou tipos de união 
+ atributos de identificador únicos como, 79 no modelo tipo Barker/Oracle, 332–333 chave candidata como, 84–85 modelo ER tipo Chen, 84 chave, 74 chave primária como, 84 entidades fortes e, 179
+  anomalia de atualização,48–49 
+ usuários, 4, 7–8
**
+  V** 
+  VARCHAR,45 
+  variantes,267–268 
**
+  C** 
+  modelo em cascata,3–4 
+ entidades fracas, 84, 179–200 estudo de caso, 194–199 conceito de, no modelo tipo Barker/Oracle, 332–333 conectado a outras entidades fracas, 186–188 metodologia de design ER, 189–190, 195 exercícios, 194 em generalizações/especializações, 269–270 gramática para, 190–191 entidade identificadora/proprietária, 180, 182, 184–186 mapeamento para banco de dados relacional, 191–193, 301 em relacionamento de relacionamento, 253 em engenharia reversa, 311–314 entidades fortes e fracas, 179–184 restrições estruturais, 184 resumo, 193



